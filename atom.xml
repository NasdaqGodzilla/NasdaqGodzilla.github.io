<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PeaceMaker</title>
  
  <subtitle>神在码先，绵绵不绝！</subtitle>
  <link href="https://nasdaqgodzilla.github.io/atom.xml" rel="self"/>
  
  <link href="https://nasdaqgodzilla.github.io/"/>
  <updated>2024-05-29T13:17:38.679Z</updated>
  <id>https://nasdaqgodzilla.github.io/</id>
  
  <author>
    <name>Niko aug3073911@outlook.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>显示系统稳定性：Kernel模块加载顺序和i2c漏电导致的花屏问题</title>
    <link href="https://nasdaqgodzilla.github.io/2024/05/29/%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9AKernel%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Ci2c%E6%BC%8F%E7%94%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E8%8A%B1%E5%B1%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://nasdaqgodzilla.github.io/2024/05/29/%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9AKernel%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Ci2c%E6%BC%8F%E7%94%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E8%8A%B1%E5%B1%8F%E9%97%AE%E9%A2%98/</id>
    <published>2024-05-29T13:15:58.000Z</published>
    <updated>2024-05-29T13:17:38.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>研发一个机型的过程中出了点意料之外的问题。在关机状态下，进行电源适配器（DC）连续插拔测试时，在特定操作下会有概率性出现花屏现象，而且花屏现象不一致不统一。</p><p>现象如下图所示。图中无关紧要的位置打了马赛克，bug的问题现象是屏幕显示的内容花了。虽然都是关机充电界面花屏，但是花的内容款式有几种不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E6%A6%82%E7%8E%87%E6%80%A7%E8%8A%B1%E5%B1%8F%E7%8E%B0%E8%B1%A1.png"></p><p>Failed Rate：每7-8次出现1次；测试未发现与特定屏型号、特定屏单体、特定主板单体有关。与特定操作和场景强相关。</p><p>步骤：设备处于关机状态下 → 接入DC电源 →设备因关机充电而自动开机 → 显示开机logo → 显示充电动画 → 如果发现充电动画正常，则立刻拔出DC，然后尽快马上再次插入，再次循环；如果花屏，则问题复现。</p><p>平台：CPU  →  mipi  →  IT6151  →  eDP  →  TCON→ SOURCE IC → LCD</p><h1 id="异常分析"><a href="#异常分析" class="headerlink" title="异常分析"></a>异常分析</h1><h2 id="软件出图分析：动画无异常、软件出图无特殊逻辑"><a href="#软件出图分析：动画无异常、软件出图无特殊逻辑" class="headerlink" title="软件出图分析：动画无异常、软件出图无特殊逻辑"></a>软件出图分析：动画无异常、软件出图无特殊逻辑</h2><p>分析显示问题的时候，第一步可以先看看我们从CPU出来的画面本身是否正常的。一般花屏可以通过截图和投屏、录屏来确认图源的正常情况，但是我们是在关机充电画面，Android尚未启动，故无法进行这类操作。</p><p>从现象上看，出问题的时候开机logo不花，充电动画花了。一般来说，花屏和屏的上下电时序、波形质量有关系，通常喜欢在亮屏就花。但是碰到的问题是亮屏的时候并不花，而是一段时间后才花，看来不能直接去找时序的锅。</p><p>因此结合关机充电这个场景，不排除是充电动画解析和显示的异常，包括充电动画对屏和背光的操作有时序异常。因此首先在问题出现后借助串口日志分析动画和屏操作日志。</p><p>此外，该机型有引入MTK AAL功能、上层PQ功能，因此SoC端的CABC功能或PQ模式可能有影响，也进行分析。</p><blockquote><p>AAL功能和PQ功能是芯片厂商提供的调节画质的接口。</p></blockquote><table><thead><tr><th>Action</th><th>小结</th><th>结论</th></tr></thead><tbody><tr><td>动画日志分析</td><td>正常</td><td rowspan="5">关机充电动画部分没有异常，软件出图没有明显异常，电信号操作没有差异</td></tr><tr><td>开关、背光日志分析</td><td>正常</td></tr><tr><td>正常、异常日志对比；<br>新、老版本日志对比；<br>与drvier only版本对比；</td><td>没有差异</td></tr><tr><td>PQ影响</td><td>确认PQ服务在该阶段不会生效</td></tr><tr><td>AAL影响</td><td>AAL没有源码，但根据文档确认在关机充电阶段不会生效。<br>此外，软件关闭ALL编译开关后，问题仍能复现</td></tr></tbody></table><h2 id="做实验缩小范围：发现问题不在屏端、TCON端"><a href="#做实验缩小范围：发现问题不在屏端、TCON端" class="headerlink" title="做实验缩小范围：发现问题不在屏端、TCON端"></a>做实验缩小范围：发现问题不在屏端、TCON端</h2><p>前面的实验表面CPU出来的画面应该没有问题，而且花屏的时候每次花的内容基本不相同，和正常显示的内容看着也不相干，因此向更底层的方向去分析。</p><table><thead><tr><th>Action</th><th>小结</th><th>结论</th></tr></thead><tbody><tr><td>同主板同软件搭配A型屏</td><td>复现</td><td rowspan="3">花屏问题和屏、TCON无关</td></tr><tr><td>同主板同软件搭配B型屏</td><td>复现</td></tr><tr><td>硬件飞线，将TCON Core 1V8接开关，在问题复现后，手动开关该开关，等价重启TCON</td><td>复现后拨动、拨回开关，现象还在</td></tr><tr><td>屏单体问题分析</td><td>测试资源不够、时间紧张，未测</td><td>结合上面的结论（和屏无关），因此和屏单体也无关</td></tr></tbody></table><h2 id="6151信号稳定性、电源稳定性和软件逻辑分析：无异常（除eDP和MIPI信号无法分析）"><a href="#6151信号稳定性、电源稳定性和软件逻辑分析：无异常（除eDP和MIPI信号无法分析）" class="headerlink" title="6151信号稳定性、电源稳定性和软件逻辑分析：无异常（除eDP和MIPI信号无法分析）"></a>6151信号稳定性、电源稳定性和软件逻辑分析：无异常（除eDP和MIPI信号无法分析）</h2><blockquote><p>6151是mipi to eDP芯片，CPU出来的画面发送给它，它处理后再发送给屏幕</p></blockquote><p>前面步骤分析认为CPU出图、TCON均没有异常，因此围绕6151进行分析。</p><p>保障6151稳定运行的两个条件是：</p><ol><li>软件下的配置正确</li><li>时序正确且各电信号稳定</li></ol><p>梳理6151几个关键监测点，准备挂示波器和逻辑分析仪：</p><ol><li>6151可以通过MIPI DSI下发指令、切换模式</li><li>6151可以通过I2C下发指令、切换模式</li><li>关键电信号包括几个GPIO、LDO、VDD（1V2、1V8、3V3、eDP使能、RST）的时序及波形</li></ol><p>此外，在eDP驱动中初始化完成后dump寄存器，在进入充电界面时再次dump，排查意外没发现的SoC对6151的配置、6151寄存器变化、或6151自己跑飞了。</p><table><thead><tr><th>Action</th><th>小结</th><th>结论</th></tr></thead><tbody><tr><td>1V2、1V8、3V3使能、eDP使能、RST的时序、波形（从开机到花屏发生）</td><td>未见异常</td><td>关键电信号的时序和质量正常</td></tr><tr><td>review软件配置正确</td><td>未见异常</td><td>软件配置符合要求，不涉及屏参</td></tr><tr><td>开机logo后（屏亮起后）6151 I2C监测，有一次意料之外的Write和Read</td><td>没有挂逻辑分析仪，不能直接简单从示波器看到通信内容，不能排除软件这次通信是否让6151发生了变化，致使花屏</td><td rowspan="2">没有对6151有重新初始化、切换模式、修改参数等操作<br>i2c通信没有影响花屏，也不影响概率</td></tr><tr><td>出新软件，移除掉这个I2C通信<br>（分析驱动，发现6151驱动确实有个i2c读写，但是这个是状态dump，可以直接去掉不影响功能）</td><td>示波器体现，i2c通信已经去除<br>花屏现象仍然能保持复现<br>且少量手工验证下，复现概率没有变化</td></tr><tr><td>6151寄存器dump<br>（改动量较大，需要在关机动画那里进行dump。接下来问题有更明确的进展，没来得及做这个实验）</td><td>/</td><td>/</td></tr><tr><td>是否通过MIPI DSI向6151发出指令</td><td>软件排查没有走过MIPI DSI通道<br>无仪器分析</td><td>如果存在该情况，则问题不应该是概率性的</td></tr></tbody></table><p>坑：回顾问题分析过程，这里有个漏掉的信号（V3P3A）没有分析到（而是只量取了使能）。因为这个信号，我们有惯性思维，会认为它是稳定常开的，因此没有量它的波形。</p><blockquote><p>我们分析到后面才发现是这个信号有异常掉0，它导致了花屏</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LCM3v3%E4%BE%9B%E7%94%B5.png"></p><h2 id="花屏伴随着L-Sensor-通信异常；发现前级电源有短暂异常掉电；L-Sensor-通信异常导致前级掉电"><a href="#花屏伴随着L-Sensor-通信异常；发现前级电源有短暂异常掉电；L-Sensor-通信异常导致前级掉电" class="headerlink" title="花屏伴随着L-Sensor 通信异常；发现前级电源有短暂异常掉电；L-Sensor 通信异常导致前级掉电"></a>花屏伴随着L-Sensor 通信异常；发现前级电源有短暂异常掉电；L-Sensor 通信异常导致前级掉电</h2><p>截止目前我们并没有发现什么太异常的东西，没有线索去指引分析。但是在串口日志中发现一个奇怪的现象，花屏的时候，都伴随着光感传感器I2C通信异常。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.362148]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c_dump_info: -----------------------</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.362969]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: last transfer info:</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.363699]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[00]</span> <span class="comment">[    4.343075]</span> SLAVE_ADDR=86,INTR_STAT=2,CONTROL=28,FIFO_STAT=1101,DEBUGSTAT=300, tmo=500</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.365236]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[01]</span> <span class="comment">[    3.710385]</span> SLAVE_ADDR=48,INTR_STAT=2,CONTROL=28,FIFO_STAT=1210,DEBUGSTAT=300, tmo=500</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.366781]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[02]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.368221]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[03]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.369661]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[04]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.371108]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[05]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.372549]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[06]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.373989]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[07]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.375436]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[08]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.376877]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: <span class="comment">[09]</span> <span class="comment">[    0.000000]</span> SLAVE_ADDR=0,INTR_STAT=0,CONTROL=0,FIFO_STAT=0,DEBUGSTAT=0, tmo=0</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.378323]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span>i2c i2c-1: addr:0x43,ACK error</span><br><span class="line"><span class="comment">[2024-05-16 10:13:58]</span>  <span class="comment">[    4.379064]</span> &lt;5&gt;.(5)<span class="comment">[1:swapper/0]</span><span class="comment">[ALS]</span> gt4421_i2c_read_reg 162 : read reg send res = -121</span><br></pre></td></tr></table></figure><p>软件逻辑上光感传感器与显示无关，排查发现光感传感器与6151不在同一路I2C，但是会共用前级电源（V3P3A）。因此两者之间可能有关联，先来看看这个i2c通信失败和花屏有没有关联。</p><p>电路图如下，LCM电源会使用V3P3A这路电。它和光感传感器是共用的电源。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LCM%E5%85%AC%E7%94%A8v3p3a.png"></p><table><thead><tr><th>Action</th><th>小结</th><th>结论</th></tr></thead><tbody><tr><td>日志看花屏现象伴有L-Sensor的I2C通信异常</td><td>花屏和L-Sensor可能不是巧合，有相关性，要证明是否因果关系，需要用示波器确认时间点</td><td rowspan="2">L-Sensor通信失败，相关或因果地，使V3P3A短暂掉到底<br>V3P3A会给屏供电，供电的异常有导致花屏的重大嫌疑</td></tr><tr><td>示波器抓取V3P3A波形、I2C波形<br>（V3P3A电源来自VPA_PMU，给屏、TP、L-Sensor使用）</td><td>1. 花屏发生时，L-Sensor有三次连续i2c通信（Write，无ACK）后，V3P3A短暂掉电<br>2. 摄像头录像确认，花屏是紧接着随后发生的<br>3. 异常掉电波形见下图</td></tr><tr><td>查阅L-Sensor驱动，确定会通过Regulator关闭前级电源V3P3A</td><td>驱动代码如下展示</td><td>L-Sensor通信失败，会通过regulator关闭V3P3A的输出</td></tr><tr><td>拔掉光感后进行实验</td><td>花屏现象从概率性发生，变成必现</td><td rowspan="2">花屏现象与光感通信异常情况强相关<br></td></tr><tr><td>保持光感装好，软件关闭光感驱动</td><td>花屏现象不再复现</td></tr></tbody></table><p>波形图如下所示，可以看到电源有短暂的异常掉到0。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E7%A4%BA%E6%B3%A2%E5%99%A8%E9%87%8F%E5%8F%96%E6%8E%89%E7%94%B5%E6%B3%A2%E5%BD%A2.png"></p><p>由于这一路电源是PMIC输出的，驱动能力和稳定性都较强，而且每次复现的时候波形都是一致的，因此基本认定异常波形应该是来源于软件的异常逻辑。</p><p>既然花屏的时候伴随着光感传感器的通信异常问题，那么直接定位到对应驱动代码的位置，如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">exit_create_attr_failed:</span><br><span class="line">exit_sensor_obj_attach_fail:</span><br><span class="line">exit_misc_device_register_failed:</span><br><span class="line">        misc_deregister(&amp;gt4421_device);</span><br><span class="line">exit_init_failed:</span><br><span class="line">        kfree(obj);</span><br><span class="line">        gt4421_obj = NULL;</span><br><span class="line">        <span class="keyword">if</span>(regulator_disable(rgb_3v3))&#123;</span><br><span class="line">                APS_ERR(<span class="string">&quot;gt4421 disable regulator failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">exit</span>:</span><br><span class="line">        gt4421_i2c_client = NULL;</span><br><span class="line">        APS_ERR(<span class="string">&quot;%s: err = %d\n&quot;</span>, __func__, err);</span><br><span class="line">        gt4421_init_flag = -<span class="number">1</span>;</span><br><span class="line">        return err;</span><br><span class="line">        </span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这段代码是光感传感器初始化（probe）过程中，碰到i2c通信失败，即没有与传感器正常通信的情况下，走的失败逻辑。其中的关键代码是<code>regulator_disable(rgb_3v3)</code>，它通过regulator接口关闭了3.3V的电源供电，因此造成了供电电源的异常波形。</p><p>由于这一路电源同时给屏供电，因此这一异常的电源波形使屏端的逻辑出现异常，进一步导致了花屏现象的发生。</p><h2 id="L-Sensor概率性通信异常根因：SDA-x2F-SCL台阶问题"><a href="#L-Sensor概率性通信异常根因：SDA-x2F-SCL台阶问题" class="headerlink" title="L-Sensor概率性通信异常根因：SDA&#x2F;SCL台阶问题"></a>L-Sensor概率性通信异常根因：SDA&#x2F;SCL台阶问题</h2><p>从前面的分析可以确定，我们发现了事故的直接原因。即光感传感器初始化失败，其驱动代码关闭了前级电源，致使屏的电源异常，导致花屏。</p><p>问题的“概率性”来源。实际上花屏不是“概率性”的，只要是V3P3A掉电了，必定会花屏。而“概率性”的来源是L-Sensor概率性的通信异常。因此问题转向为分析光感传感器概率性通信异常的原因。</p><p>L-Sensor本身比较简单，其电信号总共只有使能、i2c两根线，加起来3个信号。</p><table><thead><tr><th>Action</th><th>小结</th><th>结论</th></tr></thead><tbody><tr><td>示波器量取RGB_PWR_EN</td><td>未见异常</td><td>光感传感器概率性通信异常不是因为它自己的供电有问题</td></tr><tr><td>i2c影响（驱动能力）</td><td>检查该路i2c已经配置CPU内部上拉，且L-Sensor本身具备内部上拉</td><td rowspan="3">与i2c干扰无关，与同一路i2c上的重力传感器无关，i2c链路未见异常</td></tr><tr><td>i2c影响（其他client）</td><td>该路i2c还插着g-sensor，贴在板上无法拿下，软件关闭驱动后复测，可复现花屏</td></tr><tr><td>i2c影响（波形）</td><td>示波器体现，波形健康</td></tr><tr><td>示波器量取SDA波形</td><td>SDA进入工作状态前，有0.7V台阶，自CPU IO reset后就存在</td><td rowspan="2">i2c开始工作前有异常电平，有较大嫌疑（异常波形放在“异常根因”小结展示）</td></tr><tr><td>示波器量取SCL波形</td><td>SCL进入工作状态前，有0.7V台阶，自CPU IO reset后就存在</td></tr><tr><td>临时措施，将台阶压下去</td><td>i2c启用前，将SDA、SCL的电放掉，让台阶下来</td><td>异常电平压下去后，i2c不再复现异常通信的情况，花屏不再复现</td></tr></tbody></table><p>到这里，问题不再复现了，我们从找到花屏的直接诱因，并顺藤摸瓜到找到了根本的原因。</p><h1 id="异常根因"><a href="#异常根因" class="headerlink" title="异常根因"></a>异常根因</h1><p>在最前面先展示一下异常波形，如下图。</p><p>其中，紫色、蓝色线分别代表L-Sensor（光感传感器）的i2c的SDA和SCL两根线。图上有相应标注，特别说明的，这个图是导入了解决措施后抓取的。在图的左半部分有标记出来的“异常的台阶”，它就是异常的电平。中部标记的“放电，压下台阶”是导入了措施后。未导入前的异常情况下，这个台阶没有放电过程，一直有不小的台阶存在。</p><blockquote><p>SDA和SCL一高一低，原因是示波器选取的0基准线的位置的差异，实际上它们电平相等</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E7%A4%BA%E6%B3%A2%E5%99%A8%E9%87%8F%E5%8F%96%E5%8F%B0%E9%98%B6%E6%94%BE%E6%8E%89%E7%94%B5%E5%90%8E%E7%9A%84%E6%B3%A2%E5%BD%A2_%E5%B8%A6%E6%88%AA%E5%9B%BE%E8%AF%B4%E6%98%8E.png"></p><p>首先来解释一下在解决措施导入前，L-Sensor会概率性通信失败的原因。</p><p>我们通过示波器看到，L-Sensor i2c线上有一些抬起来的电平（台阶）。由于这个台阶不算小，而且这一型号的L-Sensor本身器件设计、制造上带来的电气特性，使得台阶（即i2c线路上的电压），顺着i2c线及L-Sensor芯片内部的电路，对其灌入电流。灌入的电流相当于对芯片进行了半残废的供电，可能会导致其处于半工作状态。</p><p>但由于不是正常的正确的供电，因此内部逻辑可能紊乱，就像程序引用空指针一样行为是未定义的，会出现概率性的通信异常。</p><blockquote><p>当然，平时i2c正常工作都是拉高的，这个时候为什么不怕灌电流呢？因为在正常情况下，L-Sensor是有正常电源供电的，i2c上的电流灌不进来，或者是L-Sensor已经正常启动了，不再像灌电流那样跑飞了</p></blockquote><p>至于i2c为什么会出现台阶，分析下电路图可以发现，i2c的两根线是从CPU的引脚上出来的，CPU初始化后，引脚处于悬空态，因此有台阶电平出来。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">flowchart</span> <span class="comment">LR</span></span><br><span class="line">    <span class="comment">开机</span> --&gt; <span class="comment">GPIO初始化</span> --&gt; <span class="comment">i2c线所在引脚悬空</span> --&gt; <span class="comment">产生电平台阶</span> --&gt; <span class="comment">对光感传感器灌电</span> --&gt; <span class="comment">光感传感器i2c概率性通信异常</span></span><br></pre></td></tr></table></figure><p>开机过程中，L-Sensor的驱动会尝试与L-Sensor进行i2c通信。当通信失败时，驱动代码逻辑将V3P3A下电了，影响了屏的电源稳定性，导致花屏。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">flowchart</span> <span class="comment">LR</span></span><br><span class="line">    <span class="comment">光感传感器i2c概率性通信异常</span> --&gt; <span class="comment">regulator_disable</span> --&gt; <span class="comment">屏的电源有异常掉电</span> --&gt; <span class="comment">屏工作异常</span> --&gt; <span class="comment">花屏</span></span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>对于L-Sensor而言，其器件特性决定了无法耐受住i2c上小台阶（0.7V作用）的灌电，使得L-Sensor ic处于半工作半死、没正常运行的阶段。</p><p>从SDA&#x2F;SCL漏进去的电让内部ic错乱了，使得L-Sensor不再正常工作、不能正常启动。换句话说，即使器件没有上电，i2c漏进去的电使得器件实际上不是完全没电的，接下来的启动时序实际上不一定满足要求。</p><p>因此，解决这个问题很简单，要么让这个台阶不出现，要么出现后让它消失。</p><p>L-Sensor的电路图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/RGB_i2c_.png"></p><p>查看电路和规格书有如下几个重要的信息，用于决策我们的解决方案。</p><ul><li>L-Sensor有一个电源，用于供电。它是常开的，很前级的电，影响很大，不能想着用它来放电；且它内部连接是PMIC的一个LDO，用于放电可能有其他异常————不能切断漏电路径，也不能用于放电。</li></ul><blockquote><p>就是这路电和屏共用的，被异常放掉了，出了花屏问题</p></blockquote><ul><li>SCL1直接接CPU I2C1，在RGB_3V3上拉没有使能的情况下，显然SCL和SDA的台阶就是SCL1自己导致的————台阶是CPU输出的</li><li>漏电路径看————SCL1可以放电下掉台阶</li><li>漏电路径看————RGB_3V3可以放电下掉台阶，但是有电阻，且属于CPU的两个GPIO之间有电流灌入流出</li></ul><p>因此可以看到决策我们处理这个台阶的关键结论如下：</p><ol><li>台阶是CPU i2c引脚自己输出出来的，它可以想办法不输出出来，或者出来后卸掉</li><li>漏电通路上，开关漏电路径的VIO18_PMU动不得，因此通过切断传输路径的方式来切断漏电的方案不可行</li></ol><p>因此我们尝试再CPU引脚即SDA&#x2F;SCL两根线上想办法。查看规格和代码配置有一个可行方案——把CPU引脚配置成下拉或输出0————这样可以避免输出台阶，并且就算输出了台阶也可以经CPU内部电路把台阶卸掉。</p><p>SCL1内部支持下拉，本事是SCL驱动能力较强————可以灌入电流（请硬件确认过），用SCL1来放电可以达成目标。</p><p>因此改法就很清晰了：借助dws将引脚配置为下拉，将台阶电放掉，在i2c使用之前，再切换到i2c模式，接入上拉。（实际上台阶无法完全去掉，因为CPU一旦完成初始化，这个引脚就是悬空的（芯片级默认模式），就会有台阶。CPU初始化完成后一段时间才跑到软件逻辑去下拉放电）</p><p>修改如下，只需要把对应引脚拉下去即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">              <span class="tag">&lt;<span class="name">gpio84</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">eint_mode</span>&gt;</span>false<span class="tag">&lt;/<span class="name">eint_mode</span>&gt;</span></span><br><span class="line">-                <span class="tag">&lt;<span class="name">def_mode</span>&gt;</span>1<span class="tag">&lt;/<span class="name">def_mode</span>&gt;</span></span><br><span class="line">+                <span class="tag">&lt;<span class="name">def_mode</span>&gt;</span>0<span class="tag">&lt;/<span class="name">def_mode</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">inpull_en</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inpull_en</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">inpull_selhigh</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inpull_selhigh</span>&gt;</span></span><br><span class="line">-                <span class="tag">&lt;<span class="name">def_dir</span>&gt;</span>IN<span class="tag">&lt;/<span class="name">def_dir</span>&gt;</span></span><br><span class="line">+                <span class="tag">&lt;<span class="name">def_dir</span>&gt;</span>OUT<span class="tag">&lt;/<span class="name">def_dir</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">out_high</span>&gt;</span>false<span class="tag">&lt;/<span class="name">out_high</span>&gt;</span></span><br><span class="line">-                <span class="tag">&lt;<span class="name">varName0</span>&gt;</span>GPIO_I2C1_SCA_PIN<span class="tag">&lt;/<span class="name">varName0</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">smt</span>&gt;</span>false<span class="tag">&lt;/<span class="name">smt</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">ies</span>&gt;</span>true<span class="tag">&lt;/<span class="name">ies</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">gpio84</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个修改导入后，量取波形（前面展示过修改后的波形图）。可以看到i2c线的台阶会有一小段拉下来，这个操作可以把i2c线上的电拉下来，把灌入L-Sersor的电放干净，使光感传感器处于正常的状态。</p><p>经过压测后问题能成功修复，再也没有复现到L-Sensor i2c通信异常和花屏异常了。</p><h1 id="优化措施：Regulator失效了？"><a href="#优化措施：Regulator失效了？" class="headerlink" title="优化措施：Regulator失效了？"></a>优化措施：Regulator失效了？</h1><p>熟悉驱动的朋友，应该能看到一个不合理的地方。通常情况下，一些公共使用的资源，在共用这些资源的模块之间，会以特定的协作方式来控制资源的开关，防止互相干扰。比如一个智能指针，会在一个对象的引用计数降低到0的时候再回收它。</p><p>对于驱动来说，对共用电源的控制一般采用regulator。当regulator的引用计数降低到0后才真正关闭电源。</p><p>那么，在L-Sensor驱动和屏驱动均规范使用了regulator的情况下，为何屏还在用的电，仍然被L-Sensor regulator_disable关掉了呢？</p><p>经过分析，添加日志后发现，屏驱动的初始化居然在传感器后面，传感器先初始化，然后才是屏初始化。</p><p>用一个表格来说明这个逻辑，以及它是怎么触发花屏问题的。</p><blockquote><p>这个问题中共用的电源来自于PMIC，下表用PMIC输出来表示这个电源，1表示打开，0表示关闭</p></blockquote><table><thead><tr><th>开机过程顺序</th><th>跑的逻辑</th><th>PMIC输出状态</th><th>Regulator计数</th><th>备注</th></tr></thead><tbody><tr><td>PMIC初始化</td><td>根据代码配置，将PMIC输出为高电平</td><td>1</td><td>0</td><td>此时对使用该电的设备供电（屏和L-Sensor）</td></tr><tr><td>初始化L-Sensor</td><td>进入L-Sensor驱动，regulator +1</td><td>1</td><td>1</td><td>PMIC本来就输出高电平，这里+1后仍然出高电平，供电正常</td></tr><tr><td>L-Sensor通信失败</td><td>L-Sensor做异常释放逻辑，将regulator计数-1</td><td>0</td><td>0</td><td>Regulator计数掉为0，触发关闭电源的逻辑，使PMIC输出0</td></tr><tr><td>初始化屏</td><td>进入屏驱动，regulator +1</td><td>1</td><td>1</td><td>regulator不为0，打开PMIC供电</td></tr></tbody></table><p>regulator正确使用，供电也正常，逻辑没问题，为什么花屏了呢？</p><p>原因在于第一步PMIC就已经是输出高电平，开始对L-Sensor和屏供电了。对于屏而言，过早的供电，不仅使屏芯片已经处于工作状态，后面的异常掉电的波形不仅不是让它重启，反而是让它变得紊乱、异常。此外，屏的初始化有时序要求，在屏驱动初始化时，本来上电时序是设计好的，谁曾想驱动逻辑想要控制的电源实际上早在L-Sensor初始化时就上好了电呢？</p><blockquote><p>换句话说，就是屏不一定想要这么早上电，而且上完电后就稳稳地给我电，中间突然来一下掉到零这叫什么？</p></blockquote><p>显而易见的，在屏驱动运行前，屏就已经上电了，这个时候开机亮屏都是正常的，可谓歪打正着，给屏的供电是意料之外的但是却一脸懵逼的。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/IMG_1816.jpg"></p><p>因此看上去很离谱的“光感传感器通信异常居然能导致我花屏？？？”是有合理解释的。</p><p>我们能看到这个模块初始化顺序不仅导致功能强大的Regulator失去了其作用，而且在体验上，用户觉得开机速度快不快很大程度上就是开机亮屏快不快，居然先给我在屏初始化之前去初始化了传感器这个用户无感的模块。</p><p>最后，这个问题也很好处理，我们调整屏的初始化到前面即可。一般调节初始化阶段（initcall）会有效果。但是由于Linux各模块启动顺序有很大牵扯关联，这么改是有风险的。因此我们通过调节模块链接顺序即可实现在同一个initcall阶段内去调节模块的初始化顺序（调节链接顺序即可）。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/drivers/misc/mediatek/Makefile b/drivers/misc/mediatek/Makefile</span></span><br><span class="line"><span class="comment">index b8e611a48b1f..1544f7159cbe 100755</span></span><br><span class="line"><span class="comment">--- a/drivers/misc/mediatek/Makefile</span></span><br><span class="line"><span class="comment">+++ b/drivers/misc/mediatek/Makefile</span></span><br><span class="line"><span class="meta">@@ -84,7 +84,6 @@</span> obj-$(CONFIG_MTK_AUXADC)      += auxadc/</span><br><span class="line"> obj-$(CONFIG_MTK_GPT_SCHEME_SUPPORT)   += partition/</span><br><span class="line"> obj-$(CONFIG_MTK_PWM)      += pwm/</span><br><span class="line"> obj-$(CONFIG_MTK_IRTX_PWM_SUPPORT)         += irtx/</span><br><span class="line"><span class="deletion">-obj-$(CONFIG_MTK_SENSORS_1_0) += sensors-1.0/</span></span><br><span class="line"> obj-$(CONFIG_MTK_TINYSYS_SCP_SUPPORT) += scp/</span><br><span class="line"> obj-$(CONFIG_MTK_HIFIXDSP_SUPPORT) += hifi_dsp/</span><br><span class="line"> obj-$(CONFIG_MTK_HIFIXDSP_SUPPORT) += hifidsp_audio_ipi/</span><br><span class="line"><span class="meta">@@ -123,6 +122,7 @@</span> obj-$(CONFIG_MTK_CMDQ) += mdp/</span><br><span class="line"> obj-$(CONFIG_MTK_SMI_EXT) += smi/</span><br><span class="line"> obj-$(CONFIG_MTK_LCM) += lcm/</span><br><span class="line"> obj-$(CONFIG_MTK_LCM) += ext_disp/</span><br><span class="line"><span class="addition">+obj-$(CONFIG_MTK_SENSORS_1_0) += sensors-1.0/</span></span><br><span class="line"> obj-$(CONFIG_MTK_HDMI_SUPPORT) += hdmi/</span><br><span class="line"> obj-$(CONFIG_MTK_FB) += video/</span><br><span class="line"> obj-$(CONFIG_MTK_DYNAMIC_FPS_FRAMEWORK_SUPPORT) += dfrc/</span><br></pre></td></tr></table></figure><h1 id="为什么其他项目没有这个问题"><a href="#为什么其他项目没有这个问题" class="headerlink" title="为什么其他项目没有这个问题"></a>为什么其他项目没有这个问题</h1><ol><li>电路设计差异</li></ol><p>其他项目的板子，i2c SCL&#x2F;SDA那里不使用mos fet，而使用专门的转接芯片。区别是，mos管会被一定的电压打开（本案说的小台阶就是这个“一定的电压”），而转接芯片不会。</p><p>一句话说，mos fet会因小台阶而导通，使电漏过去。</p><ol start="2"><li>L-Sensor差异</li></ol><p>本案涉及的L-Sensor是1.8V的器件，且其内部电路设计和工艺制程会受到SDA&#x2F;SCL的灌电影响，处于不正常的工作状态和不正常的上电时序。</p><ol start="3"><li>CPU IO配置</li></ol><p>在开机过程中IO没有配置下拉，会使SDA&#x2F;SCL存在台阶，产生了灌电流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;研发一个机型的过程中出了点意料之外的问题。在关机状态下，进行电源适配器（DC）连续插拔测试时，在特定操作下会有概率性出现花屏现象，而且花屏现</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="Linux" scheme="https://nasdaqgodzilla.github.io/categories/Linux/"/>
    
    <category term="BSP" scheme="https://nasdaqgodzilla.github.io/categories/BSP/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="Linux" scheme="https://nasdaqgodzilla.github.io/tags/Linux/"/>
    
    <category term="BSP" scheme="https://nasdaqgodzilla.github.io/tags/BSP/"/>
    
  </entry>
  
  <entry>
    <title>MTK LED驱动节点创建和读写流程</title>
    <link href="https://nasdaqgodzilla.github.io/2024/04/07/MTK-LED%E9%A9%B1%E5%8A%A8%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/"/>
    <id>https://nasdaqgodzilla.github.io/2024/04/07/MTK-LED%E9%A9%B1%E5%8A%A8%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/</id>
    <published>2024-04-07T06:11:40.000Z</published>
    <updated>2024-04-07T06:12:56.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文分析MTK平台对LED（指示灯）驱动节点部分的创建、处理流程。MTK Android平台遵循Linux的规范惯例，和常规的Linux一样，将发光的二极管等设备抽象为一个sysfs class（驱动里面的一种类），诸如指示灯、LED灯、背光等都属于这一类，因此都在同一个class（&#x2F;sys&#x2F;class&#x2F;leds）下管理。MTK平台在该目录下提供了对LED进行操作的驱动节点。</p><p>其中，和常规的Linux一样，也是通过trigger节点来控制LED灯的触发。</p><pre><code>android:/ # ls /sys/class/leds/*/sys/class/leds/blue:brightness device max_brightness power subsystem trigger uevent /sys/class/leds/green:brightness device max_brightness power subsystem trigger uevent /sys/class/leds/lcd-backlight:brightness device max_brightness power subsystem trigger uevent /sys/class/leds/red:brightness device max_brightness power subsystem trigger uevent /sys/class/leds/vibrator:activate brightness device duration max_brightness power state subsystem trigger uevent</code></pre><blockquote><p>Linux标准规范下对LED设备节点名称的命名格式为：devicename:colour:function，而MTK Android平台不遵循这一规则，通常直接用简单直观的名字命名。</p></blockquote><h1 id="1-LED模式、驱动方式和基本数据结构"><a href="#1-LED模式、驱动方式和基本数据结构" class="headerlink" title="1. LED模式、驱动方式和基本数据结构"></a>1. LED模式、驱动方式和基本数据结构</h1><p>对于MTK Android平台各个LED驱动节点而言，设备中各LED均按照一个既定的类型和模式来管理并驱动。对于一个LED设备驱动而言，指定了其类型、模式和输出方式，就是完整的一个LED控制方法的配置了。</p><p>MTK Android平台将设备中对LED归类为如下几种类型，主要是RGB三色灯、键盘灯按键灯、LCD背光等。</p><pre><code>enum mt65xx_led_type            &#123;        MT65XX_LED_TYPE_RED = 0,        MT65XX_LED_TYPE_GREEN,        MT65XX_LED_TYPE_BLUE,        MT65XX_LED_TYPE_JOGBALL,        MT65XX_LED_TYPE_KEYBOARD,        MT65XX_LED_TYPE_BUTTON,        MT65XX_LED_TYPE_LCD,        MT65XX_LED_TYPE_TOTAL,&#125;;</code></pre><p>而驱动这些能发光的器件，主要是通过GPIO输出、PWM输出、借助PMIC（iSink）输出等几种方式。</p><pre><code>enum mt65xx_led_mode&#123;        MT65XX_LED_MODE_NONE,        MT65XX_LED_MODE_PWM,        MT65XX_LED_MODE_GPIO,        MT65XX_LED_MODE_PMIC,        MT65XX_LED_MODE_CUST_LCM,        MT65XX_LED_MODE_CUST_BLS_PWM&#125;;// PMIC iSink的输出方式enum mt65xx_led_pmic&#123;        MT65XX_LED_PMIC_LCD_ISINK = 0,        MT65XX_LED_PMIC_NLED_ISINK_MIN = MT65XX_LED_PMIC_LCD_ISINK,        MT65XX_LED_PMIC_NLED_ISINK0,        MT65XX_LED_PMIC_NLED_ISINK1,        MT65XX_LED_PMIC_NLED_ISINK_MAX,&#125;;// PWM方式的定义struct PWM_config&#123;        int clock_source;        int div;        int low_duration;        int High_duration;        BOOL pmic_pad;&#125;;</code></pre><p>LED设备配置模式的一个完整的描述如下，完整的LED包含名称、模式、输出方式。</p><pre><code>/* * name : must the same as lights HAL * mode : control mode * data : *    PWM:  pwm number *    GPIO: gpio id *    PMIC: enum mt65xx_led_pmic *    CUST: custom set brightness function pointer*/struct cust_mt65xx_led &#123;        char                 *name;        enum mt65xx_led_mode  mode;        int                   data;        struct PWM_config config_data;&#125;;</code></pre><p>对于上述data成员，当mode是<code>MT65XX_LED_MODE_CUST_LCM</code>时，data存储控制屏幕亮度的函数指针（一般这种屏幕是接收BB端的指令来自行调节亮度的，而不是BB端来控制背光，如OLED等自发光的屏幕）。</p><p>小结：通过<code>cust_mt65xx_led</code>来描述一个LED类型和驱动模式。</p><blockquote><p>cust_mt65xx_led只是LED类型和驱动模式的封装，还不是真正使用的驱动的数据结构。</p></blockquote><h1 id="2-驱动节点配置"><a href="#2-驱动节点配置" class="headerlink" title="2. 驱动节点配置"></a>2. 驱动节点配置</h1><p>为了方便不同的主板对自己的LED进行适配，MTK Android平台提供了dts的方式来允许用户方便的配置支持的LED数量和类型，不需要用户手动去创建和初始化<code>cust_mt65xx_led</code>。</p><p>其中，当dts没有配置时，会从一个数组（列表）中获取LED配置。如果不进行dts配置，仅修改这个列表，效果也是一样的，但不推荐。</p><h2 id="2-1-列表配置"><a href="#2-1-列表配置" class="headerlink" title="2.1. 列表配置"></a>2.1. 列表配置</h2><p>前面讲过，<code>cust_mt65xx_led</code>即是LED模式和驱动方式的完整抽象，<code>cust_leds.c</code>定义了该类型的数组，用来包含保存所有LED配置实例，外部文件通过<code>get_cust_led_list</code>获得这个列表。</p><blockquote><p>没有定义dts时才会获取这个列表</p></blockquote><pre><code>static struct cust_mt65xx_led cust_led_list[MT65XX_LED_TYPE_TOTAL] = &#123;    &#123;&quot;red&quot;,               MT65XX_LED_MODE_PWM, 1,&#123;0,0,0,0,1&#125;&#125;,    &#123;&quot;green&quot;,             MT65XX_LED_MODE_PWM, 0,&#123;0,0,0,0,1&#125;&#125;,    &#123;&quot;blue&quot;,              MT65XX_LED_MODE_PWM, -1,&#123;0,0,0,0,1&#125;&#125;,    &#123;&quot;jogball-backlight&quot;, MT65XX_LED_MODE_NONE, -1,&#123;0,0,0,0,0&#125;&#125;,    &#123;&quot;keyboard-backlight&quot;,MT65XX_LED_MODE_NONE, -1,&#123;0,0,0,0,0&#125;&#125;,    &#123;&quot;button-backlight&quot;,  MT65XX_LED_MODE_NONE, -1,&#123;0,0,0,0,0&#125;&#125;,    &#123;&quot;lcd-backlight&quot;,     MT65XX_LED_MODE_CUST_BLS_PWM, (int)disp_bls_set_backlight,&#123;0&#125;&#125;,&#125;;struct cust_mt65xx_led *get_cust_led_list(void)&#123;        return cust_led_list;&#125;</code></pre><h2 id="2-2-dts配置"><a href="#2-2-dts配置" class="headerlink" title="2.2. dts配置"></a>2.2. dts配置</h2><p>LED dts的配置如下。由于dts中配置的命名非常直观，且和前述LED数据结构变量名都能刚好对应，不再赘述。由于LED节点的创建流程中会首先判断是否存在dts配置，然后再检查列表配置。因此dts配置优先级高于列表配置。</p><pre><code>&amp;odm &#123;        led0:led@0 &#123;                compatible = &quot;mediatek,red&quot;;                led_mode = &lt;1&gt;;                data = &lt;1&gt;;                pwm_config = &lt;0 0 0 0 0&gt;;        &#125;;        led1:led@1 &#123;                compatible = &quot;mediatek,green&quot;;                led_mode = &lt;1&gt;;                data = &lt;0&gt;;                pwm_config = &lt;0 0 0 0 0&gt;;        &#125;;        ...&#125;;</code></pre><h2 id="2-3-dts解析"><a href="#2-3-dts解析" class="headerlink" title="2.3. dts解析"></a>2.3. dts解析</h2><p>LED配置的解析和加载是懒加载的形式。即运行流程中发生了对LED相关操作（如<code>mt65xx_leds_brightness_set()函数调用</code>）后，检查是否完成了dts的解析，使得LED dts配置是在使用时才解析，且仅进行首次解析。</p><pre><code>int mt65xx_leds_brightness_set(enum mt65xx_led_type type, enum led_brightness level)&#123;        struct cust_mt65xx_led *cust_led_list = get_cust_led_dtsi();        // dts没有配置时，加载列表配置        if (cust_led_list == NULL) &#123;                cust_led_list = get_cust_led_list();                LEDS_DEBUG(&quot;Cannot not get the LED info from device tree. \n&quot;);        &#125;        if (type &gt;= MT65XX_LED_TYPE_TOTAL)                return -1;                ...&#125;</code></pre><p><code>get_cust_led_dtsi()</code>通过缓存解析结果来实现仅首次解析一次的目的。其中，缓存结果存储到pled_dtsi中。它是以指针类型存储的数组。</p><pre><code>struct cust_mt65xx_led pled_dtsi[MT65XX_LED_TYPE_TOTAL];</code></pre><p>前面dts的配置可以确定LED dts配置的解析路径，以及相匹配的LED名称。</p><pre><code>char *leds_name[MT65XX_LED_TYPE_TOTAL] = &#123;        &quot;red&quot;,        &quot;green&quot;,        &quot;blue&quot;,        &quot;jogball-backlight&quot;,        &quot;keyboard-backlight&quot;,        &quot;button-backlight&quot;,        &quot;lcd-backlight&quot;,&#125;;char *leds_node[MT65XX_LED_TYPE_TOTAL] = &#123;        &quot;/odm/led@0&quot;,        &quot;/odm/led@1&quot;,        &quot;/odm/led@2&quot;,        &quot;/odm/led@3&quot;,        &quot;/odm/led@4&quot;,        &quot;/odm/led@5&quot;,        &quot;/odm/led@6&quot;,&#125;;</code></pre><p>解析函数如下。它的逻辑很简单，就是按照<code>leds_name[]</code>数组来按顺序解析dts，对数据结构初始化。如果是CUST系列的两个mode，则对data赋值为对应函数指针。</p><pre><code>struct cust_mt65xx_led *get_cust_led_dtsi(void)&#123;        static bool isDTinited = false;        int i, offset;        int pwm_config[5] = &#123;0&#125;;#if defined(USE_DTB_NO_DWS)        if ( isDTinited == true )                goto out;        for (i = 0; i &lt; MT65XX_LED_TYPE_TOTAL; i++) &#123;                pled_dtsi[i].name = leds_name[i];                offset = fdt_path_offset(get_lk_overlayed_dtb(), leds_node[i]);                if (offset &lt; 0) &#123;                        LEDS_DEBUG(&quot;[LEDS]LK:Cannot find LED node from dts\n&quot;);                        pled_dtsi[i].mode = 0;                        pled_dtsi[i].data = -1;                &#125; else &#123;                        isDTinited = true;                        pled_dtsi[i].mode = led_fdt_getprop_u32(get_lk_overlayed_dtb(), offset, &quot;led_mode&quot;);                        pled_dtsi[i].data = led_fdt_getprop_u32(get_lk_overlayed_dtb(), offset, &quot;data&quot;);                        led_fdt_getprop_char_array(get_lk_overlayed_dtb(), offset, &quot;pwm_config&quot;, (char *)pwm_config);                        pled_dtsi[i].config_data.clock_source = pwm_config[0];                        pled_dtsi[i].config_data.div = pwm_config[1];                        pled_dtsi[i].config_data.low_duration = pwm_config[2];                        pled_dtsi[i].config_data.High_duration = pwm_config[3];                        pled_dtsi[i].config_data.pmic_pad = pwm_config[4];                        switch (pled_dtsi[i].mode) &#123;                                case MT65XX_LED_MODE_CUST_LCM:                                        pled_dtsi[i].data = (long)primary_display_setbacklight;                                        LEDS_DEBUG(&quot;[LEDS]LK:The backlight hw mode is LCM.\n&quot;);                                        break;                                case MT65XX_LED_MODE_CUST_BLS_PWM:                                        pled_dtsi[i].data = (long)disp_bls_set_backlight;                                        LEDS_DEBUG(&quot;[LEDS]LK:The backlight hw mode is BLS.\n&quot;);                                        break;                                default:                                        break;                        &#125;                        LEDS_INFO(&quot;[LEDS]LK:led[%d] offset is %d,mode is %d,data is %d .\n&quot;,    \                                  i,offset,pled_dtsi[i].mode,pled_dtsi[i].data);                &#125;        &#125;#endif        if ( isDTinited == false )                return NULL;out:        return pled_dtsi;&#125;</code></pre><h1 id="3-驱动的初始化和驱动节点创建"><a href="#3-驱动的初始化和驱动节点创建" class="headerlink" title="3. 驱动的初始化和驱动节点创建"></a>3. 驱动的初始化和驱动节点创建</h1><p>MTK LED驱动是一个独立的module，由<code>CONFIG_MTK_LEDS</code>控制，在系统中注册LED设备驱动，并初始化节点。实际上，完整的LED节点创建过程中，创建LED节点本身是第二步，第一步是Linux原生创建的LED sysfs class。因此Kernel中有一些Linux定义好的用来创建对应class的KConfig配置也和LED驱动节点有关。下表列出相关的一些KConfig配置（这些配置是需要打开以支持LED驱动的），列出的顺序和Module加载顺序是一致的。</p><blockquote><p>除CONFIG_MTK_LEDS是MTK加入的，其他都是Linux原生的</p></blockquote><table><thead><tr><th>定义</th><th>包含模块</th><th>加载</th><th>简介</th></tr></thead><tbody><tr><td>CONFIG_NEW_LEDS</td><td>led-core.o</td><td>exported symbols</td><td>提供LED操作函数的抽象和这些函数的symbol export，定义了leds_list、锁并export。主要是将通用函数和公共全局变量symbol export出来，并挂接到真正的ledclass_cdev实现中。相当于将通用API和实际设备驱动进行胶水层粘合</td></tr><tr><td>CONFIG_LEDS_CLASS</td><td>led-class.o</td><td>subsys_initcall</td><td>加载、初始化LED类（class），让系统中出现这一类的sysfs驱动节点，初始化对应attribute。注册电源管理函数、group attribute等。</td></tr><tr><td>CONFIG_LEDS_TRIGGERS</td><td>led-triggers.o</td><td>exported symbols</td><td>类似led-core，提供并export trigger相关的通用API ｜</td></tr><tr><td>CONFIG_LEDS_TRIGGER_TIMER</td><td>ledtrig-timer.o</td><td>module_init</td><td>用于trigger实现blink，创建delay_on&#x2F;off节点并通过它们来运行调用者设置、实现blink</td></tr><tr><td>CONFIG_MTK_LEDS</td><td>mtk_leds_drv.o mtk_leds.o</td><td>late_initcall，在led-class加载完成后才加载，先加载mtk_leds_drv后加载mtk_leds</td><td>mtk_leds_drv完成LED dts配置解析，并创建LED在sysfs class的节点，注册了LED brightness、blink等节点设置亮度、blink的处理函数块。其中，mtk_leds_drv注册的各处理函数，都是调用了mtk_leds.o</td></tr></tbody></table><h2 id="3-1-sysfs-LED-Class驱动"><a href="#3-1-sysfs-LED-Class驱动" class="headerlink" title="3.1. sysfs LED Class驱动"></a>3.1. sysfs LED Class驱动</h2><p>在分析LED驱动前，先分析sysfs下LED class。led-class.o在subsys_initcall阶段初始化，主要完成创建class类、注册电源管理函数、注册groups。</p><h3 id="3-1-1-创建sysfs-LED-class"><a href="#3-1-1-创建sysfs-LED-class" class="headerlink" title="3.1.1. 创建sysfs LED class"></a>3.1.1. 创建sysfs LED class</h3><p>创建一个class比较简单，调用<code>class_create()</code>就会在对应路径创建class目录了。led-class.o模块通过这个方法在sysfs下创建了<code>leds</code>目录。</p><h3 id="3-1-2-注册sysfs-class-dev-pm-ops"><a href="#3-1-2-注册sysfs-class-dev-pm-ops" class="headerlink" title="3.1.2. 注册sysfs class dev_pm_ops"></a>3.1.2. 注册sysfs class dev_pm_ops</h3><p><code>dev_pm_ops</code>是设备电源管理的操作函数，当LED驱动挂起和恢复时调用，用于LED电源的管理。其中，注册的操作函数包含<code>led_suspend</code>和<code>led_resume</code>。</p><p>其中suspend的过程非常简单，通过<code>dev_get_drvdata(struct device*)</code>，根据电源管理子系统传入的<code>device</code>取得存储于<code>device-&gt;driver_data</code>的<code>led_classdev</code>指针，然后调用<code>led-core.o</code>定义好的API，把LED的brightness设置为0，关掉了灯即进入了suspend。</p><blockquote><p>如前所述，led class、led core、led device中间通过框架抽象粘合在了一起，这里的suspend过程就是这个框架在发挥作用。led device如何加入到框架中，稍后分析。</p></blockquote><p>resume的流程也是一样的，把之前LED灯的brightness level恢复点亮就行了。其中brightness level（即对应LED device当前生效的亮度）存储在<code>led_classdev-&gt;brightness</code>。</p><h3 id="3-1-3-注册sysfs-class-dev-groups，为设备添加属性节点"><a href="#3-1-3-注册sysfs-class-dev-groups，为设备添加属性节点" class="headerlink" title="3.1.3. 注册sysfs class dev_groups，为设备添加属性节点"></a>3.1.3. 注册sysfs class dev_groups，为设备添加属性节点</h3><p>dev_groups的类型是<code>struct attribute_group</code>，它是class给其包含的设备添加的属性。LED class添加了brightness、max_brightness、trigger等节点，这里仅看看brightness节点。</p><pre><code>static ssize_t brightness_show(struct device *dev,                                         struct device_attribute *attr, char *buf)                  &#123;                                                                                    struct led_classdev *led_cdev = dev_get_drvdata(dev);                         /* no lock needed for this */        led_update_brightness(led_cdev);        return sprintf(buf, &quot;%u\n&quot;, led_cdev-&gt;brightness);&#125;static ssize_t brightness_store(struct device *dev,                struct device_attribute *attr, const char *buf, size_t size)&#123;        struct led_classdev *led_cdev = dev_get_drvdata(dev);        unsigned long state;        ssize_t ret;        mutex_lock(&amp;led_cdev-&gt;led_access);        if (led_sysfs_is_disabled(led_cdev)) &#123;                ret = -EBUSY;                goto unlock;        &#125;        ret = kstrtoul(buf, 10, &amp;state);        if (ret)                goto unlock;        if (state == LED_OFF)                led_trigger_remove(led_cdev);        led_set_brightness(led_cdev, state);        ret = size;unlock:        mutex_unlock(&amp;led_cdev-&gt;led_access);        return ret;&#125;static DEVICE_ATTR_RW(brightness);</code></pre><p><code>brightness_show()</code>的逻辑是通过<code>led_update_brightness()</code>调用LED设备驱动，获取brightness。</p><p><code>brightness_store()</code>的逻辑会进行加锁、拷贝用户空间的输入值，调用<code>led_set_brightness()</code>，他是led-core提供的抽象API。</p><pre><code>void led_set_brightness(struct led_classdev *led_cdev,                        enum led_brightness brightness)             &#123;        /*                                           * If software blink is active, delay brightness setting         * until the next timer tick.         */                                                                          if (test_bit(LED_BLINK_SW, &amp;led_cdev-&gt;work_flags)) &#123;                /*                                          * If we need to disable soft blinking delegate this to the                 * work queue task to avoid problems in case we are called                 * from hard irq context.                 */                 if (brightness == LED_OFF) &#123;                        set_bit(LED_BLINK_DISABLE, &amp;led_cdev-&gt;work_flags);                        schedule_work(&amp;led_cdev-&gt;set_brightness_work);                &#125; else &#123;                               set_bit(LED_BLINK_BRIGHTNESS_CHANGE,                                &amp;led_cdev-&gt;work_flags);                        led_cdev-&gt;new_blink_brightness = brightness;                &#125;                return;        &#125;                  led_set_brightness_nosleep(led_cdev, brightness);&#125;EXPORT_SYMBOL_GPL(led_set_brightness);void led_set_brightness_nopm(struct led_classdev *led_cdev,                              enum led_brightness value)&#123;        /* Use brightness_set op if available, it is guaranteed not to sleep */        if (!__led_set_brightness(led_cdev, value))                return;        /* If brightness setting can sleep, delegate it to a work queue task */        led_cdev-&gt;delayed_set_value = value;        schedule_work(&amp;led_cdev-&gt;set_brightness_work);&#125;EXPORT_SYMBOL_GPL(led_set_brightness_nopm);void led_set_brightness_nosleep(struct led_classdev *led_cdev,                                enum led_brightness value)&#123;        led_cdev-&gt;brightness = min(value, led_cdev-&gt;max_brightness);        if (led_cdev-&gt;flags &amp; LED_SUSPENDED)                return;        led_set_brightness_nopm(led_cdev, led_cdev-&gt;brightness);&#125;EXPORT_SYMBOL_GPL(led_set_brightness_nosleep);</code></pre><p>如果此时LED是软件实现的Blink（通过一个工作队列实现的），则设置对应标志位，由工作队列来更新亮度。否则调用<code>led_set_brightness_nosleep()</code>。</p><p><code>led_set_brightness_nosleep()</code>的作用是跳过<code>LED_SUSPENDED</code>状态，设置brightness的操作仅在此之外的状态中生效。实际调用<code>led_set_brightness_nopm()</code>来设置brightness。</p><p><code>led_set_brightness_nopm()</code>首先通过<code>__led_set_brightness()</code>检查LED是否注册了<code>brightness_set</code>函数。有则调用，完成brightness设置。否则调用<code>set_brightness_work</code>工作队列来完成。</p><pre><code>static int __led_set_brightness(struct led_classdev *led_cdev,                                              enum led_brightness value)                 &#123;                                                       if (!led_cdev-&gt;brightness_set)                return -ENOTSUPP;                                                                                                                led_cdev-&gt;brightness_set(led_cdev, value);                                                                               return 0;                                                                             &#125;</code></pre><blockquote><p>brightness_set是mtk_leds_drv.o模块在probe时，解析LED dts、创建mt65xx_led_data的时候赋值为mt65xx_led_set()</p></blockquote><blockquote><p>set_brightness_work是led-class.o在初始化led class时创建的，该延时队列执行的是set_brightness_delayed()。它首先调用和_nopm()相同的__led_set_brightness()，在失败的情况下会再尝试__led_set_brightness_blocking()</p></blockquote><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4. 小结"></a>3.1.4. 小结</h3><p>led-class.o创建了LED class，并为即将加入到该class的子节点们准备了brightness、max_brightness、trigger等属性（attribute），并将这些属性与对应的读写函数挂接起来。其中，挂接的函数实际是mtk_leds_drv.o和mtk_leds.o模块实现的。</p><h2 id="3-2-LED驱动基础数据结构"><a href="#3-2-LED驱动基础数据结构" class="headerlink" title="3.2. LED驱动基础数据结构"></a>3.2. LED驱动基础数据结构</h2><p>我们知道Android启动过程实际上是经历了LK和Kernel两个阶段的。其中Kernel阶段会创建LED驱动节点。Kernel中除了定义了与LK一致的用于抽象LED模式和驱动方式的struct外，主要在此基础上增加了设备驱动模型的抽象，当前亮度等级，以及用于blink的支持。</p><pre><code>struct mt65xx_led_data &#123;        struct led_classdev cdev;        struct cust_mt65xx_led cust;        struct work_struct work;        int level;        int delay_on;        int delay_off;&#125;;</code></pre><p>其中<code>led_classdev</code>包含了blink、timer、trigger等除brightness等的功能，比较庞大。</p><pre><code>struct led_classdev &#123;                                                  const char              *name;                        enum led_brightness      brightness;                                           enum led_brightness      max_brightness;                  int                      flags;                                                                                            /* set_brightness_work / blink_timer flags, atomic, private. */            unsigned long           work_flags;                                                                              /* Set LED brightness level                                      * Must not sleep. Use brightness_set_blocking for drivers              * that can sleep while setting brightness.                               */                                                                void            (*brightness_set)(struct led_classdev *led_cdev,                                            enum led_brightness brightness);        /*                                                                       * Set LED brightness level immediately - it can block the caller for         * the time required for accessing a LED device register.                             */                                                                     int (*brightness_set_blocking)(struct led_classdev *led_cdev,                                       enum led_brightness brightness);        /* Get LED brightness level */        enum led_brightness (*brightness_get)(struct led_classdev *led_cdev);        /*         * Activate hardware accelerated blink, delays are in milliseconds         * and if both are zero then a sensible default should be chosen.         * The call should adjust the timings in that case and if it can&#39;t         * match the values specified exactly.         * Deactivate blinking again when the brightness is set to LED_OFF         * via the brightness_set() callback.         */        int             (*blink_set)(struct led_classdev *led_cdev,                                     unsigned long *delay_on,                                     unsigned long *delay_off);        struct device           *dev;        const struct attribute_group    **groups;        struct list_head         node;                  /* LED Device list */        const char              *default_trigger;       /* Trigger to use */        unsigned long            blink_delay_on, blink_delay_off;        struct timer_list        blink_timer;        int                      blink_brightness;        int                      new_blink_brightness;        void                    (*flash_resume)(struct led_classdev *led_cdev);        struct work_struct      set_brightness_work;        int                     delayed_set_value;#ifdef CONFIG_LEDS_TRIGGERS        /* Protects the trigger data below */        struct rw_semaphore      trigger_lock;        struct led_trigger      *trigger;        struct list_head         trig_list;        void                    *trigger_data;        /* true if activated - deactivate routine uses it to do cleanup */        bool                    activated;#endif#ifdef CONFIG_LEDS_BRIGHTNESS_HW_CHANGED        int                      brightness_hw_changed;        struct kernfs_node      *brightness_hw_changed_kn;#endif        /* Ensures consistent access to the LED Flash Class device */        struct mutex            led_access;</code></pre><h2 id="3-3-LED驱动初始化"><a href="#3-3-LED驱动初始化" class="headerlink" title="3.3. LED驱动初始化"></a>3.3. LED驱动初始化</h2><p><code>mtk_leds_drv.o</code>模块的<code>mt65xx_leds_probe</code>完成对LED驱动的初始化。</p><p>首先读取LED配置（dts配置或列表配置），为配置的每个LED创建驱动数据结构，设置操作函数指针，初始化工作队列，最后调用LED节点注册函数。</p><pre><code>static int mt65xx_leds_probe(struct platform_device *pdev)&#123;                        int i;        int ret;        struct cust_mt65xx_led *cust_led_list = mt_get_cust_led_list();                                                      if (!cust_led_list) &#123;                               pr_info(&quot;[LED] get dts fail! Probe exit.\n&quot;);                ret = -1;                                                              goto err_dts;                                           &#125;                                                                                   #ifdef CONFIG_BACKLIGHT_SUPPORT_LP8557        /*i2c_register_board_info(4, &amp;leds_board_info, 1);*/        if (i2c_add_driver(&amp;led_i2c_driver)) &#123;                LEDS_DRV_DEBUG(&quot;unable to add led-i2c driver.\n&quot;);                ret = -1;                goto err_dts;        &#125;#endif                                                              for (i = 0; i &lt; TYPE_TOTAL; i++) &#123;                if (cust_led_list[i].mode == MT65XX_LED_MODE_NONE) &#123;                        g_leds_data[i] = NULL;                        continue;                &#125;                g_leds_data[i] =                    kzalloc(sizeof(struct mt65xx_led_data), GFP_KERNEL);                if (!g_leds_data[i]) &#123;                        ret = -ENOMEM;                        goto err;                &#125;                g_leds_data[i]-&gt;cust.mode = cust_led_list[i].mode;                g_leds_data[i]-&gt;cust.data = cust_led_list[i].data;                g_leds_data[i]-&gt;cust.name = cust_led_list[i].name;                g_leds_data[i]-&gt;cdev.name = cust_led_list[i].name;                g_leds_data[i]-&gt;cust.config_data = cust_led_list[i].config_data;                g_leds_data[i]-&gt;cdev.brightness_set = mt65xx_led_set;                g_leds_data[i]-&gt;cdev.blink_set = mt65xx_blink_set;                INIT_WORK(&amp;g_leds_data[i]-&gt;work, mt_mt65xx_led_work);                ret = led_classdev_register(&amp;pdev-&gt;dev, &amp;g_leds_data[i]-&gt;cdev);                if (ret)                        goto err;        &#125;        ...&#125;</code></pre><p>接下来通过<code>led_classdev_register()</code>注册LED设备驱动，注册每个LED驱动所需要的同步锁、驱动节点。</p><blockquote><p>其中，每个LED是分别在for循环里面逐个单独地调用<code>led_classdev_register()</code>进行注册的。</p></blockquote><p>函数如下。这个函数较长，包含几个关键步骤。下面先展示这个函数后再分解分析。</p><pre><code>#define led_classdev_register(parent, led_cdev)                         \        of_led_classdev_register(parent, NULL, led_cdev)/** * of_led_classdev_register - register a new object of led_classdev class.  *                                                        * @parent: parent of LED device                                              * @led_cdev: the led_classdev structure for this device.                  * @np: DT node describing this LED        */                                                     int of_led_classdev_register(struct device *parent, struct device_node *np,                            struct led_classdev *led_cdev)                    &#123;                                                                  char name[LED_MAX_NAME_SIZE];        int ret;                                                                               ret = led_classdev_next_name(led_cdev-&gt;name, name, sizeof(name));             if (ret &lt; 0)                                                                          return ret;                                                                                led_cdev-&gt;dev = device_create_with_groups(leds_class, parent, 0,                                led_cdev, led_cdev-&gt;groups, &quot;%s&quot;, name);        if (IS_ERR(led_cdev-&gt;dev))                return PTR_ERR(led_cdev-&gt;dev);        led_cdev-&gt;dev-&gt;of_node = np;        if (ret)                dev_warn(parent, &quot;Led %s renamed to %s due to name collision&quot;,                                led_cdev-&gt;name, dev_name(led_cdev-&gt;dev));        if (led_cdev-&gt;flags &amp; LED_BRIGHT_HW_CHANGED) &#123;                ret = led_add_brightness_hw_changed(led_cdev);                if (ret) &#123;                        device_unregister(led_cdev-&gt;dev);                        return ret;                &#125;        &#125;        led_cdev-&gt;work_flags = 0;        #ifdef CONFIG_LEDS_TRIGGERS        init_rwsem(&amp;led_cdev-&gt;trigger_lock);#endif#ifdef CONFIG_LEDS_BRIGHTNESS_HW_CHANGED        led_cdev-&gt;brightness_hw_changed = -1;#endif        mutex_init(&amp;led_cdev-&gt;led_access);        /* add to the list of leds */        down_write(&amp;leds_list_lock);        list_add_tail(&amp;led_cdev-&gt;node, &amp;leds_list);        up_write(&amp;leds_list_lock);        if (!led_cdev-&gt;max_brightness)                led_cdev-&gt;max_brightness = LED_FULL;        led_update_brightness(led_cdev);        led_init_core(led_cdev);#ifdef CONFIG_LEDS_TRIGGERS        led_trigger_set_default(led_cdev);#endif        dev_dbg(parent, &quot;Registered led device: %s\n&quot;,                        led_cdev-&gt;name);        return 0;&#125;EXPORT_SYMBOL_GPL(of_led_classdev_register);</code></pre><p><code>of_led_classdev_register()</code>可以分解为如下几个最主要的流程。</p><h3 id="3-3-1-查找并移除重名LED节点"><a href="#3-3-1-查找并移除重名LED节点" class="headerlink" title="3.3.1. 查找并移除重名LED节点"></a>3.3.1. 查找并移除重名LED节点</h3><p><code>led_classdev_next_name()</code>查找LED class内重复注册同一个名称（函数参数里面的name）的节点。class中如果重复注册，第一个节点命名为LED名称（如”red”），其余重复的命名为”red_0”。这个函数<code>通过class_find_device()</code>查找到同名class节点后，通过<code>put_device()</code>将其从class节点集合中移除。</p><blockquote><p>这里传入的参数中len &#x3D;&#x3D; sizeof(name)，因此只会将直接重名的LED class移除（如”red”），而不会移除按序号再命名的class节点如（”red_0”）。</p></blockquote><p>函数返回小于0的时候，即枚举重名节点期间的缓冲区大小不够（注意缓冲区要有空间给字符串后面补’\0’才算满足大小；直接传入sizeof()大小是满足要求的。），此时没有可靠地检查并移除重名函数，因此提前退出，不创建节点。</p><p>函数返回值大于等于0时表示发现并移除了对应数量的重名和再命名节点。</p><pre><code>static int led_classdev_next_name(const char *init_name, char *name,                                  size_t len)&#123;        unsigned int i = 0;        int ret = 0;        struct device *dev;        strlcpy(name, init_name, len);        while ((ret &lt; len) &amp;&amp;               (dev = class_find_device(leds_class, NULL, name, match_name))) &#123;                put_device(dev);                ret = snprintf(name, len, &quot;%s_%u&quot;, init_name, ++i);        &#125;        if (ret &gt;= len)                return -ENOMEM;        return i;&#125;</code></pre><h3 id="3-3-2-创建LED节点"><a href="#3-3-2-创建LED节点" class="headerlink" title="3.3.2. 创建LED节点"></a>3.3.2. 创建LED节点</h3><p>在移除同名节点后，通过<code>device_create_with_groups</code>创建sysfs LED class路径下的节点。它是Linux系统特地为创建sysfs class节点专用的函数。</p><pre><code>/** * device_create_with_groups - creates a device and registers it with sysfs * @class: pointer to the struct class that this device should be registered to * @parent: pointer to the parent struct device of this new device, if any * @devt: the dev_t for the char device to be added * @drvdata: the data to be added to the device for callbacks * @groups: NULL-terminated list of attribute groups to be created * @fmt: string for the device&#39;s name * * This function can be used by char device classes.  A struct device * will be created in sysfs, registered to the specified class. * Additional attributes specified in the groups parameter will also * be created automatically. * * A &quot;dev&quot; file will be created, showing the dev_t for the device, if * the dev_t is not 0,0. * If a pointer to a parent struct device is passed in, the newly created * struct device will be a child of that device in sysfs. * The pointer to the struct device will be returned from the call. * Any further sysfs files that might be required can be created using this * pointer. * * Returns &amp;struct device pointer on success, or ERR_PTR() on error. * * Note: the struct class passed to this function must have previously * been created with a call to class_create(). */struct device *device_create_with_groups(struct class *class,                                         struct device *parent, dev_t devt,                                         void *drvdata,                                         const struct attribute_group **groups,                                         const char *fmt, ...)&#123;    ...&#125;EXPORT_SYMBOL_GPL(device_create_with_groups);</code></pre><p>LED创建它的sysfs LED class子节点的调用方式如下。创建的device指针存储在<code>mt65xx_led_data-&gt;led_classdev-&gt;dev</code>这一<code>struct device*</code>中。</p><pre><code>led_cdev-&gt;dev = device_create_with_groups(leds_class, parent, 0,                    led_cdev, led_cdev-&gt;groups, &quot;%s&quot;, name);</code></pre><p>至此，<code>mtk_leds_drv.o</code>就借助<code>mt65xx_leds_probe()</code>完成了MTK LED驱动的sysfs class注册和初始化了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MTK LED采用了Linux LED sysfs class，它通过dts进行配置，借助built-in module的方式加载。其中，LED class提供了各LED设备的attribute来实现brightness、trigger等节点的创建，并将store、show等读写函数挂接到<code>mtk_leds_drv.o</code>这一真正的LED class device中，实现了LED节点的创建、读写流程。</p><h2 id="类图和流程图"><a href="#类图和流程图" class="headerlink" title="类图和流程图"></a>类图和流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/MTK_LED_watermarked.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本文分析MTK平台对LED（指示灯）驱动节点部分的创建、处理流程。MTK Android平台遵循Linux的规范惯例，和常规的Linux一样</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="驱动" scheme="https://nasdaqgodzilla.github.io/categories/%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="驱动" scheme="https://nasdaqgodzilla.github.io/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android Emulator运行自定义的AOSP镜像</title>
    <link href="https://nasdaqgodzilla.github.io/2024/03/20/Android-Emulator%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84AOSP%E9%95%9C%E5%83%8F/"/>
    <id>https://nasdaqgodzilla.github.io/2024/03/20/Android-Emulator%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84AOSP%E9%95%9C%E5%83%8F/</id>
    <published>2024-03-20T10:11:01.000Z</published>
    <updated>2024-03-20T11:36:49.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>介绍在Mac上通过Android官方Emulator启动自己编译的AOSP模拟器镜像,实现自定义AOSP在Mac Android模拟器上的调试.</p><h1 id="Emulator准备"><a href="#Emulator准备" class="headerlink" title="Emulator准备"></a>Emulator准备</h1><p>直接下载官方的Emulator,这个模拟器用于启动AOSP编译出来的模拟器镜像</p><p>下载地址: <a href="https://github.com/google/android-emulator-m1-preview/releases">https://github.com/google/android-emulator-m1-preview/releases</a></p><h1 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h1><p>完成AOSP的编译,得到模拟器镜像.可以参考: <a href="https://nasdaqgodzilla.github.io/2024/03/20/%E5%9C%A8Apple-Mac-M1%E4%B8%8A%E7%BC%96%E8%AF%91AOSP-ARM-Android%E6%A8%A1%E6%8B%9F%E5%99%A8/">在Apple Mac M1上编译AOSP ARM Android模拟器</a>和<a href="https://nasdaqgodzilla.github.io/2024/03/19/%E6%8B%89%E5%8F%96%E5%B9%B6%E7%BC%96%E8%AF%91AOSP-Android-14%E6%A8%A1%E6%8B%9F%E5%99%A8/">拉取并编译AOSP Android 14模拟器</a></p><ol start="2"><li>打包镜像,可以参考:<a href="https://github.com/NasdaqGodzilla/aosp_image_pack">aosp_image_pack</a></li></ol><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ol><li>将打包好的镜像解压放入Mac Android Emulator目录<code>/Applications/Android Emulator.app/Contents/MacOS/</code></li></ol><blockquote><p>假设镜像解压到目录&#x2F;Applications&#x2F;Android Emulator.app&#x2F;Contents&#x2F;MacOS&#x2F;api30-gphone-arm64-v8a</p></blockquote><ol start="2"><li>选择镜像,启动模拟器</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PATH_EMULATOR</span>=<span class="string">&#x27;/Applications/Android Emulator.app/Contents/MacOS&#x27;</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ANDROID_PRODUCT_OUT</span>=<span class="string">&quot;<span class="variable">$PATH_EMULATOR</span>&quot;</span>/api30-gphone-arm64-v8a</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ANDROID_BUILD_TOP</span>=<span class="variable">$ANDROID_PRODUCT_OUT</span></span><br><span class="line"><span class="variable">$PATH_EMULATOR</span>/emulator/emulator</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;介绍在Mac上通过Android官方Emulator启动自己编译的AOSP模拟器镜像,实现自定义AOSP在Mac Android模拟器上的调</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在Apple Mac M1上编译AOSP ARM Android模拟器</title>
    <link href="https://nasdaqgodzilla.github.io/2024/03/20/%E5%9C%A8Apple-Mac-M1%E4%B8%8A%E7%BC%96%E8%AF%91AOSP-ARM-Android%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://nasdaqgodzilla.github.io/2024/03/20/%E5%9C%A8Apple-Mac-M1%E4%B8%8A%E7%BC%96%E8%AF%91AOSP-ARM-Android%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2024-03-20T08:43:32.000Z</published>
    <updated>2024-03-20T09:59:47.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>旨在让你能在Mac上运行可自行定制的模拟器和Android系统.</p><p>分两个部分,分别编译模拟器emulator和AOSP模拟器镜像, 其中以Android 14为例.</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="DepotTools"><a href="#DepotTools" class="headerlink" title="DepotTools"></a>DepotTools</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//</span>chromium.googlesource.com<span class="regexp">/chromium/</span>tools/depot_tools.git</span><br><span class="line">export PATH=<span class="regexp">/path/</span>to/depot_tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>显然你必须将&#x2F;path&#x2F;to&#x2F;depot_tools正确替换为实际路径</p></blockquote><blockquote><p>其中,export命令最好加到.bashrc中,让你的所有终端都能生效</p></blockquote><h2 id="拉取qemu源码并编译"><a href="#拉取qemu源码并编译" class="headerlink" title="拉取qemu源码并编译"></a>拉取qemu源码并编译</h2><p>用于将编译得到的镜像运行起来</p><p>注意:这一步可以跳过,因为AOSP源码自带一个emulator.如果你想研究emulator的实现才需要自行编译</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> emu</span><br><span class="line"><span class="keyword">cd</span> emu</span><br><span class="line">repo init -<span class="keyword">u</span> http<span class="variable">s:</span>//android.googlesource.<span class="keyword">com</span>/platform/external/qemu --depth=<span class="number">1</span></span><br><span class="line">repo <span class="keyword">sync</span> -qcj <span class="number">4</span></span><br><span class="line"><span class="keyword">cd</span> external/qemu</span><br><span class="line"><span class="keyword">python</span> android/build/<span class="keyword">python</span>/cmake.<span class="keyword">py</span> --target=darwin_aarch64</span><br></pre></td></tr></table></figure><blockquote><p>如果repo init有问题,可以改用git.可以切到一个稳定的分支,如aosp-emu-30-release</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//</span>android.googlesource.com<span class="regexp">/platform/</span>external/qemu</span><br></pre></td></tr></table></figure><p>其中,emu的源码在这,感兴趣可以研究</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>android.googlesource.com<span class="regexp">/platform/</span>external<span class="regexp">/qemu/</span>+<span class="regexp">/refs/</span>heads/emu-master-dev</span><br></pre></td></tr></table></figure><ul><li>最后一个python命令会进行大量target的初始化.当你看到终端输出表明编译已经开始了,那么终止这个编译,直接用如下这个命令能让你编译更快</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C objs <span class="keyword">install</span>/strip</span><br></pre></td></tr></table></figure><p>编译产物:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/path/</span>to<span class="regexp">/external/</span>qemu<span class="regexp">/objs/</span>distribution/emulator</span><br></pre></td></tr></table></figure><p>签名:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="keyword">sign</span>-objs-binaries.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>这一步将编译得到的emulator及其相关产物进行签名</p></blockquote><h2 id="编译Android"><a href="#编译Android" class="headerlink" title="编译Android"></a>编译Android</h2><p>编译Android比较麻烦.因为Mac的文件系统并不区分大小写…并不兼容AOSP.</p><p>因此,请在Linux下编译AOSP</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> aosp<span class="number">14</span></span><br><span class="line"><span class="attribute">cd</span> aosp<span class="number">14</span></span><br><span class="line"><span class="attribute">repo</span> init -u https://android.googlesource.com/platform/manifest -b android-<span class="number">14</span>.<span class="number">0</span>.<span class="number">0</span>_r<span class="number">20</span> --depth=<span class="number">1</span></span><br><span class="line"><span class="attribute">repo</span> sync -qcj <span class="number">4</span></span><br></pre></td></tr></table></figure><p>把这个patch打到<code>build/make/target/board/emulator_arm64/BoardConfig.mk</code>,移除32位支持: <a href="https://android-review.googlesource.com/c/platform/build/+/1518218">https://android-review.googlesource.com/c/platform/build/+/1518218</a></p><p>启动编译:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> build/envsetup.<span class="keyword">sh</span></span><br><span class="line">lunch sdk_phone_arm64-userdebug</span><br><span class="line"><span class="keyword">make</span> -j12</span><br></pre></td></tr></table></figure><blockquote><p>其中,lunch的target有平板:sdk_tablet_x86_64, GooglePhone: sdk_gphone_arm64; 当然,它们都可以添加’-userdebug’</p></blockquote><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>把产物打包到zip，放到Mac下面<code>/Applications/Android\ Emulator.app/Contents/MacOS/aosp-master-arm64-v8a/</code></p><blockquote><p>其中,产物打包脚本如下</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ANDROID_PRODUCT_OUT</span></span><br><span class="line">export ZIPPED_NAME=<span class="variable">$1</span></span><br><span class="line">mkdir <span class="literal">-p</span> <span class="variable">$ZIPPED_NAME</span>/files</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$ZIPPED_NAME</span>/files</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/system<span class="literal">-qemu</span>.img system.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/vendor.img vendor.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/ramdisk.img ramdisk.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/ramdisk.img ramdisk.img</span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/<span class="type">kernel</span>-<span class="type">ranchu</span>-<span class="number">64</span> ]; then</span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/kernel<span class="literal">-ranchu</span><span class="literal">-64</span> kernel<span class="literal">-ranchu</span><span class="literal">-64</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/kernel<span class="literal">-ranchu</span> kernel<span class="literal">-ranchu</span></span><br><span class="line">fi;</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/<span class="keyword">data</span> .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/advancedFeatures.ini advancedFeatures.ini</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/userdata.img .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/encryptionkey.img .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/build.prop .</span><br><span class="line">mkdir system</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/build.prop system/build.prop</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/VerifiedBootParams.textproto .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/source.properties .</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">zip <span class="literal">-1rq</span> <span class="variable">$ZIPPED_NAME</span>.zip files</span><br><span class="line"><span class="built_in">ls</span> <span class="literal">-l</span> <span class="variable">$ZIPPED_NAME</span>.zip</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>直接打开Mac中emulator应用的图标,或者敲命令:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Android Emulator.app<span class="regexp">/Contents/</span>MacOS<span class="regexp">/emulator/</span>emulator -avd foo</span><br></pre></td></tr></table></figure><blockquote><p>其中-avd是设备名称</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;旨在让你能在Mac上运行可自行定制的模拟器和Android系统.&lt;/p&gt;
&lt;p&gt;分两个部分,分别编译模拟器emulator和AOSP模拟器镜</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>拉取并编译AOSP Android 14模拟器</title>
    <link href="https://nasdaqgodzilla.github.io/2024/03/19/%E6%8B%89%E5%8F%96%E5%B9%B6%E7%BC%96%E8%AF%91AOSP-Android-14%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://nasdaqgodzilla.github.io/2024/03/19/%E6%8B%89%E5%8F%96%E5%B9%B6%E7%BC%96%E8%AF%91AOSP-Android-14%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2024-03-19T06:33:46.000Z</published>
    <updated>2024-03-20T06:32:53.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">repo</span> init -u https://android.googlesource.com/platform/manifest -b android-<span class="number">14</span>.<span class="number">0</span>.<span class="number">0</span>_r<span class="number">20</span></span><br><span class="line"><span class="attribute">repo</span> sync</span><br></pre></td></tr></table></figure><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> .<span class="regexp">/build/</span>envsetup.sh</span><br><span class="line">lunch sdk_phone_x86_64</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>当想要编译平板镜像时</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lunch</span> sdk_tablet_x<span class="number">86</span>_<span class="number">64</span></span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">emulator</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拉取&quot;&gt;&lt;a href=&quot;#拉取&quot; class=&quot;headerlink&quot; title=&quot;拉取&quot;&gt;&lt;/a&gt;拉取&lt;/h1&gt;&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android bpf简单上手教程</title>
    <link href="https://nasdaqgodzilla.github.io/2023/08/23/Android-bpf%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B/"/>
    <id>https://nasdaqgodzilla.github.io/2023/08/23/Android-bpf%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B/</id>
    <published>2023-08-23T12:10:37.000Z</published>
    <updated>2023-08-23T12:16:29.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>业界对Android的性能监控、hook、系统分析、抓包、逆向等领域的关注和投入在不断提升，作为Linux Kernel中新兴的优美的一套技术框架，bpf逐渐在Android中被用于监控、分析、优化和逆向，产出了众多的工具。此外，Google原生系统的上层服务（如网络流量统计、网络黑白名单）也转向使用ebpf来实现。</p><p>bpf可以理解成Kernel的虚拟机字节码，它借助C语言编译成特定的ELF，通过专用的系统调用注册到Kernel，挂载到指定的tracepoint，进行代码流程的hook，与App的插桩、性能优化的检查点非常类似。</p><p>本文以Android源码AOSP为基础，讲解一个bpf程序应该如何被编译、集成到系统、在系统中启动&#x2F;运行，并使用C语言编写了一个可以实际运行的bpf程序（<a href="https://github.com/NasdaqGodzilla/cpuprobe%EF%BC%89%E3%80%82">https://github.com/NasdaqGodzilla/cpuprobe）。</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>常规的C语言bpf程序需要编译为Kernel BPF子系统能够识别的专用字节码，Android采用了一套独特的编译系统（Android.bp）来包装包含bpf程序在内的编译流程。</p><p>一个最简单的bpf编译描述如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">bpf </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">&quot;cpu_stats.o&quot;</span>,</span><br><span class="line"><span class="symbol">    srcs:</span> [<span class="string">&quot;cpu_stats.c&quot;</span>],</span><br><span class="line"><span class="symbol">    cflags:</span> [</span><br><span class="line">        <span class="string">&quot;-Wall&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-Werror&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段写在Android.bp内的bpf代码声明了需要编译一个名称为cpu_stats.o的bpf程序，srcs指定了其源文件，cflags指定了向编译器传递的编译参数。</p><p>前面说过，一个bpf程序，从结构上说是一个elf，从逻辑上说是一个被Kernel BPF虚拟机加载后才能执行的字节码（类似JS解释器加载JS），因此它编译期间不会发生链接，不会产生可执行bin文件，也不能直接执行。</p><p>通过AOSP的模块编译指令即可编译：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">m</span> cpu_stats.o</span><br></pre></td></tr></table></figure><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>常规的bpf程序有多种集成方式，包括调用bpf()、通过python、bpftrace等（本质也是bpf()）调用。但出于安全和效率的原因，Android屏蔽了bpf()，仅提供了bpf loader在开机阶段加载预置的bpf程序，在开机后，系统就不能再加载任何bpf程序了。</p><p>bpf loader会加载存放在&#x2F;system&#x2F;etc&#x2F;bpf目录下的所有bpf程序，因此将我们编译出来的bpf程序放入该路径（或通过Android.bp、Android.mk等预置）即可让系统自动为我们加载我们的bpf程序：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">push</span> cpu_stats.o <span class="regexp">/system/</span>etc/bpf</span><br><span class="line">adb <span class="keyword">push</span> cpu_stats_client <span class="regexp">/system/</span>bin/</span><br></pre></td></tr></table></figure><p>这里我们还push了一个cpu_stats_client，稍后解释它的作用。<br>push后，重启设备，让Android自动加载这个bpf程序，加载成功的话日志大概长这样：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LibBpfLoader: Loading ELF object <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o with license GPL</span><br><span class="line">LibBpfLoader: Loaded code section <span class="number">3</span> (tracepoint_sched_sched_switch)</span><br><span class="line">LibBpfLoader: Loaded relo section <span class="number">3</span> (.reltracepoint<span class="regexp">/sched/</span>sched_switch)</span><br><span class="line">LibBpfLoader: Adding section <span class="number">3</span> to cs list</span><br><span class="line">LibBpfLoader: bpf_create_map name cpu_stats_map, ret: <span class="number">27</span></span><br><span class="line">LibBpfLoader: map_fd found at <span class="number">0</span> is <span class="number">27</span> in <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o</span><br><span class="line">LibBpfLoader: applying relo to instruction at <span class="keyword">byte</span> offset: <span class="number">144</span>,               insn offset <span class="number">18</span> , insn <span class="number">118</span></span><br><span class="line">LibBpfLoader: <span class="keyword">New</span> bpf core prog_load <span class="keyword">for</span> <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o (tracepoint_sched_sched_switch) returned: <span class="number">28</span></span><br><span class="line">bpfloader: Attempted load object: <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o, ret: Success</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>系统启动时，会自动把上述目录的bpf程序交给内核进行加载。内核为了安全，会进行字节码分析，检测待加载的bpf程序是否带有Bug如越界、空指针、死循环等，以此来排除崩溃风险和恶意攻击。如果程序没有什么问题，就会成功加载。</p><p>加载成功的一个标志是，bpf程序定义的map（bpf的数据结构，稍后解释）会出现在指定目录下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local@device:<span class="regexp">/ # ls /</span>sys<span class="regexp">/fs/</span>bpf/map_cpu_stats_cpu_stats_map</span><br><span class="line"><span class="regexp">/sys/</span>fs<span class="regexp">/bpf/m</span>ap_cpu_stats_cpu_stats_map</span><br></pre></td></tr></table></figure><p>这个map由bpf程序在代码里面通过函数定义得到，当bpf程序hook命中时，Kernel会回调bpf程序，bpf程序通常将其业务逻辑中产生的需要存储的数据保存在这个map里面。这个map的两大主要作用，一是让bpf程序能够保存数据（因为bpf程序即不能使用内核的栈、堆，也不能使用被hook命中的应用程序的栈、堆），二是这个map可以让应用程序读取到，是一种bpf程序向应用程序进行通信的方式，bpf程序可以往这个map写东西，向用户态应用程序通信。</p><h1 id="程序解释"><a href="#程序解释" class="headerlink" title="程序解释"></a>程序解释</h1><p>从bpf程序本身的结构来看，bpf程序主要有两大部分组成：1. 指定的hook点以及这个hook点的处理函数，用于hook；2. 定义的bpf map，用于存储数据。</p><h2 id="执行hook并保存数据"><a href="#执行hook并保存数据" class="headerlink" title="执行hook并保存数据"></a>执行hook并保存数据</h2><ol><li>通过DEFINE_BPF_MAP来创建bpf map</li><li>通过SEC()来指定hook点，当kernel对应事件发生时，会回调SEC指定的函数</li><li>SEC指定的回调函数内执行hook逻辑，可以向bpf map读写数据，用于存储数据，或用于向用户态应用程序传递信息</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">DEFINE_BPF_MAP(<span class="params">cpu_stats_map</span>, LRU_HASH, CPU_STATS_BPFMAP_KEY, CPU_STATS_BPFMAP_VALUE, CPU_STATS_MAXENTRIES)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEFINE_BPF_PROG(&quot;tracepoint/sched/sched_switch&quot;, AID_ROOT, AID_NET_ADMIN, cpu_stats_tp_sched_switch) (struct switch_args* args) &#123;</span></span><br><span class="line"><span class="constructor">SEC(<span class="string">&quot;tracepoint/sched/sched_switch&quot;</span>)</span></span><br><span class="line"><span class="built_in">int</span> cpu<span class="constructor">_stats_tp_sched_switch(<span class="params">struct</span> <span class="params">switch_args</span><span class="operator">*</span> <span class="params">args</span>)</span> &#123;</span><br><span class="line">    CPU_STATS_BPFMAP_KEY ktime_ns = bpf<span class="constructor">_ktime_get_ns()</span>;</span><br><span class="line">    CPU_STATS_BPFMAP_VALUE record = &#123;</span><br><span class="line">        .ktime_ns = ktime_ns,</span><br><span class="line">        .smp_id = bpf<span class="constructor">_get_smp_processor_id()</span>,</span><br><span class="line">        .uid_gid = bpf<span class="constructor">_get_current_uid_gid()</span>,</span><br><span class="line">        .pid_tgid = bpf<span class="constructor">_get_current_pid_tgid()</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    memset(record.comm, <span class="character">&#x27;\0&#x27;</span>, sizeof(record.comm));</span><br><span class="line">    memcpy(record.comm, args-&gt;next_comm, sizeof(record.comm));</span><br><span class="line"></span><br><span class="line">    bpf<span class="constructor">_cpu_stats_map_update_elem(&amp;<span class="params">ktime_ns</span>, &amp;<span class="params">record</span>, BPF_ANY)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> _license<span class="literal">[]</span> <span class="constructor">SEC(<span class="string">&quot;license&quot;</span>)</span> = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>前面“集成”小节里面示例命令有将一个cpu_stats_client push到&#x2F;system&#x2F;bin，实际上它就是用来读取数据的工具。</p><ol><li>通过bpf_obj_get()来取得bpf程序和bpf map的句柄（不是使用常规的fd open）</li><li>通过android::bpf::BpfMap来遍历bpf map里面的所有数据（Key-Value对）</li></ol><p>可以访问文章开头的Github链接查看完整代码</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>bpf提供了强大的功能，凭借数量众多的tracepoint和kprobe，绝大多数位置都能提供hook，在不修改内核的情况下能实现非常精彩的业务逻辑，在Android上必然能发挥重要作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;业界对Android的性能监控、hook、系统分析、抓包、逆向等领域的关注和投入在不断提升，作为Linux Kernel中新兴的优美的一套技</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="稳定性" scheme="https://nasdaqgodzilla.github.io/categories/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="稳定性" scheme="https://nasdaqgodzilla.github.io/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android BatteryStats服务功耗统计流程详解</title>
    <link href="https://nasdaqgodzilla.github.io/2023/06/17/Android-BatteryStats%E6%9C%8D%E5%8A%A1%E5%8A%9F%E8%80%97%E7%BB%9F%E8%AE%A1%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nasdaqgodzilla.github.io/2023/06/17/Android-BatteryStats%E6%9C%8D%E5%8A%A1%E5%8A%9F%E8%80%97%E7%BB%9F%E8%AE%A1%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-06-17T10:18:39.000Z</published>
    <updated>2023-06-17T10:27:37.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>BatteryStatsService和BatterStatsImpl是系统中用于估算电流消耗的关键对象，能够估算并存储软件功耗和硬件功耗。其中主要流程分为事件回调时记录耗电信息、触发读取时计算并统计耗电信息两大流程。本文介绍耗电信息的读取和统计过程。</p><h1 id="BatteryStatsService和BatteryStatsImpl"><a href="#BatteryStatsService和BatteryStatsImpl" class="headerlink" title="BatteryStatsService和BatteryStatsImpl"></a>BatteryStatsService和BatteryStatsImpl</h1><p>BatteryStatsService提供App和硬件的功耗，是通过BatteryStatsImpl的接口<code>getUidStats()</code>方法取得的，在分析该方法的流程前先简单介绍一些关键成员。</p><p>BatteryStatsHelper关键成员：</p><ol><li>BatterySipper：按照Uid和drain type来过滤存储的功耗记录，从BatteryStatsImpl中提取。可以理解为从系统记录的全部功耗信息中，按照Uid和Drain type提取出来。其中Drain type是耗电类型，如屏幕耗电、Wi-Fi耗电、App耗电等</li><li>mUsageList：以BatterySipper的形式记录各Uid的功耗</li><li>mWifiSippers、mBluetoothSippers：Wi-Fi、蓝牙专用的功耗记录（也是BatterySipper的形式）</li><li>mUserSippers：mUsageList只存储<code>refresh</code>方法传入的参数内的uid的耗电。当uid不在refresh方法指定的uid范围内时，不存储到mUsageList而是存储到这里</li><li>mMobilemsppList：各App的milliseconds per packets：各App的每个数据包的平均时间</li><li>mRawRealtimeUs mRawUptimeUs : refresh()调进来的传入的elapsed time和uptime</li><li>mBatteryUptimeUs mBatteryRealtimeUs mRaw*timeUs下当前battery*time</li><li>mTypeBatteryUptimeUs mTypeBatteryRealtimeUs：当前版本的Android只支持上一次充满电后的记录，因此等同于mBattery*timeUs</li><li>mBatteryTimeRemainingUs 根据上一次充满电后的掉电量&#x2F;掉电时间估算出来还需要多久用光电池</li><li>mChargeTimeRemainingUs 根据充电量&#x2F;充电时间估算出来的还需要多久充满电池</li><li>mMinDrainedPower mMaxDraingedPower 上次充电后的最小&#x2F;最大的一次掉电量范围</li><li>BatteryStatsImpl.TimeBase：拔掉电源、熄屏等各有一个TimeBase，封装了成员用于计算这些事件后的事件</li></ol><h2 id="BatteryStatsHelper-refreshStats：获取功耗记录主入口"><a href="#BatteryStatsHelper-refreshStats：获取功耗记录主入口" class="headerlink" title="BatteryStatsHelper.refreshStats：获取功耗记录主入口"></a>BatteryStatsHelper.refreshStats：获取功耗记录主入口</h2><p><code>refreshStats()</code>方法用于获取系统记录的耗电情况，流程如下。</p><ol><li>功耗记录是借助Binder从BatteryStatsService获取的：BatteryStatsService.getStats()-&gt;getActiveStatistics()获取BatteryStatsImpl（binder parcel传递）</li><li>调用processAppusage计算各Uid App的电耗</li><li>调用processMiscUsage()计算硬件功耗</li><li>计算mUsageList内记录的最高功耗到mMaxRealPower、mMaxPower</li><li>计算mUsageList内记录的各Uid的总功耗到mComputedPower、mTotalPower</li><li>根据mMinDrainedPower和mMaxDrainedPower，确定UNAACCOUNTED、OVERCOUNTED的电耗量，更新mTotalPower和mMaxPower，将over count和un count的电耗量加入到mUsageList中</li><li>进行电耗摊派。部分电耗属于系统需要隐藏的（shouldHideSipper），或者是要分摊给Uid们的。其中，要分摊的种类是需要隐藏的种类的子集，也就是说部分需要隐藏的电耗是不需要摊派的（或者之前已经摊派了，不用重复分摊）。其中屏幕功耗的分摊方式是，根据几个sipper的前台时间来算比例，根据前台时间的多少来承担对应比例的屏幕功耗，将屏幕功耗按前台时间分出去；承担了屏幕功耗的sipper会将自己分担的屏幕功耗记录到proportionalSmearMah，并调用sumPower()更新自己的总功耗</li><li>至此，详细功耗信息就记录到了mUsageList中了，通过BatteryStatsHelper.getUsageList()即可取得，遍历该集合的BatterySipper即可取得各uid的耗电记录</li></ol><h2 id="processAppUsage-：读取并按uid来计算App耗电"><a href="#processAppUsage-：读取并按uid来计算App耗电" class="headerlink" title="processAppUsage()：读取并按uid来计算App耗电"></a>processAppUsage()：读取并按uid来计算App耗电</h2><p>该方法根据uid和drain type来统计App的耗电情况。</p><ol><li>BatteryStatsImpl.getUsageStats()取得所有Uid，遍历processAppUsage()传入指定的需要统计的uid</li><li>创建BatterySipper；BatterySipper用于提取Uid里面指定消耗类型；因为Uid里面记录了App、硬件等不同类型的消耗，这里只统计App自己的消耗（排除硬件）；Sipper的作用其实就是从Uid里面提取Type对应的数据并存储下来</li><li>通过几大类的PowerCalculator.calculateApp()将Uid内的信息提取出来，进行计算，将数据存储进sipper</li><li>最后调用sipper.sumPower()将几大类的功耗全部加起来得到总功耗</li><li>接着当这个Uid sumpower &gt; 0时，就根据uid来添加到对应的sipper集合中。<ol><li>Wifi、蓝牙对应的Uid会独立存储在它们的特定的sipper集合</li><li>当该Uid不是processAppUsage()参数指定的要读取的uid时、且该UID是App的Uid（≥FISTST_APPLICATION_UID）时，存储到mUserSippers中</li><li>都不是时，存储到mUsageList这个sipper集合中</li><li>UID &#x3D;&#x3D; 0（ROOT）时，处理为uid为0的实体的Wakelock的功耗，相当于将uid为0的drain type为App的情况算作系统的唤醒功耗（设备唤醒的时间可能比屏幕亮起时间和应用程序唤醒锁定时间要长。如果可能，将此余数分配给操作系统）；记录到uid为0的drain type为app的记录时，表明应用可能都已经停止耗电，但系统还有服务或逻辑在运行，或进入睡眠前的一段间隔，这些内容会算作系统的功耗，并在Uid记录中体现</li></ol></li></ol><h3 id="PowerCalculator：9大耗电类别计算App耗电"><a href="#PowerCalculator：9大耗电类别计算App耗电" class="headerlink" title="PowerCalculator：9大耗电类别计算App耗电"></a>PowerCalculator：9大耗电类别计算App耗电</h3><p>PowerCalculator是abstract类，用于App的9大类别的耗电计算，分别为：CPU、WakeLock、移动网络、Wifi、蓝牙、传感器、摄像头、闪光灯、媒体：9大类。</p><p>主要方法：</p><ol><li>reset()：清除掉本计算器内的所有状态和数据</li><li>calculateApp(BatterySipper，BatteryStats.Uid，rawRealtimeUs，rawUptimeUs，statsType)：计算App在这个类别下消耗的电量；其中sipper用于从Uid提取对应的信息，可以理解成一个提供过滤能力的吸管，用于存储返回给调用者的信息，包括类型、uid、各项细节功耗值；real&#x2F;upTime：系统当前的real time和uptime；realtime就是linux系统记录的系统启动以来经过的时间，uptime是realtime去掉休眠的时间；statsType是如何统计，Android Q以后只有一种方式：从上一次充满电后开始的所有数据</li><li>calculateRemaining()，参数与calApp()完全一致；作用是当Uid内部记录的电量消耗不能全部算给App时，剩余的电量消耗</li></ol><h3 id="class-Uid"><a href="#class-Uid" class="headerlink" title="class Uid"></a>class Uid</h3><p>BatteryStats有个内部类<code>Uid</code>，它封装了各uid（应用、系统等）以及它们的运行时长、耗电信息、网络收发情况、CPU时间等等一切和功耗有关的信息。各个PowerCalculator基于这个对象内存储的数据来进行计算。</p><h3 id="CpuPowerCalculator：计算App消耗在CPU上的功耗"><a href="#CpuPowerCalculator：计算App消耗在CPU上的功耗" class="headerlink" title="CpuPowerCalculator：计算App消耗在CPU上的功耗"></a>CpuPowerCalculator：计算App消耗在CPU上的功耗</h3><p>BatterySipper与CPU相关的主要是：cpuTimeMs、cpuFgTimeMs、cpuPowerMah、packageWithHighestDrain，CpuPowerCalculator主要就是读取并计算这些值，存储到上述sipper的这些成员中，最后存储到mUsageList或mUserSippers。</p><p>calculateApp：</p><ol><li>调用Uid的方法取得Uid记录的uid对应的CPU时间（分不同的cluster（簇，不同的簇，因大小核、架构而功耗不一样）、不同的CPU速度），将这些数据与power_profile.xml记录的硬件功耗相乘后相加，得到Uid在CPU上消耗的时间和电量。其中CPU电量的计算公式是：总电耗&#x3D;总CPU时间*CPU激活状态下的功耗 + 各频率运行时长*各频率对应额外运行功耗</li><li>一个uid可以有多个进程，Uid.Proc对象表示一个进程的唤醒时长等统计信息，同一个uid的进程的信息对应的若干Proc存储在Uid内的ArrayMap中；取得Uid内所有Proc的foreground time求和得到uid对应的总的cpuFdTimeMs，存入sipper；并总时间（user time、system time、fg time）最大的Proc存储到sipper的packageWithHighestDrain用于表示该Uid下CPU消耗最大的Proc</li></ol><p>calculateRemaining：空实现</p><h3 id="WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗"><a href="#WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗" class="headerlink" title="WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗"></a>WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗</h3><p>calculateApp:</p><ol><li>WakeLock专门存储于一个集合，用Uid.Wakelock表示，里面记录的Wake time取出后累加记录到sipper的wakeLockTimeMs</li><li>电量计算公式为：wakeLockTimeMs * CPU idle电耗</li></ol><p>calculateRemaining：</p><ol><li>calculateApp只统计了Uid自己的wakelock时长对应的电耗，当Uid内记录的电池时间大于sum(WakeLockTime + ScreenOnTime)时，大于的部分算作app wake，同样算入wakeLockTimeMs、及对应电耗</li></ol><h3 id="MobileRationPowerCalculator：计算App进行的移动网络射频功耗"><a href="#MobileRationPowerCalculator：计算App进行的移动网络射频功耗" class="headerlink" title="MobileRationPowerCalculator：计算App进行的移动网络射频功耗"></a>MobileRationPowerCalculator：计算App进行的移动网络射频功耗</h3><p>calculateApp：根据App收发的数据包数量结合power_profile计算电耗</p><p>calculateRemaining：根据信号强度、扫描次数结合power_profile计算电耗</p><h3 id="WifiPowerCalculator：计算App进行的Wifi收发功耗"><a href="#WifiPowerCalculator：计算App进行的Wifi收发功耗" class="headerlink" title="WifiPowerCalculator：计算App进行的Wifi收发功耗"></a>WifiPowerCalculator：计算App进行的Wifi收发功耗</h3><p>calculateApp：根据收发时长、空闲时长结合power_profile计算电耗；获取Uid存储的收发字节数、数据包数量存储到sipper</p><h3 id="MediaPowerCalculator：计算App音视频功耗"><a href="#MediaPowerCalculator：计算App音视频功耗" class="headerlink" title="MediaPowerCalculator：计算App音视频功耗"></a>MediaPowerCalculator：计算App音视频功耗</h3><p>calculateApp：Audio、Video时长*对应功耗得出电耗</p><h2 id="processMiscUsage-：统计硬件功耗"><a href="#processMiscUsage-：统计硬件功耗" class="headerlink" title="processMiscUsage()：统计硬件功耗"></a>processMiscUsage()：统计硬件功耗</h2><p>该方法用于统计硬件的功耗，与App功耗一致，都是根据Uid、Drain type借助sipper来计算的。</p><h3 id="addUserUsage"><a href="#addUserUsage" class="headerlink" title="addUserUsage"></a>addUserUsage</h3><p>前面统计App用量时提到，如果不是App的uid或没有在refreshStats方法传入的参数中没包含这个uid，那么不会存到mUsageList里面，而是在mUserSippers内；这个方法将mUserSippers内的DrainType为User的sipper提取出来放入mUsageList内。</p><p>注意前面processAppUsage处理的DrainType是APP，这里是USER。</p><h3 id="addPhoneUsage"><a href="#addPhoneUsage" class="headerlink" title="addPhoneUsage"></a>addPhoneUsage</h3><p>添加”Phone On”类型的功耗；这里统计的是Ratio功能active的功耗，可以认为是不开飞行模式时、上了基站的通话网络情况下功耗；形象理解为：设备正常放着，不进行基带射频、扫描、上网、通话时的功耗</p><h3 id="addScreenUsage"><a href="#addScreenUsage" class="headerlink" title="addScreenUsage"></a>addScreenUsage</h3><p>添加屏幕的功耗，DrainType.Screen加入到mUsageList</p><h3 id="addAmbientDisplayUsage"><a href="#addAmbientDisplayUsage" class="headerlink" title="addAmbientDisplayUsage"></a>addAmbientDisplayUsage</h3><p>添加屏幕微光情况下的功耗（Display Doze)，DrainType.Ambient加入到mUsageList</p><h3 id="addWiFiUsage"><a href="#addWiFiUsage" class="headerlink" title="addWiFiUsage"></a>addWiFiUsage</h3><p>统计除分摊给App以外的剩余Wifi消耗，从mWifiSippers中提取，以DrainType.WIFI的新的sipper加入到mUsageList。</p><h3 id="addBluetoothUsage"><a href="#addBluetoothUsage" class="headerlink" title="addBluetoothUsage"></a>addBluetoothUsage</h3><p>蓝牙消耗的电量不会像WiFi一样会分摊给各个使用的App，它没有进行摊派全部统计在这里。该方法统计蓝牙的整体消耗；同WIFI，DrainType.BLUETOOTH加入mUsageList</p><h3 id="addMemoryUsage"><a href="#addMemoryUsage" class="headerlink" title="addMemoryUsage"></a>addMemoryUsage</h3><p>类似蓝牙的情况</p><h3 id="addIdleUsage"><a href="#addIdleUsage" class="headerlink" title="addIdleUsage"></a>addIdleUsage</h3><p>统计设备休眠、空闲时的AP（App Processor，即CPU）的功耗——也就是说，不包含BP（基带）的功耗，由于外设已经关闭或挂起、系统已经休眠，可以认为是深度待机状态下的整机功耗，可以说是开机状态下设备的最低功耗了</p><p>DrainType.IDLE sipper加入到mUsageList</p><h3 id="addRadioUsage"><a href="#addRadioUsage" class="headerlink" title="addRadioUsage"></a>addRadioUsage</h3><p>射频也和Wifi一样进行了摊派，同样是将没有摊派出去的独立出来到DrainType.CELL。其中，射频会额外关注信号强度，信号强度对射频功率、模组功耗影响大，进而影响对电耗的估算</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BatteryStatsService从系统各服务、驱动节点、Linux文件系统节点中取得的数据，在需要时，通过BatteryStatsImpl.refresh()取出、过滤、计算。其中，按照App电耗、硬件电耗两大部分来分别计算。耗电信息从Uid中取得，经过PowerCalculator处理后放入BatterySipper。一些类别的硬件电耗会分摊到使用它的几个App中，最终会以uid和Drain Type的形式来存储到多个BatterySipper中，交给调用者完成整个功耗信息获取过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;BatteryStatsService和BatterStatsImpl是系统中用于估算电流消耗的关键对象，能够估算并存储软件功耗和硬件功耗。</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/categories/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/tags/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>Android后台驻留：保活和回收的机制</title>
    <link href="https://nasdaqgodzilla.github.io/2023/06/03/Android%E5%90%8E%E5%8F%B0%E9%A9%BB%E7%95%99%EF%BC%9A%E4%BF%9D%E6%B4%BB%E5%92%8C%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://nasdaqgodzilla.github.io/2023/06/03/Android%E5%90%8E%E5%8F%B0%E9%A9%BB%E7%95%99%EF%BC%9A%E4%BF%9D%E6%B4%BB%E5%92%8C%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2023-06-03T07:10:56.000Z</published>
    <updated>2023-06-03T07:11:51.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>众所周知，Android平台的管理机制下，App进入后台后，为了提供持续的及时服务（如推送、音乐），或进行驻留获取收益（跟踪、信息收集、广告）等，会利用一些方法来让自身保持活跃，躲过被Android系统或用户发觉、清理，实现后台驻留。</p><p>其中，后台驻留的广义概念，除了保持在后台运行外，被其他组件拉起也属于驻留（唤醒）。</p><p>由于驻留会对系统的性能、响应延迟、续航、发热等带来负面影响，令系统的资源管理效果降低，属于违背用户意愿和知情的恶劣行为，因此将这些App称为顽固（Diehard）应用，其利用的方法称为顽固方法。</p><p>除了App利用的一些黑科技（甚至是在违法边缘的擦边手段）以外，Android系统本身自带的机制也可以实现保活和拉起。这些保活、拉起机制，粗略划分为两类：</p><ol><li>保持活跃，在后台运行不被清理、回收</li><li>被其他组件唤醒，包括被其他App唤醒、被系统提供的功能唤醒</li></ol><p>本文总结上述这两类会被顽固App利用的机制。</p><h1 id="进程和Task管理"><a href="#进程和Task管理" class="headerlink" title="进程和Task管理"></a>进程和Task管理</h1><p>首先简单梳理一下Android Framework层基本的进程管理。</p><p>Android平台基于Linux，除了基于Linux的“进程”维度来进行管理外，还按照Task的概念来管理应用进程，分别为ProcessRecord和TaskRecord。系统可以按Task也可以按Process来管理进程。</p><p>Android提供接口直接杀死Linux进程：1. ProcessRecord的kill()方法，其实现是向对应的进程发送SIGNAL_KILL信号；2. libc的kill()函数，也是发送信号</p><h2 id="OOM终止进程（LMK）"><a href="#OOM终止进程（LMK）" class="headerlink" title="OOM终止进程（LMK）"></a>OOM终止进程（LMK）</h2><p>App进程在系统中根据OOM（Out of Memory）ADJ（Adjustment）级别和进程状态来确定优先级，当系统需要杀死进程来释放内存时，优先级越低的会优先终止。OOM ADJ分数越小优先级越高。</p><p>由于顽固App进程后台驻留时可能会被系统回收，因此顽固App通常通过一些手段（services、弹窗）等来降低OOM（提高优先级），减少自身被系统回收的几率。</p><h2 id="最近任务列表结束Task"><a href="#最近任务列表结束Task" class="headerlink" title="最近任务列表结束Task"></a>最近任务列表结束Task</h2><p>用户在多任务界面（Recents）移除应用，系统会结束应用对应的Task：Removing Recent Task Item（RRT）。</p><p>该操作会结束掉与Task关联的进程，但在一些场景下仍然会有对应App的进程没有被杀死。</p><ol><li>当App通过”Exclude from recents”功能（不在最近任务列表显示自己）时，没有提供给用户结束的机会，就没有手动结束掉Task的入口</li><li>当一个进程属于多个Task时（该进程还需要为其他Task服务）</li></ol><p>这类终止机制由用户操作触发，当顽固应用借助多进程、多任务、唤醒拉起、互拉等操作，被终止后仍在后台运行（或后续又被唤醒），给用户感受为“杀不干净”。</p><h2 id="强制结束App"><a href="#强制结束App" class="headerlink" title="强制结束App"></a>强制结束App</h2><p>强制结束（Force-Stop）时Android内建的功能，由ActivityManagerService提供接口，可以在设置-应用程序界面由用户手动调用。</p><p>强制结束的范畴是App对应的所有Task（即可以杀死一般App所有进程）。FSA还额外会将App设置为“STOPPED“状态，禁止应用在下一次被用户手动启用或应用跳转前被广播、服务等唤醒。强制结束对顽固App的效果不佳，许多顽固App具备Native保活能力、互拉保活、唤醒拉起等对抗措施。</p><p>此外，Android提供KILL_BACKGROUND_PROCESSES权限，允许具备权限的App调用API杀死ADJ大于SERVICE_ADJ的后台进程（即没有Service的后台进程可以被杀掉）。</p><h1 id="保持活跃或唤醒"><a href="#保持活跃或唤醒" class="headerlink" title="保持活跃或唤醒"></a>保持活跃或唤醒</h1><h2 id="从最近任务隐藏或多个最近任务"><a href="#从最近任务隐藏或多个最近任务" class="headerlink" title="从最近任务隐藏或多个最近任务"></a>从最近任务隐藏或多个最近任务</h2><p>Android平台提供的excludeFromRecents功能可以让App的Task在多任务中隐藏。此外一个进程可以属于不同的Task，产生多个Task并隐藏其中几个Task可以实现”杀不干净“的效果。</p><h2 id="提升App进程优先级、阻止部分回收场景"><a href="#提升App进程优先级、阻止部分回收场景" class="headerlink" title="提升App进程优先级、阻止部分回收场景"></a>提升App进程优先级、阻止部分回收场景</h2><p>LMK和OOM ADJ会受到进程状态和优先级的影响，提高优先级可以降低被系统回收的几率，阻止部分会杀进程的场景。</p><p>其中，将借助前台进程绑定后台服务进程保活的手段，是较常见的“杀不死、杀不干净”的情况（最近任务移除后仍有进程）。</p><ol><li>接收广播，启动Receiver，具有Receiver的后台进程优先级高于无Receiver的后台进程</li><li>创建前台Service（高版本Android前台service需要带有通知），OOM ADJ更低（SERVICE_ADJ），杀死概率更低，此时进程不会被“杀死后台进程”杀掉（会跳过ADJ小于等于SERVICE_ADJ的进程）</li><li>保持前台Activity，OOM ADJ更低（用户可见的Task）</li><li>创建前台窗口（悬浮窗）或覆盖窗口（将窗口盖在前台App上面）</li><li>将后台服务绑定到前台进程，赋予后台服务在的进程更低的OOM，提升该进程的优先级，减少被杀的几率；同时对应进程不再属于后台进程，不会被“杀死后台进程”杀死，且该进程转为“需要为其他Task服务”，同样不会被最近任务移除时杀死</li><li>对于涉及Service的场景，ContentProvider也适用</li></ol><h2 id="借助Sticky-Service唤醒"><a href="#借助Sticky-Service唤醒" class="headerlink" title="借助Sticky Service唤醒"></a>借助Sticky Service唤醒</h2><p>黏性Service是系统提供的机制，被杀死后会由系统调度进行重启。前述的force-stop杀死的进程，由于设置的“STOPPED”状态是会被跳过的，因此这种情况杀死的进程不会再自动重启。大多数ROM对此都有限制（次数、频率）。</p><h2 id="借助广播唤醒"><a href="#借助广播唤醒" class="headerlink" title="借助广播唤醒"></a>借助广播唤醒</h2><p>通过系统或其他App、组件发出的广播可以唤醒应用，顽固应用可以借助广播来完成唤醒自启。同样的，force-stop设置的“STOPPED”状态也会让广播跳过这些App，不会唤醒这些App来传递广播。但广播带有一个特例功能，带有FLAG_INCLUDE_STOPPED_PACKAGES的广播可以无视“STOPPED状态”，仍会唤醒force-stop的App。通常系统广播没有这个FLAG，基本上是其他应用发出的广播带有。</p><p>高版本的Android已经不再触发静态广播和隐式广播，这种唤醒方式少了很多。（但有FLAG_RECEIVER_INCLUDE_BACKGROUND和FLAG_INCLUDE_STOPPED_PACKAGES规避）</p><h2 id="借助Alarm-Service定时器唤醒"><a href="#借助Alarm-Service定时器唤醒" class="headerlink" title="借助Alarm Service定时器唤醒"></a>借助Alarm Service定时器唤醒</h2><p>Alarm是Android提供的定时器功能，定时器timeout时会唤醒App。被force-stop的应用会自动移除掉注册的定时器，因此不会被唤醒。</p><h2 id="借助Job-Scheduling-Service任务调度唤醒"><a href="#借助Job-Scheduling-Service任务调度唤醒" class="headerlink" title="借助Job Scheduling Service任务调度唤醒"></a>借助Job Scheduling Service任务调度唤醒</h2><p>与Alarm类似，定时唤醒App。但是受到电源管理策略、功耗管理策略、系统休眠状态、WorkManager等的影响，唤醒的定时精度较低，且不同ROM可能表现一致性较差。同样的，会跳过被force-stop的App。</p><h2 id="借助其他App拉起唤醒"><a href="#借助其他App拉起唤醒" class="headerlink" title="借助其他App拉起唤醒"></a>借助其他App拉起唤醒</h2><p>这是国内互联网App最恶心的一种机制，一群App（或集成的SDK）互相拉起对方、互相绑定提高优先级、互相拉起唤醒。其中，唤醒方式除了常规的四大组件外，还有一些黑科技、Native的方法。其中，App发出的广播带上FLAG_RECEIVER_INCLUDE_BACKGROUND和FLAG_INCLUDE_STOPPED_PACKAGES完全可以规避force-stop后”STOPPED”的应用，实现唤醒。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以说，Android本身的管理机、提供的组件间通信功能，叠加App们的流氓行为，可以说后台驻留、拉起唤醒是防不胜防的，实现较好的后台驻留管理需要较高的投入，且对系统稳定性、App基本功能的影响较大，是高投入高难度的研究方向。其中，App互拉唤醒和保活的机制，让force-stop机制做不到太好的效果，其”STOPPED”实现的类似的轻度冻结状态几乎报废，也是各大ROM厂商在后台管理部分大展身手的重要因素。</p><p>为了实现好的功耗、续航、性能，就需要在应用唤醒、冻结、暂停执行等方面下功夫了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;众所周知，Android平台的管理机制下，App进入后台后，为了提供持续的及时服务（如推送、音乐），或进行驻留获取收益（跟踪、信息收集、广告</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/categories/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/tags/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>Android性能监控：主循环性能统计LooperStatsService详解</title>
    <link href="https://nasdaqgodzilla.github.io/2023/05/05/Android%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9A%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1LooperStatsService%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nasdaqgodzilla.github.io/2023/05/05/Android%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9A%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1LooperStatsService%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-05-05T09:38:02.000Z</published>
    <updated>2023-05-05T09:39:14.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在Android性能监控和优化领域，一个会影响App性能表现的因素与Handler Message Looper机制有关。当Looper里面的Message处理不及时、或数量太多占用过多处理时间时，可能会出现卡顿感，并且不容易定位到卡顿的Message和慢方法。</p><p>Android本身提供了LooperStats机制来统计和监测Message的处理，并且可以通过LooperStatsService来统计和记录，方便调试和分析。</p><h1 id="LooperStatsService详解"><a href="#LooperStatsService详解" class="headerlink" title="LooperStatsService详解"></a>LooperStatsService详解</h1><h2 id="由SystemServer创建、Settings数据库变更触发启动"><a href="#由SystemServer创建、Settings数据库变更触发启动" class="headerlink" title="由SystemServer创建、Settings数据库变更触发启动"></a>由SystemServer创建、Settings数据库变更触发启动</h2><p>LooperStatsService是一个系统服务，由SystemServer在开机阶段启动。按照系统服务的接口要求，它是通过LooperStatsService.Lifecycle这个类被启动的。</p><p>启动流程主要是初始化LooperStats、LooperStatsService和SettingsObserver。</p><p>SettingsObserver在Settings数据库的值发生变化时回调，回调方法中根据特定格式来解析数据库的内容，根据解析的内容确定是否开始监控、监控频率等。</p><p>数据库是Settings.Global.looper_stats，对应的数据库格式如下：使用键值对（key&#x3D;value）来表示一个参数和它的值，多个键值对之间用逗号分隔。参数包括：sampling_interval控制采样频率（毫秒，默认1000），track_screen_state控制是否跟踪屏幕状态（默认false）。</p><p>也就是说，执行如下adb指令，写入Settings数据库，就能让LooperStatsService开始采样监控App的主循环Looper：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings <span class="keyword">put</span> <span class="keyword">global</span> looper_stats sampling_interval=<span class="number">100</span>,track_screen_state=<span class="literal">true</span>,enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动流程非常简单，先参数值初始化，然后将Observer设置到Looper。</p><p>也可以采用adb命令的方式来控制：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd looper_stats</span></span><br><span class="line"><span class="attr">looper_stats commands:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="string">Enable</span> <span class="string">collecting</span> <span class="string">stats.</span></span><br><span class="line">  <span class="attr">disable:</span> <span class="string">Disable</span> <span class="string">collecting</span> <span class="string">stats.</span></span><br><span class="line">  <span class="attr">sampling_interval:</span> <span class="string">Change</span> <span class="string">the</span> <span class="string">sampling</span> <span class="string">interval.</span></span><br><span class="line">  <span class="attr">reset:</span> <span class="string">Reset</span> <span class="string">stats.</span></span><br></pre></td></tr></table></figure><h2 id="Looper-Message-Dispatch流程实现监控"><a href="#Looper-Message-Dispatch流程实现监控" class="headerlink" title="Looper Message Dispatch流程实现监控"></a>Looper Message Dispatch流程实现监控</h2><p>我们知道Android的主线程的死循环被Looper封装，在Looper内部取出MessageQueue内排队的Message，根据Message.target和callback，将其派发到对应的处理方法中，实现消息循环。实现监控的流程也很容易，在消息派发前回调到监控者，消息由处理函数处理完成后，回调监控者，即可实现让监控着感知消息处理的进度。</p><p>Looper本身提供了内部接口类Observer提供回调接口来实现上述需求：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">Object</span> messageDispatchStarting();</span><br><span class="line">        <span class="keyword">void</span> messageDispatched(<span class="keyword">Object</span> token, Message msg);</span><br><span class="line">        <span class="keyword">void</span> dispatchingThrewException(<span class="keyword">Object</span> token, Message msg, <span class="built_in">Exception</span> <span class="built_in">exception</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前两个接口分别在一个消息处理前、一个消息完成处理时回调。第三个接口是Message处理过程中抛出了异常时回调。</p><p>App主事件循环实际上可以抽象为如下流程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// LooperStatsService打开的情况下，会设置sObserver</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line"></span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单来说Looper每次处理Message的流程就是，在消息发给App处理之前、之后分别回调Observer的接口，实现记录。其中，慢速的Message处理也会在这里检查并打印日志。</p><p>LooperStatsService实际上利用了Looper提供的Observer机制，打开后它设置了sObserver，接受Message Loop的回调，在回调中记录数据并做统计。</p><h2 id="LoopStats实现性能数据记录"><a href="#LoopStats实现性能数据记录" class="headerlink" title="LoopStats实现性能数据记录"></a>LoopStats实现性能数据记录</h2><p>LooperStatsService借助LoopStats实现数据记录。在Message派发前，记录三个数据：开机后经过的时间（elpased real time，包含系统休眠）、开机后经过的时间（uptime，不包括系统休眠）、当前线程消耗的时间。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">Object</span> messageDispatchStarting() &#123;</span><br><span class="line">        <span class="keyword">if</span> (deviceStateAllowsCollection() &amp;&amp; shouldCollectDetailedData()) &#123;</span><br><span class="line">            DispatchSession <span class="keyword">session</span> = mSessionPool.poll();</span><br><span class="line">            <span class="keyword">session</span> = <span class="keyword">session</span> == <span class="keyword">null</span> ? <span class="built_in">new</span> DispatchSession() : <span class="keyword">session</span>;</span><br><span class="line">            <span class="keyword">session</span>.startTimeMicro = getElapsedRealtimeMicro();</span><br><span class="line">            <span class="keyword">session</span>.cpuStartMicro = getThreadTimeMicro();</span><br><span class="line">            <span class="keyword">session</span>.systemUptimeMillis = getSystemUptimeMillis();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">session</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DispatchSession.NOT_SAMPLED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，deviceStateAllowsCollection()的判断逻辑是“设备未在充电状态”，shouldCollectDetailedData()用于实现上述设置的采样时间间隔。</p><p>LooperStatsService区分不同的Message分别进行统计，统计的信息存储于Entry中：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> workSourceUid;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> messageName;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isInteractive;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> messageCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> recordedMessageCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> exceptionCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> totalLatencyMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> maxLatencyMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> cpuUsageMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> maxCpuUsageMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> recordedDelayMessageCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> delayMillis;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> maxDelayMillis;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，主要信息是messageName，messageCount记录消息派发的次数，recordedMessageCount记录消息被LooperStats采样并记录到的次数。</p><p>messageCount和recordedMessageCount的差异是：每个消息都让messageCount +1，而满足前述参数设置的采样时间间隔的消息才会被采样、记录，被采样的消息才会让recordedMessageCount +1。</p><p>totalLatencyMicro记录该类型的消息花费的总时间，计算方法是消息派发前、处理完成后两者的elpased time（开机后经过的时间，包含系统或进程休眠）时间差。</p><p>maxLatencyMicro计算该类型的消息在某一次派发、处理花费的最大时间，同样是elpased time。</p><p>cpuUsageMicro和maxCpuUsageMicro，分别计算该类型消息处理时间的总和、最大耗时。计算方法是取得线程运行时间，减去派发前的线程运行时间（即messageDispatchStarting()记录的起始值）即可得到线程处理该消息的耗时（线程实际工作时间，不包含休眠）</p><p>App Message Loop还有一个很大的特点，就是其Message可以指定某个时间再出发（如postDelayed()发出的Message）。那么在一些场景下，要求定时处理的Message可能不能准时触发，而是有一定的延时，可能也会存在性能问题或体验问题，甚至是功能异常。delayMills、maxDelayMills就用于记录发生这些延时的总时间、最大延时。计算方法是，计算派发前、处理后两者的uptime时间差（系统或进程休眠时不计时），大于Message的目标时间的值就是delay的大小。对应的，recordedDelayMessageCount记录延时发生的次数。注意这三个delay数据只针对Message.when有值（即指定了触发时间的Message）的情况才会统计。</p><h2 id="dumpsys获取性能监控数据"><a href="#dumpsys获取性能监控数据" class="headerlink" title="dumpsys获取性能监控数据"></a>dumpsys获取性能监控数据</h2><p>可以在adb shell执行dumpsys looper_stats获取性能统计数据。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dumpsys looper_stats</span><br><span class="line">Start <span class="selector-tag">time</span>: <span class="number">2023</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">08</span></span><br><span class="line">On battery <span class="selector-tag">time</span> (ms): <span class="number">54297</span></span><br><span class="line">work_source_uid,thread_name,handler_class,message_name,is_interactive,message_count,recorded_message_count,total_latency_micros,max_latency_micros,total_cpu_micros,max_cpu_micros,recorded_delay_message_count,total_delay_millis,max_delay_millis,exception_count</span><br><span class="line">-<span class="number">1</span>,PowerManagerService,android<span class="selector-class">.os</span><span class="selector-class">.Handler</span>,<span class="number">0</span>x2,false,<span class="number">5</span>,<span class="number">1</span>,<span class="number">72</span>,<span class="number">72</span>,<span class="number">68</span>,<span class="number">68</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">com<span class="selector-class">.android</span>.systemui/u0a139,WifiHandlerThread,com<span class="selector-class">.android</span><span class="selector-class">.wifi</span><span class="selector-class">.x</span><span class="selector-class">.com</span><span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.util</span>.StateMachine<span class="variable">$SmHandler</span>,<span class="number">0</span>x20053,false,<span class="number">9</span>,<span class="number">1</span>,<span class="number">31576</span>,<span class="number">31576</span>,<span class="number">9055</span>,<span class="number">9055</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">com<span class="selector-class">.tencent</span><span class="selector-class">.android</span>.qqdownloader/u0a164,PowerManagerService,android<span class="selector-class">.os</span><span class="selector-class">.Handler</span>,<span class="number">0</span>x2,false,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1360</span>,<span class="number">1360</span>,<span class="number">98</span>,<span class="number">98</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>如上，当CPU时间、消息处理时间、消息延迟时间等出现异常数值时，即可通过对应的线程、消息来确定耗时的消息、执行缓慢的流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在Android性能监控和优化领域，一个会影响App性能表现的因素与Handler Message Looper机制有关。当Looper里面</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LutFilter：3D LUT简介与应用</title>
    <link href="https://nasdaqgodzilla.github.io/2023/04/24/LutFilter%EF%BC%9A3D-LUT%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://nasdaqgodzilla.github.io/2023/04/24/LutFilter%EF%BC%9A3D-LUT%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2023-04-24T08:13:00.000Z</published>
    <updated>2023-04-24T08:15:12.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LUT是“Look-Up-Table”——查找表的缩写。它是数据的一种容器，类似字典、map等，将索引与值对应起来的一种描述方式。</p><p>3D LUT，顾名思义，描述索引与值之间的对应方式是三维的，可以被理解为三个维度的索引-值对应方式的结合，通过三个维度的索引，可以查找到一个值。与一本普通的字典一样，输入固定的值作为索引，可以查到固定的结果作为输出。</p><p>3D LUT被广泛地在电影工业和显示工业广泛使用，用于在不同的显示器、不同的颜色空间之间做色彩校正、显示调节、效果和优化等方面。也就是说，3D LUT实际上是颜色的转换，是RGB的映射。借助3D LUT的颜色映射，将颜色进行调节，达成3D LUT即定的显示效果。</p><p>1D LUT只能控制gamma值、RGB平衡（灰阶）和白场（white point），而3D LUT能以全立体色彩空间的控制方式影响色相、饱和度、亮度等。简单描述来说3D LUT可以影响到颜色，而1D LUT只能影响亮度值。</p><p>由于颜色空间、gamma、色域等会影响颜色的呈现效果，因此想要让LUT有较好的效果，一般要求输入的颜色和输出的颜色在同一个显示环境下（颜色空间、色域、伽马一致）。</p><p>得益于颜色映射，富有创意的艺术家们能调出效果绝伦的LUT，通常会用于显示效果调节、色彩管理、美颜P图、显示器校正等方面，有很大的实用价值。</p><ul><li>技术型LUT：用于颜色转换，校准显示器，显示补偿，硬件矫正，色彩管理，色彩过滤，失真弥补，硬件偏色改善</li><li>创意型LUT（风格LUT）：用于显示风格的转换、美化、调色、多图合成（图像叠加）</li></ul><h1 id="直观了解3D-LUT"><a href="#直观了解3D-LUT" class="headerlink" title="直观了解3D LUT"></a>直观了解3D LUT</h1><p>先来看看LUT能达到的效果，看上去就是平平无奇的滤镜。</p><p>下图为两位特邀模特的演示图，图的右半部分分别应用了一个黑白化、鲜艳化的3D LUT：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LutFilter%E6%A1%88%E4%BE%8BW%E6%88%AA%E5%9B%BE.png"></p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%94.png"></p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%942.png"></p><p>一个调整对比度的案例：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%94_%E5%AF%B9%E6%AF%94%E5%BA%A6%E8%B0%83%E8%8A%82.png"></p><p>一个调整对比度+明度的案例：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%94_%E5%AF%B9%E6%AF%94%E5%BA%A6+%E6%98%8E%E5%BA%A6%E8%B0%83%E8%8A%82.png"></p><h1 id="3D-LUT的基本结构和表示方法"><a href="#3D-LUT的基本结构和表示方法" class="headerlink" title="3D LUT的基本结构和表示方法"></a>3D LUT的基本结构和表示方法</h1><p>3D LUT是一种统称，表示RGB三个维度的颜色映射规则表，有很多种文件格式，包括文本类型的cube，图片类型的png等。</p><p>立体地来理解3D LUT，就像一个有X、Y、Z三轴的三维坐标系，分别是RGB三个分量：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/3DLUT%E7%AB%8B%E4%BD%93%E5%9B%BE.png"></p><p>颜色的查找实际上就是将RGB当作XYZ，在表中查找得到映射后的RGB值：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>如前述，3D LUT有不同的文件格式，不同的文件格式有不同的使用方式和性能表现，在工业界平台的技术栈和性能要求，对3D LUT的文件格式的选型有决定性的影响。<br>实际应用时，3D LUT往往使用cube格式，其便利性、性能表现有明显优势，下文会简单介绍，其结构如下。</p><p>将LUT按立方体进行面分割并平铺每一个面，如下。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>cube格式的核心思想是，将三维维度转换为二维维度。将R与G分量组成小的二维坐标系（小方片），整个cube有N个小方片，每个小方片内部B分量固定，小方片B分量互相之间自然增长。<br>通俗来说，每一个小方格子里面的内部横坐标是红色，纵坐标是绿色。蓝色是固定不变的，只会随着小方片的序号的增长而增长。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.png"></p><p>左上角一点蓝色都没有，所以很红很绿；右下角蓝色很多，看上去很蓝。<br>3D LUT按照面划分就是16x16x16，32x32x32，64x64x64，256x256x256……，我们知道面由线段围成，而一根线段有两个端点，因此一个3D LUT按照端点来计算深度，那么就有17x17x17，33x33x33，65x65x65，257x257x257的表示方法。</p><p>上图的cube是一个64x64x64的3D LUT。我们知道RGB颜色空间取值有256个（0~255），因此64x64x64的3D LUT实际上是不能表示所有颜色的。</p><p>因此它有如下特点：</p><ul><li>每个输入的RGB，如果不是刚好落到整数点上，此时换算不那么直接（比如输入的R分量刚好是点1和点2中间的位置，此时到底用点1还是点2，还是点1和点2的平均值，还是插值计算）来映射</li><li>换算不那么直接，意味着有一定的精度差异，低精度误差大，高精度消耗内存、消耗LUT文件解析时间（256<em>256</em>256的cube大约占据48M左右的空间）</li><li>不论LUT层数是否足够高，都会碰见需要插值或降低采样的场景</li><li>人眼分辨能力、颜色学、内容颜色精度、显示器屏幕质素等因素客观上决定了，颜色的轻微偏差不会被察觉，不会对显示效果造成影响</li></ul><p>下图为256层的LUT：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE256%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>还有一种竖直排列各层的形式（这里将它做了旋转，变成横向排列。按照B分量的方向来看，它是竖向排列的）：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%AB%96%E7%9B%B41.png"></p><p>通过图片来存储的3D LUT，有个很突出的特点，就是图片本身的外观就是3D LUT提供的调色风格，如上面一个LUT的风格看上去是让图片更加鲜艳，而如下这个LUT则看上去让图片变的带有棕褐色色调：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%AB%96%E7%9B%B42.png"></p><p>这个则一眼能看出来可以抹掉色彩，让图片变成黑白图。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%AB%96%E7%9B%B43.png"></p><h1 id="3D-LUT的优势"><a href="#3D-LUT的优势" class="headerlink" title="3D LUT的优势"></a>3D LUT的优势</h1><p>3D LUT具有一些突出的特性和优势。</p><ul><li>性能</li></ul><p>3D LUT本身是查找表，将本该经过计算得到的映射结果预先存储下来，用于直接读取，避免了对像素点的映射计算。是一种空间换时间的算法，有高响应速度的保证。</p><ul><li>灵活程度大，带来更好的效果</li></ul><p>常规的滤镜是单一映射，通常会将整个图像的所有像素机械地进行映射。如一个暖色调的普通滤镜会让图像内原本已经很暖的颜色变的更暖，甚至失真。而3D LUT则可以实现控制，不同像素值会有不同的非线性的映射效果。</p><ul><li>支持硬件加速</li></ul><p>高响应速度的图像处理通常需要GPU或FPGA进行加速。3D LUT可以加载为纹理，通过OpenGL进行绘图</p><ul><li>风格和效果的自定义自由度大、简单</li></ul><p>LUT文件的制作比较简单，风格和效果可以由富有创意的艺术家们随心所欲地随时创建</p><ul><li>用户自定义自由度大</li></ul><p>用户可以随时下载或制作符合规范的LUT，在不修改软件的前提下，任意地设置LUT，实现不同的效果</p><ul><li>兼容性高</li></ul><p>3D LUT实现的调色可以在任意没有接入调色功能的应用（如系统应用、三方应用、浏览器、视频流、相机流），无感、无侵入的实现调色，被调色的目标不会出现任何兼容性问题，也没有任何侵入性，跨平台的移植性也很高</p><ul><li>LUT的基本使用</li></ul><p>LUT的基本应用流程主要为创建LUT、导入LUT、根据LUT映射新的像素值并绘制三大流程。其中对于Android平台，流程的重点难点在于绘制过程，通常借助OpenGL在GPU进行绘制。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/OpenGL%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png"></p><p>OpenGL绘图的基本流程如上。使用3D LUT进行调色，可以实现为在片段着色器中读取原图像素的颜色值，根据LUT映射为新的颜色值，实现绘图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;LUT是“Look-Up-Table”——查找表的缩写。它是数据的一种容器，类似字典、map等，将索引与值对应起来的一种描述方式。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Graphics" scheme="https://nasdaqgodzilla.github.io/categories/Graphics/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Graphics" scheme="https://nasdaqgodzilla.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：getResources()与Binder交火导致的界面卡顿优化</title>
    <link href="https://nasdaqgodzilla.github.io/2023/02/10/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9AgetResources-%E4%B8%8EBinder%E4%BA%A4%E7%81%AB%E5%AF%BC%E8%87%B4%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/"/>
    <id>https://nasdaqgodzilla.github.io/2023/02/10/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9AgetResources-%E4%B8%8EBinder%E4%BA%A4%E7%81%AB%E5%AF%BC%E8%87%B4%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</id>
    <published>2023-02-10T08:51:13.000Z</published>
    <updated>2023-02-10T08:52:05.042Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E8%A7%82%E6%B5%8B">观测</a><ul><li><a href="#1-trace%E4%BD%93%E7%8E%B0ui%E7%BB%98%E5%88%B6%E6%93%8D%E4%BD%9C%E4%B8%A5%E9%87%8D%E8%80%97%E6%97%B6">1. trace体现UI绘制操作严重耗时</a></li><li><a href="#2-%E6%8E%92%E6%9F%A5measure%E5%92%8Clayout%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A%E5%8F%AF%E7%96%91%E7%9A%84%E5%A4%9A%E6%AC%A1binder">2. 排查measure和layout慢的原因：可疑的多次binder</a></li><li><a href="#3-binder%EF%BC%9A%E5%9C%A8%E5%93%AA%E3%80%81%E8%B0%81%E4%B8%BA%E3%80%81%E4%B8%BA%E4%BD%95%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8">3. binder：在哪、谁为、为何频繁调用</a></li><li><a href="#4-binder%EF%BC%9A%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9A%E4%BD%8D">4. binder：频繁调用的具体定位</a></li></ul></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li><li><a href="#%E6%96%B9%E6%A1%88">方案</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某轮测试发现，我们的设备运行一个第三方的App时，卡顿感非常明显：</p><ul><li>界面加载很慢，菊花转半天</li><li>滑屏极度不跟手，目测观感帧率低于15</li><li>对比机（竞品）也会稍微一点卡，但是好很多，基本不会有很大感觉的卡顿</li></ul><p>可以初步判定我们的设备存在性能问题，亟需优化，拉平到竞品水准。</p><p>最后发现，这个问题实际上是应用自身奇怪的实现（getResources()的重载），加上Binder过度调用（沉重的Binder耗时）导致的。</p><p>本文做记录和分享。</p><p>其中对比机配置、Android版本均与本机不同，不做变量参考。</p><h1 id="观测"><a href="#观测" class="headerlink" title="观测"></a>观测</h1><p>由于这个可爱的App是第三方的App（应用市场下载的），我们没有源码，只能从系统端去干涉。先抓一份trace。</p><h2 id="1-trace体现UI绘制操作严重耗时"><a href="#1-trace体现UI绘制操作严重耗时" class="headerlink" title="1. trace体现UI绘制操作严重耗时"></a>1. trace体现UI绘制操作严重耗时</h2><p>trace一抓一看，显然App主线程已经陷入困境。可以看到：</p><ol><li>CPU使用率并不高</li><li>主线程几乎完全在执行Traversal工作（mersure和layout）</li><li>measure和layout极度耗时，显然达不到合理的帧率要求（甚至连PPT帧率都赶不上）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/binder.png" alt="主线程挤满了traversal工作"></p><p>可以看到，这份trace表明App的整个measure和layout工作存在整体性的不合理耗时。但并不能准确提示细节，也不能看出问题部分。可以肯定，耗时工作位于App层（不是指耗时原因也来自App）。</p><h2 id="2-排查measure和layout慢的原因：可疑的多次binder"><a href="#2-排查measure和layout慢的原因：可疑的多次binder" class="headerlink" title="2. 排查measure和layout慢的原因：可疑的多次binder"></a>2. 排查measure和layout慢的原因：可疑的多次binder</h2><p>上面可以确认绘制缓慢造成耗时。但是一来App不是自己的，二来这么复杂的调用，通过分析调用、跟代码来定位慢方法、慢路径显然足够低效。</p><p>定位到Traversal，统计一下Traversal各部分的耗时占比，可以大致定位出耗时部分可能是什么业务的：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/traversal%E8%BF%87%E7%A8%8B%E6%9C%89%E5%A4%A7%E9%87%8Fbinder%E8%B0%83%E7%94%A8%E5%8D%A0%E6%8D%AE%E5%A4%A7%E9%87%8F%E8%80%97%E6%97%B6.png" alt="traversal过程有大量binder调用"></p><p>可以看到，traversal意外地包含了数量巨大的binder调用，它占据总耗时的80%+，使得应用层绘图超出生命线10倍以上：</p><ol><li>这次doFrame-&gt;travesal耗时接近200ms，属于”无法使用的垃圾”级别，不是性能问题而是故障</li><li>binder调用（binder transaction）次数很多，在几毫秒的时间里（预期的一次应用层绘图时间）进行了194次IPC</li><li>binder耗时占比很高：83%左右</li><li>还有一个ioctl调用次数也很多、很耗时；由于binder驱动调用talkWithDriver()需要使用ioctl，因此这里初步判断ioctl是binder IPC的伴生，无碍</li></ol><blockquote><p>生命线：对于60Hz的屏幕，生命线为16ms左右。但是16ms为图形栈全链路的极限时间，留给应用层的时间更低</p></blockquote><p>可以确认，过多的binder调用导致了这个恼火的性能问题。</p><h2 id="3-binder：在哪、谁为、为何频繁调用"><a href="#3-binder：在哪、谁为、为何频繁调用" class="headerlink" title="3. binder：在哪、谁为、为何频繁调用"></a>3. binder：在哪、谁为、为何频繁调用</h2><p>通常应用（和应用集成的库），出于一定的目的，会通过IBinder、AIDL、封装组件（如startService）、直接调用驱动节点（talkWithDriver）等方式来进行一次Binder IPC。</p><p>性能问题中，与Binder IPC相关的，最常见的主要如下：</p><ol><li>频繁调用Binder</li><li>关键、敏感、紧张的位置调用Binder</li><li>Binder对端响应太慢，对端繁忙</li><li>Binder传递的数据太大</li><li>Binder客户端线程数超限（发起请求的线程满）</li><li>Binder服务端线程数超限（处理请求的线程满）</li></ol><p>对于Binder传递数据太大、线程数导致的性能问题，由于应用不是自己的（不好干涉、不关注），且对比机卡顿不那么明显（可以粗略排除），因此不太值得去看。（另外我们是在滑屏的时候卡的，主线程UIHandler也做不到并发发出Binder IPC）</p><p>这里还是展示一下怎么分析。下列命令可以提供一些关于binder状态、traction状态、传递数据大小等内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>binder/failed_transaction_log</span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>binder/transaction_log</span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>binder/transactions</span><br></pre></td></tr></table></figure><p>同样的，我们不好关注应用为何调用binder（因为没有App的代码，最近也忙的不想逆向它；但实际上最后我们知道了为何调用），也很显然是在哪调用的（在App UI线程 performTraversal时调用的），因此先来看看这群IPC的对端是谁。</p><p>trace一看，binder调用确实很多（画蓝紫色线部分都是binder；本是细线，溢满则刚）：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%E8%BF%87%E5%A4%9A%E7%9A%84binder.png"></p><p>上图binder调用很多，其实很多是同一种类，各IPC都最终归属于一类Binder。分类看，数量巨大、占比最高的两类binder（称为第一部分binder和第二部分binder）是值得探讨的主要耗时部分。</p><p>首先，分析第一部分binder的对端。跟踪发现第一部分binder“飞”往SurafceFlinger，耗时较短，次数合理，评估正常，不再跟进，不贴图展示。</p><p>第二部分binder，从次数、耗时来看，确实可疑。它从App进程“飞”往System_server（Framework服务层）：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86binder%E5%90%8E%E9%9D%A2%E8%BF%98%E8%B7%9F%E7%9D%80%E5%87%A0%E4%B8%AAbinder_%E6%97%B6%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%90%88%E5%B9%B3%E5%9D%87binder%E8%80%97%E6%97%B6.png"></p><h2 id="4-binder：频繁调用的具体定位"><a href="#4-binder：频繁调用的具体定位" class="headerlink" title="4. binder：频繁调用的具体定位"></a>4. binder：频繁调用的具体定位</h2><p>性能分析的其中一个关键方向是找到慢方法、慢路径。上面一步已经体现了，慢是因为App在敏感且关键的位置调用了Binder，这个binder的对端是Framework。</p><p>从系统侧分析这个binder的性能，难以像App那样轻松定位——因为App里面有多少个调用、系统里面暴露了多少个binder，在哪里触发的，都不好搞。</p><p>因此直接来粗暴的方法，把所有binder调用抓堆栈下来。</p><p>多次复现、多次抓取，阅读堆栈、总结分类，可以抓到蛛丝马迹。由于最长的堆栈高达33万行（包含合理的正常的binder和造成性能问题的binder），且抓了好几份，这里只能将问题的关键点做个展示输出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="number">20230209</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span>  binder.<span class="number">20230209.2</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209.4</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230210.1</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span></span><br><span class="line"><span class="number">20230209</span><span class="selector-class">.ok</span><span class="selector-class">.trace</span>  binder.<span class="number">20230209.3</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209.5</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209</span><span class="selector-class">.ok</span><span class="selector-class">.trace</span>.log</span><br></pre></td></tr></table></figure><blockquote><p>fk表示fuck，即不正常情况下的binder堆栈；ok表示正常。</p></blockquote><p>其中性能故障对应的堆栈如下（几类有性能问题的binder调用；仅截取关键位置）：</p><p>第一个堆栈放全一些，可以看出，在正常的traversal过程中，View体系正常调用getResources()，binder发生在getResources()内部：它调用了IWindowManager.getInitialDisplayDensity()，通过binder“飞”到system_server：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">15</span></span><br><span class="line">Trace: java<span class="selector-class">.lang</span><span class="selector-class">.Throwable</span></span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span><span class="selector-class">.transact</span>(BinderProxy<span class="selector-class">.java</span>:<span class="number">547</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.IWindowManager<span class="variable">$Stub</span><span class="variable">$Proxy</span><span class="selector-class">.getInitialDisplayDensity</span>(IWindowManager<span class="selector-class">.java</span>:<span class="number">3025</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.e5</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.getResources</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at androidx<span class="selector-class">.appcompat</span><span class="selector-class">.widget</span><span class="selector-class">.ContentFrameLayout</span><span class="selector-class">.onMeasure</span>(ContentFrameLayout<span class="selector-class">.java</span>:<span class="number">1</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureChildBeforeLayout</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1632</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureVertical</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">922</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">801</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">331</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureChildBeforeLayout</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1632</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureVertical</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">922</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">801</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">331</span>)</span><br><span class="line">at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.policy</span><span class="selector-class">.DecorView</span><span class="selector-class">.onMeasure</span>(DecorView<span class="selector-class">.java</span>:<span class="number">763</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.performMeasure</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">3665</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.measureHierarchy</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">2302</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.performTraversals</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">2564</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.doTraversal</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">2026</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.ViewRootImpl<span class="variable">$TraversalRunnable</span><span class="selector-class">.run</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">8469</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.Choreographer<span class="variable">$CallbackRecord</span><span class="selector-class">.run</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">972</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.Choreographer</span><span class="selector-class">.doCallbacks</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">796</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.Choreographer</span><span class="selector-class">.doFrame</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">731</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.Choreographer<span class="variable">$FrameDisplayEventReceiver</span><span class="selector-class">.run</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">957</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span><span class="selector-class">.handleCallback</span>(Handler<span class="selector-class">.java</span>:<span class="number">938</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span><span class="selector-class">.dispatchMessage</span>(Handler<span class="selector-class">.java</span>:<span class="number">99</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.Looper</span><span class="selector-class">.loop</span>(Looper<span class="selector-class">.java</span>:<span class="number">223</span>)</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.main</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">8024</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span>.RuntimeInit<span class="variable">$MethodAndArgsCaller</span><span class="selector-class">.run</span>(RuntimeInit<span class="selector-class">.java</span>:<span class="number">605</span>)</span><br><span class="line">at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span><span class="selector-class">.ZygoteInit</span><span class="selector-class">.main</span>(ZygoteInit<span class="selector-class">.java</span>:<span class="number">947</span>)</span><br></pre></td></tr></table></figure><p>其实这里已经能看出问题，并且看清问题的严重性了。可以说，tarversal阶段是一个App最紧张、最重要的阶段之一，在这个关键时间窗口内，还调用了binder通信这一不可靠的方法（IPC是不可预期的），对性能影响很大。</p><p>该应用的View实现喜欢在traversal阶段调用上述Binder，包括但不限于如下几个：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">5</span></span><br><span class="line">Trace: java<span class="selector-class">.lang</span><span class="selector-class">.Throwable</span></span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span><span class="selector-class">.transact</span>(BinderProxy<span class="selector-class">.java</span>:<span class="number">547</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.IWindowManager<span class="variable">$Stub</span><span class="variable">$Proxy</span><span class="selector-class">.getInitialDisplayDensity</span>(IWindowManager<span class="selector-class">.java</span>:<span class="number">3025</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.e5</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.getResources</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">221</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureChildBeforeLayout</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1632</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureVertical</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">922</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">801</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureHorizontal</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1463</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">803</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">20</span></span><br><span class="line">Trace: java<span class="selector-class">.lang</span><span class="selector-class">.Throwable</span></span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span><span class="selector-class">.transact</span>(BinderProxy<span class="selector-class">.java</span>:<span class="number">547</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.IWindowManager<span class="variable">$Stub</span><span class="variable">$Proxy</span><span class="selector-class">.getInitialDisplayDensity</span>(IWindowManager<span class="selector-class">.java</span>:<span class="number">3025</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.e5</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.getResources</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">762</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.RelativeLayout</span><span class="selector-class">.measureChild</span>(RelativeLayout<span class="selector-class">.java</span>:<span class="number">849</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.RelativeLayout</span><span class="selector-class">.onMeasure</span>(RelativeLayout<span class="selector-class">.java</span>:<span class="number">652</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">331</span>)</span><br><span class="line">at androidx<span class="selector-class">.appcompat</span><span class="selector-class">.widget</span><span class="selector-class">.ContentFrameLayout</span><span class="selector-class">.onMeasure</span>(ContentFrameLayout<span class="selector-class">.java</span>:<span class="number">21</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>到此，已经定位到了慢路径了：</p><ul><li>App喜欢在View的关键回调里面调用IPC，产生巨大的性能问题</li><li>在measure和traversal阶段不厌其烦地调用一个通常情况很少调用的接口getInitialDisplayDensity()</li><li>View的加载阶段、traversal阶段，在measure、layout阶段因Binder IPC过度频繁触发了性能问题</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>App在多个不同的View（及其子类ViewGroup和ViewGroup的子类们），在不合适的时机频繁调用了Binder，以很低的CPU占用，领先性地实现了很卡的效果。</p><p>虽然卡顿的贡献来自不同的View调用的同名Binder，这个binder却是同一个接口（不易变的getInitialDisplayDensity()，这意味着返回值可以被缓存下来并确保有效），而且触发的直接原因是同一个——App在Context.getResources()方法内部调用了这个binder，getResources()在App运行时会被频繁调用（尤其是View创建、绘制阶段）。</p><blockquote><p>Context.getResources()默认实现是直接返回mResources，但是会有可爱的人会override它（或通过优美的kotlin扩展函数），往里面塞入耗时的慢方法。</p></blockquote><p>清晰的定位到了慢方法、卡顿根因后，还有一个残酷的问题：对比机不卡。</p><p>回答这个问题感觉像是对自己写出来的卡顿型代码有点欲盖弥彰的感觉。不过经过分析，排除掉竞品的优化、App在竞品的Android版本（Android版本和我们不一样）上业务逻辑不同、竞品的系统原生逻辑就不一样（Android版本原生逻辑差异）这三个变量因素后，结合代码阅读，发现我们的View Tree在Measure和Layout阶段，我们自己添加的功能会比原生要调用更多次的getResources()方法。</p><p>这在大多数情况下非常正常（逻辑上也正常，因为这个方法只有一行直接返回Resources对象实例的代码），碰到一个在超高频方法里面加慢调用、不可靠IPC的App后只能傻眼认栽。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>从App角度看，它错的很离谱。优化方案也很简单，去掉一个多余的、过度的Binder调用，一般是将调用集中在关键位置（临界区）以外、缓存返回值（确保返回值没有失效的前提下重用cache）、不在高频方法里面加东西、尽量不override sdk方法等等。</p><p>在系统侧，本着拉平甚至超越竞品的愿景，同样有减少binder调用的优化目标。不论是对应用自身问题的解决，还是对竞品的竞争性跟进，无所谓，都出手。主要有如下一些方案：</p><ol><li>Framework可以实现缓存，在Binder IPC发出前检查有效性，仅在失效后真正发出IPC</li><li>把我们加进去的额外的getResources()去掉、重构</li><li>在严酷的竞争、高标准的要求下，会将考虑一些非标准的操作（魔改）</li></ol><blockquote><p>有效性，是指IPC对端返回的内容没有发生改变（本质上是软件维护的状态并未发生改变）。比如，从未旋转过屏幕，那么我们上一次获取的屏幕宽高就仍然有效，不需要再次获取，而应复用缓存</p></blockquote><p>最终方案2采用并取得良好效果：帧率提升几倍、跟手了，还有一点卡卡的（App自己的+原生的getResources()调用），达到和竞品一致的水准了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ContextImpl.java?q=ContextImpl.getResources">Context.getResources()源码参考</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A7%82%E6%B5%8B&quot;&gt;观测&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-trace%E4%BD%93%E7%8E%B0ui%E7</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 13 WindowContainer窗口模型详解</title>
    <link href="https://nasdaqgodzilla.github.io/2023/01/25/Android-13-WindowContainer%E7%AA%97%E5%8F%A3%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nasdaqgodzilla.github.io/2023/01/25/Android-13-WindowContainer%E7%AA%97%E5%8F%A3%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-01-25T12:29:37.000Z</published>
    <updated>2023-03-08T09:33:04.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android 13后窗口模型系列架构存在较大变更，本文围绕WindowContainer总结窗口模型。</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><!--```@startumlclass ConfigurationContainer {}class WindowContainer {}class RootWindowContainer {    - child :DisplayContent}class WindowProcessController {    - parent :RootWindowContainer}class WindowToken {    - child :WindowState}class TaskFragment {    - child :ActivityRecord    - parent :DisplayArea}class Task {    - child :ActivityRecord    - parent :DisplayArea}class DisplayArea {    - child :Task // Or DisplayArea}class DisplayArea::Token {    - child :WindowToken}class DisplayArea::Dimmable {    - child :DisplayArea}class TaskDisplayArea {    - child :Task // Or TaskDisplayArea}class ActivityRecord {    - child :WindowState    - parent :TaskFragment}class WindowState {    - child :WindowState    - parent :ActivityRecord}class RootDisplayArea {}class DisplayContent {    // 由DisplayContent作为窗口架构的根节点    mTokenMap :Map<WindowToken>}class DisplayAreaGroup {}ConfigurationContainer <|-- WindowContainerConfigurationContainer <|-- WindowProcessControllerWindowContainer <|-- WindowTokenWindowContainer <|-- WindowStateWindowContainer <|-- TaskFragmentWindowContainer <|-- DisplayAreaWindowContainer <|-- RootWindowContainerTaskFragment <|-- TaskWindowToken <|-- ActivityRecordDisplayArea <|-- TaskDisplayAreaDisplayArea <|-- DisplayArea.TokenDisplayArea <|-- DisplayArea.DimmableDisplayArea.Dimmable <|-- RootDisplayAreaRootDisplayArea <|-- DisplayContentRootDisplayArea <|-- DisplayAreaGroup@enduml```--><p><img src="//www.plantuml.com/plantuml/png/fLJFIlj04BxFK-mBzDTxA3zQ53s9KWkUrsIjIpVPiDaeHNifFNdn8WWYHV3cpOjOmRUfZOzXcbOodMx_W3a4ClFDDt--cTGJourDGmM-uad2TdHq9jkfuLRgAF-mN4R2i2k07imX9p8AzANRrzJQBljP_bIOVovLmBnTcSIATwT-4LbAUsIqBv9awZLQAHGUSvFZcUT8GKbQkYCYcdVcEhRSYXBVuabdp_1sc5FJW8PlvOMqtQRmjGb85VCk6aRmHRQ_io0Z9IiILAliqB1DePxdd08Qa3iihoaC-QaID79bnrlLIv28Od50QrGZiyFIbMm8lpKLrQW7U9rnUtZLqHwNovFtcjszBhh6du_Zzu_ivVxhzdaoV9iC1zd3OF8q-hxfP_rH4HOMWXpmc7dvguP4-kzKQT_eD9vNi-9YQzUL2ZtLZLZ7_G7C70IDIdG2i11k0DRFYS0Dkm6kNm5WtZ8J0AfuPYQg0qfNnY7ZCW0P_XN4wo6_bmNWifOjuPn030MAx9uRGzS5wY8Aqb3z0000" alt="Android13窗口模型类图"></p><h1 id="窗口模型架构解析"><a href="#窗口模型架构解析" class="headerlink" title="窗口模型架构解析"></a>窗口模型架构解析</h1><p>新的窗口从WMS.addWindow()开始。首先根据DisplayId取得或创建对应的DisplayContent，然后创建WindowToken、WindowState，建立InputChannel，最后调用DisplayContent.sendNewConfiguration()。然后调用DisplayContent.updateOrientation()和sendNewConfiguration()来更新方向和conf。SurfaceControl由WindowToken管理。</p><h1 id="DisplayContent-sendNewConfiguration"><a href="#DisplayContent-sendNewConfiguration" class="headerlink" title="DisplayContent.sendNewConfiguration()"></a>DisplayContent.sendNewConfiguration()</h1><p>如果addWindow()后方向发生改变，会触发对应Display的Conf更新。</p><p>根据Rotation和DisplayInfo，计算当前屏幕宽高、方向，组装Configuration和WindowConfiguration，将新的Configuraion通过DisplayContent.updateDisplayOverrideConfigurationLocked()更新下去（这个过程还在整个体系中确认Conf是否真的发生了update，如果发生了更新，最后才会设置DisplayContent.mLayoutNeeded）。</p><h2 id="DisplayContent-updateDisplayOverrideConfigurationLocked"><a href="#DisplayContent-updateDisplayOverrideConfigurationLocked" class="headerlink" title="DisplayContent.updateDisplayOverrideConfigurationLocked()"></a>DisplayContent.updateDisplayOverrideConfigurationLocked()</h2><p>更新当前Display对应的conf。对于Default Display更新Global Conf，否则更新override conf。</p><p>对于DEFAULT_DISPLAY，实际上不是仅更新Override Conf，而是直接更新Global Conf（过程中同步更新了Override Conf）:ActivityTaskManagerService.updateGlobalConfigurationLocked()。</p><h3 id="ActivityTaskManagerService-updateGlobalConfigurationLocked"><a href="#ActivityTaskManagerService-updateGlobalConfigurationLocked" class="headerlink" title="ActivityTaskManagerService.updateGlobalConfigurationLocked()"></a>ActivityTaskManagerService.updateGlobalConfigurationLocked()</h3><p>该方法实际上首先更新system_server，然后更新所有App，接着发出Global Conf Changed的广播，最后更新RootWindowContainer。</p><p>首先将system_server所在的进程更新到新的Configuration（通过ActivityThread.applyConfigurationToResources()）。</p><h4 id="WindowProcessController-onConfigurationChanged"><a href="#WindowProcessController-onConfigurationChanged" class="headerlink" title="WindowProcessController.onConfigurationChanged()"></a>WindowProcessController.onConfigurationChanged()</h4><p>然后将新的Global Conf发给系统中所有应用进程：遍历ActivityTaskManagerService.mProcessMap，取得所有pid和对应的WindowProcessController。调用每个WindowProcessController.onConfigurationChanged()，内部使用ConfigurationChangeItem这个Binder，实现将Configuration changed发给Activity，触发Activity资源更新、回调Activity.onConfigurationChanged()。</p><h4 id="广播ACTION-CONFIGURATION-CHANGED"><a href="#广播ACTION-CONFIGURATION-CHANGED" class="headerlink" title="广播ACTION_CONFIGURATION_CHANGED"></a>广播ACTION_CONFIGURATION_CHANGED</h4><p>接着，App Conf更新完成后，调度发出广播ACTION_CONFIGURATION_CHANGED：ActivityTaskManagerService向自己的Handler发送Message，回调broadcastGlobalConfigurationChanged()，发出广播。对于App而言，可以动态监听该广播（在Manifest静态注册无效）。</p><h4 id="RootWindowContainer-onConfigurationChanged"><a href="#RootWindowContainer-onConfigurationChanged" class="headerlink" title="RootWindowContainer.onConfigurationChanged()"></a>RootWindowContainer.onConfigurationChanged()</h4><p>该方法更新系统中WindowContainer树，更新所有节点的Conf，包括ActivityRecord，实现应用新的Configuration。</p><h3 id="ActivityTaskManagerService-ensureConfigAndVisibilityAfterUpdate"><a href="#ActivityTaskManagerService-ensureConfigAndVisibilityAfterUpdate" class="headerlink" title="ActivityTaskManagerService.ensureConfigAndVisibilityAfterUpdate()"></a>ActivityTaskManagerService.ensureConfigAndVisibilityAfterUpdate()</h3><p>上一步updateGlobalConfigrautionLocked()后，紧接着调用ensureConfigAndVisibilityAfterUpdate()。该方法实际上调用top ActivityRecord.ensureActivityConfiguration()，用于应用最新的Conf。</p><p>该步骤的目的是确定Activity是否需要更新到新的Conf（即判断新旧Conf是否一致）并进行更新，然后根据Activity注册的ConfigChanges属性，判断是否需要重启Activity还是回调对应方法。</p><p>此时ActivityRecord的Conf可能已经在上一步updateGlobalConfigurationLocked()发生变化了。</p><p>判断Config不变，直接调用scheduleConfigurationChanged()并返回。</p><p>判断Config有变（shouldRelaunchLocked()），可能提前返回&#x2F;relaunchActivityLocked重启Activity，然后调用scheduleConfigurationChanged()。</p><h4 id="ActivityRecord-scheduleConfigurationChanged"><a href="#ActivityRecord-scheduleConfigurationChanged" class="headerlink" title="ActivityRecord.scheduleConfigurationChanged()"></a>ActivityRecord.scheduleConfigurationChanged()</h4><p>通过Binder ActivityConfigurationChangeItem回调Activity.onConfigurationChanged()。</p><p>这里Binder是ActivityConfigurationChangeItem，而WindowProcessController是ConfigurationChangeItem。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>新的窗口添加或者切换后，如果方向发生变化，会更新Global Conf，并通过WindowProcessController触发回调所有App。在发出广播后，以RootWindowContainer为起点更新各个WindowContainer，最后将顶层Activity的conf再次更新，并触发一次新的绘制。</p><h1 id="App"><a href="#App" class="headerlink" title="App"></a>App</h1><p>App会在WindowProcessController处通过ConfigurationChangeItem回调一次，在ActivityRecord处通过ActivityConfigurationChangeItem回调一次。</p><h2 id="ConfigurationChangeItem"><a href="#ConfigurationChangeItem" class="headerlink" title="ConfigurationChangeItem"></a>ConfigurationChangeItem</h2><p>回调ActivityThread.handleConfigurationChanged()：调用ConfigurationContainer.handleConfigurationChanged()，更新Resources，通过performConfigurationChanged()回调App内已有的各个onConfigurationChanged()回调。</p><h2 id="ActivityConfigurationChangeItem"><a href="#ActivityConfigurationChangeItem" class="headerlink" title="ActivityConfigurationChangeItem"></a>ActivityConfigurationChangeItem</h2><p>回调ActivityThread.handleActivityConfigurationChanged：调用performConfigurationChangedForActivity()-&gt;performActivityConfigurationChanged()：如果Conf的窗口模式变化时触发对应回调；判断当Conf和Resources有public域发生变化时，调用ResourcesManager.updateResourcesForActivity()更新Resources，回调Activity.onConfigurationChanged()。</p><p>然后，调用ViewRootImpl.updateConfiguration()。</p><h3 id="ViewRootImpl-updateConfiguration"><a href="#ViewRootImpl-updateConfiguration" class="headerlink" title="ViewRootImpl.updateConfiguration()"></a>ViewRootImpl.updateConfiguration()</h3><p>调用mView.dispatchConfigurationChanged()，从DecorView开始回调各View的onConfigurationChanged()。</p><p>最后，调用requestLayout()：向ChoreoGrapher注册回调，在下一次屏幕刷新中回调performTraversals()。该方法开始按照新的Configuration执行绘制工作（新的Configuration在上一步即ResourcesManager.updateResources()中更新了，ViewRootImpl.performTraversal()也是使用这个Resources.getConfiguration()来绘制的）。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>ActivityThread在Global Conf对应的从WindowProcessController的回调中，会将新的Configuration通过ConfigurationController进行更新，并回调各个onConfigurationChanged()。</p><p>窗口体系Configuration更新完成后，通过ActivityRecord会再次更新顶层Activity，此时更新的override conf可能和Global Conf并不一致。接着触发一次View Tree的重新绘制，按照新的Conf来显示应用画面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Android 13后窗口模型系列架构存在较大变更，本文围绕WindowContainer总结窗口模型。&lt;/p&gt;
&lt;h1 id=&quot;类图&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android单条日志太长导致被截断的问题分析和解决</title>
    <link href="https://nasdaqgodzilla.github.io/2022/12/28/Android%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E8%A2%AB%E6%88%AA%E6%96%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <id>https://nasdaqgodzilla.github.io/2022/12/28/Android%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E8%A2%AB%E6%88%AA%E6%96%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/</id>
    <published>2022-12-28T01:45:16.000Z</published>
    <updated>2022-12-28T01:47:57.411Z</updated>
    
    <content type="html"><![CDATA[<hr><p>9:20 AM<br>Wednesday, December 28, 2022 (GMT+8)<br>Time in Guangzhou, Guangdong Province, China</p><hr><p>[toc]</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通常在Android中使用<code>logcat</code>输出查阅日志，但有时日志很长，可能会被截断，显示不完整。</p><blockquote><p>注意，这里指的是单条日志太长了被截断了，不是指日志太多了被冲掉了</p></blockquote><p>本文研究日志被截断的原因，并给出修改方法。</p><p>首先日志被截断的原因有如下几种，其中第一种是首要原因：</p><ol><li>单条日志长度上限，日志如果太长，触及上限则会被截断</li><li>日志如果涉及序列化、binder传输，则受到binder传输上限的限制</li><li>底层（Linux、log设备）限制、系统调用限制</li></ol><p>注意，单条日志长度上限是指一次打印的日志的长度，不是指设置-开发者选项-日志缓冲区大小。</p><h1 id="查看日志缓冲区大小、单条日志大小"><a href="#查看日志缓冲区大小、单条日志大小" class="headerlink" title="查看日志缓冲区大小、单条日志大小"></a>查看日志缓冲区大小、单条日志大小</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#:/ logcat -g</span><br><span class="line">main: ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">15</span> MiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br><span class="line"><span class="built_in">system</span>: ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">6</span> MiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br><span class="line">crash: ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">13</span> KiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br><span class="line">kerne<span class="variable">l:</span> ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">3</span> MiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br></pre></td></tr></table></figure><p>通过<code>logcat -g</code>指令可以读到各个分类的缓冲区上限、目前用量、每次读取量、单条日志长度的上限。</p><h1 id="调节日志缓冲区大小"><a href="#调节日志缓冲区大小" class="headerlink" title="调节日志缓冲区大小"></a>调节日志缓冲区大小</h1><ul><li>法1: 开发者模式-设置日志缓冲区大小</li><li>法2: 通过<code>logcat -G</code>即可设置，等同于法1</li></ul><h1 id="调节单条日志大小"><a href="#调节单条日志大小" class="headerlink" title="调节单条日志大小"></a>调节单条日志大小</h1><p>修改代码根目录下的<code>system/core/liblog/include/log/log_read.h</code>下的<code>LOGGER_ENTRY_MAX_PAYLOAD</code>和<code>LOGGER_ENTRY_MAX_LEN</code>。</p><p>修改后，需要重新编译如下三个模块: <code>liblog logd logcat</code>，推入设备，重启方能生效。(通过<code>logcat -g</code>可以验证修改)</p><p>不同Android版本在不同位置，<a href="https://cs.android.com/android/platform/superproject/+/master:system/logging/liblog/include/log/log_read.h;l=55?q=LOGGER_ENTRY_&sq=">比如这个</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;9:20 AM&lt;br&gt;Wednesday, December 28, 2022 (GMT+8)&lt;br&gt;Time in Guangzhou, Guangdong Province, China&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android三方应用UI自动化测试探索</title>
    <link href="https://nasdaqgodzilla.github.io/2022/11/07/Android%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8E%A2%E7%B4%A2/"/>
    <id>https://nasdaqgodzilla.github.io/2022/11/07/Android%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8E%A2%E7%B4%A2/</id>
    <published>2022-11-07T11:59:11.000Z</published>
    <updated>2022-11-07T12:00:38.558Z</updated>
    
    <content type="html"><![CDATA[<hr><p>3:49 pm<br>Thursday, 20 October 2022 (HKT)<br>Time in Hong Kong</p><hr><ul><li><a href="#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%BB%B7%E5%80%BC">三方应用UI自动化的价值</a><ul><li><a href="#%E4%B8%9A%E5%8A%A1%E7%97%9B%E7%82%B9">业务痛点</a></li></ul></li><li><a href="#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%BE%E9%A2%98%E5%92%8C%E9%9A%90%E6%82%A3">三方应用UI自动化的技术难题和隐患</a><ul><li><a href="#app-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E8%B7%B5">App UI自动化测试的一般实践</a></li><li><a href="#app-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF">App UI自动化的基础技术</a></li><li><a href="#%E4%B8%89%E6%96%B9app-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%BE%A7%E9%87%8D">三方App UI自动化的侧重</a></li></ul></li><li><a href="#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E9%80%89%E5%9E%8B">三方应用UI自动化的选型</a><ul><li><a href="#1-%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86">1. 自动遍历</a></li><li><a href="#2-%E5%9B%BE%E5%83%8F%E6%8A%80%E6%9C%AF">2. 图像技术</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li><li><a href="#%E5%8F%82%E8%80%83%E5%B7%A5%E5%85%B7">参考工具</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="三方应用UI自动化的价值"><a href="#三方应用UI自动化的价值" class="headerlink" title="三方应用UI自动化的价值"></a>三方应用UI自动化的价值</h1><p>从设备厂商的视角来看，Android App的UI实现方式错综复杂，采用的UI技术栈层出不穷，以及需要进行显示适配的新型场景（如平行世界、窗口模式、画中画、桌面模式和折叠屏）井喷式涌现。</p><p>大部分的三方应用测试通常仅关注UI功能、冒烟测试，测试流程枯燥、重复，且业界有成熟的UI自动化基础，因此通常在三方应用兼容性测试中接入一定程度的自动化测试。</p><p>在这个大背景下，相对于一方&#x2F;二方应用而言，数量庞大、纯黑盒、架构复杂多样的三方应用，主要<strong>在以下几个场景中存在几个痛点</strong>。</p><h2 id="业务痛点"><a href="#业务痛点" class="headerlink" title="业务痛点"></a>业务痛点</h2><h4 id="1-技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的"><a href="#1-技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的" class="headerlink" title="1. 技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的"></a>1. 技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的</h4><p>三方应用UI测试投入不小，但在没有直接经济效益的前提下又不得不投入。不论测试方法以手工进行、自动化测试、混合进行，对QA资源的消耗都是巨大且不受控的。</p><h4 id="2-效率显著低于一方应用"><a href="#2-效率显著低于一方应用" class="headerlink" title="2. 效率显著低于一方应用"></a>2. 效率显著低于一方应用</h4><p>高效的自动化要求QA<strong>掌握被测应用的业务、版本变更点</strong>，以及与QA配合的<strong>自动化测试友好的应用接口</strong>。</p><p>对于三方应用，业务的不透明决定了QA设计的case<strong>不能紧咬变更点</strong>，<strong>无法设计最符合业务逻辑的测试方案</strong>。</p><p>此外，被测三方应用可能<strong>没有自动化UI测试接口</strong>，或<strong>自动化测试接口本身就不易被非App自身人员使用</strong>。</p><blockquote><p>就算条件成立，也不可能对成百上千的应用都勤力投入，通常舍弃覆盖程度</p></blockquote><p>通常，高效的UI自动化测试会通过POA模型、Page Factory模型等，借助工业级的自动化框架和思想，由RD与QA配合，从设计-开发-测试形成闭环，产出可维可测性高的产品——但仅局限于一方应用之内，厂商和其他外部并不能从中受益，用起来自动测试。</p><blockquote><p>相当一部分应用并未设计自动化基建，即使是应用方自身都需要花费大量精力才能用起自动UI测试</p></blockquote><h4 id="3-测不到位或过度测试"><a href="#3-测不到位或过度测试" class="headerlink" title="3. 测不到位或过度测试"></a>3. 测不到位或过度测试</h4><p>三方应用并非自研，且属于纯黑盒，并在成本因素制约下，对三方应用的UI测试（包括UI自动化测试）<strong>追求高覆盖率是不现实的</strong>、不科学也不可能的，但是仍然尝试追求一定程度的覆盖。这个<strong>覆盖的程度难以衡量、覆盖率目标也难以估量制定</strong>，也不依靠分析和讨论得出。</p><p>三方应用在没有公开或共享其热点流程时，黑盒的UI测试（包括按照一定case进行的手工&#x2F;自动测试、Monkey测试）<strong>通常不能拦截全部的关键流程</strong>。</p><p>当然，也有过度测试或冗余测试的情况。</p><blockquote><p>总结来说就是测试覆盖目标、测试覆盖率、测到什么程度，是非曲直，难以论说</p></blockquote><h4 id="4-投入产出不理想"><a href="#4-投入产出不理想" class="headerlink" title="4. 投入产出不理想"></a>4. 投入产出不理想</h4><p>在三方应用UI自动化测试场景下，有时QA或RD完成一组自动化case的设计、编码、验证后，发现花费的时间是手工测试的10倍甚至更多。这一投入产出比若是常态，则显然不可接受。</p><p>在紧急情况下，有时手工测试一把梭哈更加可靠，甚至可能废弃掉团队积累的自动测试方法。</p><p>这一“轻舟已过万重山”的寓景还不是最严峻的挑战，当三方应用更新后，迫于三方应用实现的多样性、厂商侧的自主性等不可抗力，<strong>自动化脚本&#x2F;工具&#x2F;case可能会很遗憾地失效</strong>，失去其“Once write, run forever”的愿景。</p><blockquote><p>Martin Flower：“GUI测试用例还很脆弱，如对系统的一些修正可能导致很多用例的失败，这时候你需要重新录制。你可以放弃录制的方法来解决这个问题，通过写GUI测试代码，但是这样效率非常低。就算你已经很精通了GUI测试代码的编写，端到端的GUI测试用例也很容易出现不可预期结果的问题，因此，基于GUI的自动化测试是脆弱、耗时（包括用例维护和执行）的。GUI测试用例能覆盖到主业务流程即可。”</p></blockquote><h4 id="5-边际效益递减"><a href="#5-边际效益递减" class="headerlink" title="5. 边际效益递减"></a>5. 边际效益递减</h4><p>根据敏捷开发模型，也出于对三方应用UI测试的展望，随着<strong>UI自动化的加深，其收益是边际递减的</strong>。</p><blockquote><p>参考Mike Cohn，自动化金字塔模型</p></blockquote><p><img src="https://s1.ax1x.com/2022/10/20/xyzaQI.png" alt="UI边际效益递减.png"></p><p>事实上，三方应用UI测试的收益曲线更加复杂，它可能不是单调简单的，对三方应用UI测试投入地更多，最终综合效率和成果的收益可能不增长甚至反而下降。</p><h4 id="6-支撑自研应用商店"><a href="#6-支撑自研应用商店" class="headerlink" title="6. 支撑自研应用商店"></a>6. 支撑自研应用商店</h4><p>应用合规分析（静态、动态分析）、自动审核&#x2F;上架、UI自动化测试是应用商店运营的重要支撑。此时UI自动化测试将从研发质量、兼容性的范畴扩展到运营、对接层面。</p><p>除此之外，三方应用的UI测试与一方二方应用的UI测试的特点无异：</p><ol><li>枯燥，重复</li><li>成本，时间</li><li>扩展，重用</li><li>探索性case的测试</li></ol><blockquote><p>一方：指的是本团队的项目，如内置应用（易于进行白盒&#x2F;黑盒测试）<br>二方：一方使用的可能是其他部分研发的、外部引入的应用&#x2F;包&#x2F;库（不难进行白盒&#x2F;黑盒测试，通常集成到一方后进行测试）<br>三方：第三方的应用，如应用市场下载的应用（几乎没有通用的白盒方法，黑盒测试囿于复杂性难以实现通用化；不熟悉主程；难以衡量覆盖率；迭代不可控、测试节奏不自主）</p></blockquote><h1 id="三方应用UI自动化的技术难题和隐患"><a href="#三方应用UI自动化的技术难题和隐患" class="headerlink" title="三方应用UI自动化的技术难题和隐患"></a>三方应用UI自动化的技术难题和隐患</h1><p>实现对应用的UI自动化测试将给团队带来效率和体验的提升、研发质量的改善，基于这一类的愿景，业界提出了大量的测试思想，落地了强大了工具、框架。</p><p>但是对于三方应用UI自动化测试的实现，主要受限于纯黑盒的环境、数量众多的各三方App，以及有限的成本预算、紧迫的时间，尚无简单高效的方案可供直接使用或参考。</p><p>本节总结<strong>三方应用UI自动化测试的难点</strong>，并铺垫下文对三方应用UI自动化方案的探索。</p><h2 id="App-UI自动化测试的一般实践"><a href="#App-UI自动化测试的一般实践" class="headerlink" title="App UI自动化测试的一般实践"></a>App UI自动化测试的一般实践</h2><p>UI自动化测试通常要求App具有如下内在特点：</p><ol><li>软件需求变动不频繁<br> 否则建议在UI测试（包括对自动化的开发）中投入占比不超过20%（因为（半）手工方式更快，具体方案见敏捷类方法）</li><li>产品更新维护周期长<br> 否则跑UI自动化的次数不够多，收益不够大</li><li>比较频繁的回归测试<br> 根据自动化金字塔，UI测试属于（相对于金字塔底层的接口测试、单元测试而言）执行效率低、复杂度高（脆弱）、问题出现后分析链路长的一般在回归测试时进行的测试</li><li>自动化测试脚本可以重复使用、易于回放<br> 脚本如果不能重用，无法”回本”，即得不偿失</li></ol><p>也就是说，<strong>UI测试是分场景</strong>的，<strong>场景决定了UI自动化测试是否值得</strong>。</p><p>测试金字塔是一个理想状态下软件测试模型。三层分别是UI测试、集成测试和单元测试。金字塔从下往上，可维可调性越差，效率越低。越接近底层所能达到的覆盖率越高。</p><p><img src="https://s1.ax1x.com/2022/10/20/x6ZM6S.png" alt="测试金字塔.png"></p><blockquote><p>UI测试应该投入的资源就如金字塔塔尖一样，占比最小，且靠后进行</p></blockquote><p><img src="https://s1.ax1x.com/2022/10/20/x6mmM8.png" alt="测试金字塔及反模式.png"></p><blockquote><p>对三方应用的UI自动化测试无法像一方应用那样易于进行，投入占比也很难有成熟的模型来衡量。但三方应用本身的“三方”特性，我们可以肯定，三方应用相关的UI自动化测试代码越少越好，总体投入越少越好。</p></blockquote><p>对于三方应用UI自动化的场景，其更加尖锐的效率要求、恶劣的自动化条件（业务是黑盒、逻辑是黑盒、Apk内建自动化接口是黑盒），使之<strong>具有了象征更高要求的特点</strong>：</p><ol><li>自动化设施必须是跨UI技术栈的<br> 要满足各种UI技术栈，不像单个应用的UI自动化那样支持单一的特定的自动化框架即可。</li><li>低代码乃至于无代码<br> 三方应用众多且迭代不受控，自动化代码越多，其保值能力就越脆弱。</li></ol><p>在尽可能满足以上几点要求、兼顾低代码、高效率，可以推导出符合三方应用UI自动化测试需求的方案应该满足以下几点：</p><ol><li>具备识别各类型UI的能力：原生、WebView、Flutter、Cocos、Unity、React…</li><li>具备各类型UI的点击能力</li><li>对三方应用，不关注业务流程，只关注一定程度的不要太低的覆盖率（“界面点点点的深度、广度”）：要有自动“点点点”的能力，能划屏更佳</li><li>低代码，不&#x2F;少写保质期短、制作耗时的测试脚本</li></ol><p>那么总结来说，这个工具应该是<strong>自动遍历各类界面并点点点</strong>。</p><p>Android单个应用的UI自动化具有完善的工业级技术，我们看看这些基础技术能否使用或参考。</p><h2 id="App-UI自动化的基础技术"><a href="#App-UI自动化的基础技术" class="headerlink" title="App UI自动化的基础技术"></a>App UI自动化的基础技术</h2><p>Android UI自动化框架的主要能力是界面感知和界面操作。一个完整的自动化UI测试操作是首先完成<strong>待点击、滑动区域的识别</strong>，然后完成<strong>界面操作和导航</strong>。</p><p>对于业界先进的方案，主要如下。</p><p><img src="https://s1.ax1x.com/2022/10/21/x6cvWj.png" alt="AndroidUI自动化.png"></p><p>UI自动化测试中重要也是耗费精力的一环，就是借助UI技术提供的机制编写代码、操作、录制，实现UI感知，即UI控件识别、定位。主要分为如下两种类型的实现。</p><p><img src="https://s1.ax1x.com/2022/10/21/xcixZn.png" alt="UI自动化测试定位方法.png"></p><table><thead><tr><th>分类</th><th>原理</th><th>兼容能力</th><th>优点</th><th>缺点</th><th>代表作</th></tr></thead><tbody><tr><td>图像技术</td><td>通过图像识别来分析和查找操作区域</td><td>应用无侵入，依靠图像因而可以无视UI技术差异，兼容能力强</td><td>避免繁琐的界面分析定位、自动化脚本，上手更快；兼容各UI栈</td><td>图像识别在准确率、耗时、模型大小等需要投入</td><td>Airtest + Poco</td></tr><tr><td>原生定位能力</td><td>Android内置无障碍服务提供ViewTree解析能力，自动化工具借助它来分析UI结构、发出操作事件</td><td>三方应用UI实现具有随意性，存在相当比例的应用难以编写自动化脚本</td><td>定位准确；在稳定迭代的项目中发挥更佳</td><td>借助无障碍服务提供的ViewTree，存在IPC耗时、ViewTree解析耗时，测试速度慢；自动化脚本保质期短（尤其是三方应用）</td><td>Appium</td></tr></tbody></table><blockquote><p>兼容能力：Android UI技术栈众多，UI自动化测试得以进行的基础是这个UI技术栈维护的ViewTree或DOM易于获取、解析。多种不同技术栈之间差异较大，主要分为原生、WebView、React、Cocos、Unity、Flutter等。</p></blockquote><blockquote><p>应用侵入：为了满足自动化测试，必须注入到应用进程中，或者要求应用接入SDK</p></blockquote><h2 id="三方App-UI自动化的侧重"><a href="#三方App-UI自动化的侧重" class="headerlink" title="三方App UI自动化的侧重"></a>三方App UI自动化的侧重</h2><p>从上文两类界面感知方法及其配套的界面操作方法各有千秋，在不同的场景下各有优劣。在这些特性的基础上，三方应用UI自动化实际上更依赖于以下几个特性来确保效率。</p><ul><li>跨UI技术栈的兼容性</li><li>低代码</li><li>自动遍历Clickable、Scrollable控件并完成操作</li><li>进行的UI测试具有一定的深度、广度，能够测试到足够多的UI界面</li></ul><p>对于图像技术而言，实现上述功能在整体难度上暂且不表，而逻辑上则较简单——即通过图像技术分析画面，分类出符合的控件，并按照一定逻辑组织自动测试（深度优先、广度优先）流程。</p><p>前面分析过，图像技术本身的原理以及对UI的实现技术栈的独立性，天生就决定了其在跨UI技术栈兼容性会表现更佳，且模型的成熟度影响测试深度、广度。此外，由于图像分析避免了原生定位中要求的繁琐代码实现，因此其低代码属性也是与生俱来。</p><p>对比来看，在针对三方应用UI自动化而言，由于客观上UI技术的多样性、碎片化，以及主观上对原生定位接口即自动化脚本的开发具有脆弱性，原生定位方案在跨UI技术栈兼容性这一方面较弱，同时针对一个应用的一个场景，所投入的资源、产出的代码量也较大，不适合与大量三方应用的场景。</p><p>为了在三方应用UI自动化这种要求低代码、高兼容性的黑盒场景中取得更高的效率、更低的投入，要求自动化设施必须具有下面这些特性。</p><table><thead><tr><th>特性</th><th>目的</th><th>原理</th><th>技术方案</th></tr></thead><tbody><tr><td>兼容多UI技术栈</td><td>应对三方应用多样、脆弱的UI技术栈</td><td>同时具有原生定位能力和图像技术定位能力</td><td>原生定位方案+机器学习&#x2F;视觉方案</td></tr><tr><td>低代码甚至无代码</td><td>减少自动化脚本成本、防止陷入过低的投入产出比</td><td>避免进行界面定位工作、自动化脚本编码工作</td><td>将原生能力、图像技术能力得到的界面信息转化为树、图等进行遍历，抛弃xpath、图像匹配等的遍历</td></tr></tbody></table><h4 id="小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。"><a href="#小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。" class="headerlink" title="小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。"></a>小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。</h4><h1 id="三方应用UI自动化的选型"><a href="#三方应用UI自动化的选型" class="headerlink" title="三方应用UI自动化的选型"></a>三方应用UI自动化的选型</h1><p>在常规的传统的UI自动化测试的基础上，由于原生定位能力相关的技术较完善成熟，对三方应用的UI自动化重点关注“自动遍历”和“图像技术”辅助。</p><h2 id="1-自动遍历"><a href="#1-自动遍历" class="headerlink" title="1. 自动遍历"></a>1. 自动遍历</h2><p>对于非图像处理技术的定位方案，通常自动化测试的主要投入是对界面的分析工作、对界面的自动化编码。这两大步骤是UI自动化测试中最大的投入之一，同时也是“脆弱性”即自动化脚本时效性的来源。</p><p>事实上，App的界面和控件可以被抽象成树型结构。</p><ul><li>App的所有UI界面可以抽象成树，界面之间的跳转即树的连接路径，各个界面为叶子或根节点</li><li>App的一个UI界面中的所有控件是树形结构组织的（ViewRootImpl树），各个控件总是能够从父节点经过路径到达</li><li>部分UI技术提供的“树”可能需要结合图像技术才能完整确定</li></ul><p>基于原生定位能力实现的自动化设施主要的耗时点（尤其是针对三方应用）在于分析该UI树，找到关键控件的关键信息，编写自动化脚本完成定位、操作和导航。</p><p>自动遍历的核心在于忽略“树”的细节，从根节点开始，遍历整个UI树和控件树，在摒弃自动化脚本的同时实现对UI的遍历，达成和自动化脚本接近的自动操作效果。</p><p><img src="https://s1.ax1x.com/2022/10/25/xRRqtP.png" alt="二叉树_前序遍历"></p><p>从策略上看，遍历通常有DFS（深度优先）和BFS（广度优先）。对大多数应用而言，DFS效率更高，需要跳转界面的频次较低。</p><p>从方案上看，由于原生定位能力和图像技术均能建立抽象UI树，因此自动遍历也有这两种方案。一般而言，原生定位能力实现的难度较低（因为UI树是App现成的自带的），但是考虑到UI多样性和跨UI栈兼容能力的脆弱性，图像技术是很重要的补充（尤其是针对三方应用）。</p><h2 id="2-图像技术"><a href="#2-图像技术" class="headerlink" title="2. 图像技术"></a>2. 图像技术</h2><p>图像技术最直接的作用是支持那些无法被原生定位能力所支撑的应用的自动化测试。但实践来看，图像技术对测试效率的提升、测试时长方面有显著的优势，这超出了其增强UI兼容性的最基本需要。</p><p>出于原生定位能力自身的局限、三方应用UI的脆弱性（技术栈多、保质期短、自动化不友好），为了提升原生定位能力不够用的多技术栈兼容能力，通过图像技术来识别和分析界面的研究已经在业界取得众多成果。</p><p><img src="https://s1.ax1x.com/2022/10/25/xRf6G6.png" alt="UI视觉分析.png"></p><p>图像技术超脱了UI技术实现的细节，因而摆脱了基于原生定位能力的自动化设施的脆弱性。在针对数量广大的三方应用的自动化测试场景中不可或缺，决定了自动遍历阶段的输入的完整性和高效性。</p><p>同时，图像技术在辅助甚至主导界面感知之外，还可能提供不菲的效率提升。原生定位能力所提供的界面感知能力的优点是精细，适合一方应用开发使用。在数量众多的三方应用的自动化测试方面，除了存在效率、脆弱性等隐患以外，其测试速度也较低。</p><p>原生定位能力基于UI树来进行界面感知、界面点击。由于对树（或图）的分析非常耗时（对树的节点们都进行分析若干个属性），且在设备端无障碍服务需要通过IPC（Binder）来与App交互。因此，从原理上（树的分析）和工程上（IPC）导致其效率不高。实践数据来看，其测试速度慢于图像技术。分部分来看，其界面感知速度较慢（树的分析慢于图像分析），操作速度也慢于直接发送触摸事件。</p><blockquote><p>原生定位能力对混合应用存在较大兼容问题。如React虚拟DOM的情况，每当页面更新会触发生成新的DOM，导致UI树变化，需要重新进行分析。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>三方应用的自动化测试工具，通过同时支持原生定位能力和图像能力作为界面感知技术来应对三方应用UI自动化的脆弱性，并在界面操作方面通过自动遍历来实现低代码，解决在投入产出比、效率方面的隐患。</p><h2 id="参考工具"><a href="#参考工具" class="headerlink" title="参考工具"></a>参考工具</h2><p>对于原生定位能力、图像技术、自动遍历等技术，较适合三方应用场景的有如下几个工具。</p><table><thead><tr><th>分类</th><th>方案</th><th>原理</th><th>描述</th></tr></thead><tbody><tr><td>原生定位能力</td><td>Appium</td><td>通过无障碍服务取得UI树</td><td>提供界面感知能力，对多种UI技术栈兼容性较佳，但是没有完整达到三方应用自动化的需求</td></tr><tr><td>自动遍历</td><td>AppCrawler</td><td>基于Appium，对UI树进行自动遍历</td><td>UI兼容性没有完整达到三方应用自动化的需求；测试速度较慢</td></tr><tr><td>图像技术</td><td>Poco Airtest</td><td>Poco进行图像匹配，Airtest进行测试流程</td><td>编码较原生定位能力更少，但是仍然需要编码</td></tr><tr><td>图像技术+自动遍历+原生定位能力混合</td><td>Fastbot</td><td>多种技术结合</td><td>兼容性强，能够自动遍历；但是自动遍历方案不是完整的深度遍历</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>RD: 研发</li><li>QA: 质量（包括测试、测开）</li><li>《Succeeding with Agile: Software Development using Scrum 》(Scrum敏捷软件开发) Mike Cohn</li><li><a href="https://developer.android.com/training/testing/fundamentals">Android Developer 测试最佳实践</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;3:49 pm&lt;br&gt;Thursday, 20 October 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：分析数据库事务性能瓶颈与优化方案</title>
    <link href="https://nasdaqgodzilla.github.io/2022/11/03/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E4%B8%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>https://nasdaqgodzilla.github.io/2022/11/03/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E4%B8%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2022-11-03T13:08:48.000Z</published>
    <updated>2022-11-03T13:09:42.662Z</updated>
    
    <content type="html"><![CDATA[<hr><p>10:59 am<br>Tuesday, 1 November 2022 (HKT)<br>Time in Hong Kong</p><hr><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a><ul><li><a href="#%E7%9B%AE%E6%A0%87">目标</a></li></ul></li><li><a href="#%E7%8E%AF%E5%A2%83%E3%80%81%E5%B7%A5%E5%85%B7">环境、工具</a><ul><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E5%B7%A5%E5%85%B7">工具</a></li></ul></li><li><a href="#%E8%A7%82%E6%B5%8B">观测</a><ul><li><a href="#1-trace%E4%B8%8A%E7%9C%8B%E7%93%B6%E9%A2%88%E6%98%AF%E5%AD%98%E5%82%A8">1. Trace上看瓶颈是存储</a><ul><li><a href="#11-%E6%A3%80%E9%AA%8Cfdatasync%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%80%97%E6%97%B6">1.1 检验fdatasync是否真的耗时</a></li></ul></li><li><a href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%B2%A1%E6%9C%89%E8%B7%91%E6%BB%A1io%E6%9E%81%E9%99%90">2. 数据库测试没有跑满IO极限</a><ul><li><a href="#21-%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9dd%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D">2.1 系统缓冲区对dd性能的影响</a></li><li><a href="#22-%E4%BC%B8%E7%BC%A9io%E8%B5%84%E6%BA%90%E5%8F%91%E7%8E%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%88%90%E7%BB%A9%E5%BD%B1%E5%93%8D%E6%9C%89%E9%99%90">2.2 伸缩IO资源发现对数据库测试成绩影响有限</a></li></ul></li><li><a href="#3-cpu%E8%B5%84%E6%BA%90%E5%88%B6%E7%BA%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%91%E5%88%86">3. CPU资源制约数据库跑分</a><ul><li><a href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%8D%E5%90%8C%E6%A0%B8%E5%BF%83%E5%BE%97%E5%87%BA%E7%9A%84%E8%B7%91%E5%88%86%E6%88%90%E7%BB%A9:-%E5%A4%A7%E5%B0%8F%E6%A0%B8%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82">绑定到不同核心得出的跑分成绩: 大小核性能差异</a></li><li><a href="#%E5%AE%9A%E9%A2%91%E5%B8%A6%E6%9D%A5%E8%B7%91%E5%88%86%E6%8F%90%E5%8D%87:-%E5%BC%BA%E5%88%B6%E6%8F%90%E9%AB%98CPU%E9%A2%91%E7%8E%87">定频带来跑分提升: 强制提高CPU频率</a></li></ul></li></ul></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们的设备经过性能测试，在IO测试阶段、数据库操作部分的跑分显著与对比机拉开差距，且跑分结果怪异：常规的<strong>串行读写、随机读写与对比机成绩差距细微，但是数据库操作居然差距巨大</strong>。</p><p><img src="https://s1.ax1x.com/2022/11/01/xT7C0s.png" alt="数据库跑分对比"></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>从表中可以看到，两者<strong>常规IO成绩接近，但是数据库事务差距一倍以上</strong>。我们需要分析跑分差异的原因，并定位设备和系统的性能瓶颈。</p><ol><li>分析跑分差异根因；为什么数据库读写会意外地落差巨大？</li><li>定位性能瓶颈；性能瓶颈是来自存储吗？</li></ol><h1 id="环境、工具"><a href="#环境、工具" class="headerlink" title="环境、工具"></a>环境、工具</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table><thead><tr><th>设备</th><th>软件环境</th><th>硬件环境</th><th>跑分手法</th></tr></thead><tbody><tr><td>MT8183</td><td>Android 10 + 不加后台负载</td><td>MT8183 + 4GB LPDDR4X + mmc</td><td>AndroBench V5.0.1 测试data分区，数据库事务size&#x3D;1; 启用Index Usage; Journal Mode&#x3D;WAL;</td></tr><tr><td>对比机 QCOM 660 AIE</td><td>Android 9 + 不加后台负载</td><td>QCOM 660 AIE + 4GB LPDDR4</td><td>同上</td></tr></tbody></table><blockquote><p>注意，IO测试与存储芯片有相关性，这里用mmc来表示，忽略具体的存储芯片型号和性能。</p></blockquote><blockquote><p>具体原因是：1. 没有取得机器们的存储芯片的准确的型号和性能参数；2. 两者在Antutu BenchMark和AndroBench的串行读写、随机读写的成绩几乎一致——因此可以认为两个机器的存储性能接近（起码是跑分场景的性能接近），所以<strong>忽略存储芯片差异，不影响分析</strong>。</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>工具</th><th>目的</th><th>使用</th></tr></thead><tbody><tr><td>AndroBench V5.0.1</td><td>数据库跑分</td><td></td></tr><tr><td>strace</td><td>统计系统调用耗时</td><td>strace -qc -pPID</td></tr><tr><td>top</td><td>查看线程CPU、Per CPU Usage</td><td>busybox top -d1 转H、转1</td></tr><tr><td>top</td><td>查看线程状态</td><td>top -m15 -H -pPID</td></tr><tr><td>iostat</td><td>看IO信息</td><td>busybox iostat -cdtzm 1</td></tr><tr><td>TraceView</td><td>看Trace</td><td></td></tr><tr><td>taskset</td><td>对跑分软件绑核</td><td>taskset -ap MASK PID</td></tr><tr><td>drop_caches</td><td>强制系统丢弃cache</td><td>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</td></tr><tr><td>sync</td><td>写入脏buffer到磁盘</td><td>sync</td></tr><tr><td>CPU定频</td><td>让CPU运行在最高频</td><td><a href="https://nasdaqgodzilla.github.io/2022/11/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9ACPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E5%AE%9A%E9%A2%91%EF%BC%88MTK%EF%BC%89/">链接</a></td></tr></tbody></table><h1 id="观测"><a href="#观测" class="headerlink" title="观测"></a>观测</h1><p>本节通过一些观测手法来尝试分析和定位性能瓶颈。</p><h2 id="1-Trace上看瓶颈是存储"><a href="#1-Trace上看瓶颈是存储" class="headerlink" title="1. Trace上看瓶颈是存储"></a>1. Trace上看瓶颈是存储</h2><p>首先再次在机器上跑一次AndroBench数据库测试，并抓一次trace。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7FAl4.png" alt="8183_perfetto.png"></p><p>可以看到<code>sys_fdatasync</code>耗时很长，整个数据库事务提交过程绝大部分在<code>fdatasync()</code>。乍一看似乎瓶颈是存储性能，但由于trace机制粒度较粗，细节较少，其实目前还没有足够的证据证实。Anyway，先继续分析，暂时不做出性能瓶颈是存储的结论。</p><blockquote><p>Trace上有很多层的<code>sys_fdatasync</code>，虽然它记录的耗时很长但是不一定能真实反应data sync耗时真的很长。实际上很可能是对fdatasync trace end的调用放到了整个过程的后面，即实际上sync工作完成之后一段时间才结束这个tag的trace，因而data sync的记录很长，且记录的耗时可能远远高于实际耗时。</p></blockquote><ul><li><p>小结1：Trace目前没有可靠地提示一些信息</p></li><li><p>小结2: 根据Trace的实现机制，认为该Trace记录可能不准确</p></li></ul><h3 id="1-1-检验fdatasync是否真的耗时"><a href="#1-1-检验fdatasync是否真的耗时" class="headerlink" title="1.1 检验fdatasync是否真的耗时"></a>1.1 检验fdatasync是否真的耗时</h3><p>从Linux man可以查阅到，<code>fdatasync()</code>和<code>fsync()</code>都是会阻塞直到数据完成写入的。那么我们可以通过检查IO线程的挂起状态的占比即可确认线程是否在等待IO时消耗了过长的时间。</p><blockquote><p>The call blocks until the device reports that the transfer has completed。</p></blockquote><p><img src="https://s1.ax1x.com/2022/11/01/x71ZTS.png" alt="x71ZTS.png"></p><p>从trace可以看到，线程在IO等待方面耗时很小。</p><ul><li>小结：IO flush操作耗时不是性能瓶颈</li></ul><h2 id="2-数据库测试没有跑满IO极限"><a href="#2-数据库测试没有跑满IO极限" class="headerlink" title="2. 数据库测试没有跑满IO极限"></a>2. 数据库测试没有跑满IO极限</h2><p>从上面的分析来看，并没有严丝合缝的证据表明数据库事务测试碰到了IO瓶颈。本节通过一些方法检验该机器的数据库测试性能瓶颈不是IO，并设计一些实验来进行一些额外的观测。</p><p>与顺序&#x2F;随机读写测试对比而言，数据库CRUD的特点是QPS高，但是数据量低。表现在IO上，前者消耗更多的IO资源，而后者通常需要高并发来取得高IO占用。</p><p>顺序&#x2F;随机读写测试，消耗很低的CPU，触及IO极限：</p><p><img src="https://s1.ax1x.com/2022/11/01/x73Q4e.png" alt="顺序读写测试资源占用.png"></p><ul><li>上图结果可见，该机器的IO极限约90附近。CPU消耗低且处于IO wait。下图为数据库跑分阶段：</li></ul><p><img src="https://s1.ax1x.com/2022/11/01/x73ovR.png" alt="数据库事务测试资源占用.png"></p><ul><li><p>数据库CRUD测试远远达不到IO极限（仅峰值的10%+），但是需要付出巨大的CPU代价。注意，CPU消耗占比中，<strong>USER和SYS占比上升几倍，而IO wait接近可以忽略，表明此时CPU是“真忙”，而不是在等待IO中的“假忙”</strong>。</p></li><li><p>小结：<strong>数据库事务测试没有跑到IO极限，且针对该设备，数据库CRUD是计算资源敏感型</strong></p></li></ul><p>通常来说数据库性能除了与硬件相关，还与数据库库表设计、磁盘缓冲、内存操作容量等因素相关。但是在IO性能测试场景，由于和对比机使用的测试工具是一致的，因此需要忽略数据库的设计、操作方法、缓存方案、并发数、连接数，而重点关注其他的具有差异的因素对数据库性能的影响。如下：</p><ul><li>系统缓存策略</li><li>CPU性能</li><li>存储性能</li></ul><p>由于在数据库事务测试中发现没有跑满IO，因此<strong>尝试伸缩IO资源来检验性能瓶颈</strong>。</p><h3 id="2-1-系统缓冲区对dd性能的影响"><a href="#2-1-系统缓冲区对dd性能的影响" class="headerlink" title="2.1 系统缓冲区对dd性能的影响"></a>2.1 系统缓冲区对dd性能的影响</h3><p>Linux系统IO实现是分层的，一些上层的测试方法可能因缓冲区策略、大小不同而出现不同的测试成绩。本小结测试缓冲区对dd的性能影响。</p><blockquote><p><code>iostat</code>输出的数据实际上是磁盘真实IO速度，而不受缓冲区策略的影响</p></blockquote><p><strong>每次测试前，清空buffer，丢弃cache</strong>：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/data/local/tmp # free -k &amp;&amp; sync &amp;&amp; echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches &amp;&amp;<span class="title"> free</span> -k<span class="title"></span></span><br><span class="line"><span class="title">                total</span> <span class="title">       used</span> <span class="title">       free</span> <span class="title">     shared</span> <span class="title">    buffers</span></span><br><span class="line">Mem:          3957988     1429360     2528628        7048        4464</span><br><span class="line">-/+<span class="title"> buffers/cache:</span>        1424896     2533092<span class="title"></span></span><br><span class="line"><span class="title">Swap:</span>         2176888      302080     1874808<span class="title"></span></span><br><span class="line"><span class="title">                total</span> <span class="title">       used</span> <span class="title">       free</span> <span class="title">     shared</span> <span class="title">    buffers</span></span><br><span class="line">Mem:          3957988     1413012     2544976        7048         476</span><br><span class="line">-/+<span class="title"> buffers/cache:</span>        1412536     2545452<span class="title"></span></span><br><span class="line"><span class="title">Swap:</span>         2176888      302080     1874808</span><br></pre></td></tr></table></figure><ul><li>带缓冲区：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">time</span> dd if=/dev/zero of=test bs=<span class="number">1</span>k count=<span class="number">4096000</span> &amp;&amp; time sync</span><br><span class="line"></span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">4194304000</span> bytes (<span class="number">3</span>.<span class="number">9</span> G) copied, <span class="number">40</span>.<span class="number">776918</span> s, <span class="number">98</span> M/s</span><br><span class="line"><span class="attribute">0m40</span>.<span class="number">79</span>s real     <span class="number">0</span>m<span class="number">01</span>.<span class="number">93</span>s user     <span class="number">0</span>m<span class="number">28</span>.<span class="number">54</span>s system</span><br><span class="line"><span class="attribute">0m05</span>.<span class="number">11</span>s real     <span class="number">0</span>m<span class="number">00</span>.<span class="number">00</span>s user     <span class="number">0</span>m<span class="number">00</span>.<span class="number">08</span>s system</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn</span><br><span class="line"><span class="attribute">mmcblk0</span>         <span class="number">183</span>.<span class="number">17</span>         <span class="number">0</span>.<span class="number">00</span>        <span class="number">90</span>.<span class="number">60</span>          <span class="number">0</span>         <span class="number">91</span></span><br></pre></td></tr></table></figure><ul><li>不带缓冲区</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">time</span> dd if=/dev/zero of=test bs=<span class="number">1</span>k count=<span class="number">4096000</span> conv=fsync &amp;&amp; time sync</span><br><span class="line"></span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">4194304000</span> bytes (<span class="number">3</span>.<span class="number">9</span> G) copied, <span class="number">45</span>.<span class="number">229102</span> s, <span class="number">88</span> M/s</span><br><span class="line"><span class="attribute">0m45</span>.<span class="number">24</span>s real     <span class="number">0</span>m<span class="number">01</span>.<span class="number">79</span>s user     <span class="number">0</span>m<span class="number">29</span>.<span class="number">42</span>s system</span><br><span class="line"><span class="attribute">0m00</span>.<span class="number">03</span>s real     <span class="number">0</span>m<span class="number">00</span>.<span class="number">00</span>s user     <span class="number">0</span>m<span class="number">00</span>.<span class="number">01</span>s system</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn</span><br><span class="line"><span class="attribute">mmcblk0</span>         <span class="number">187</span>.<span class="number">00</span>         <span class="number">0</span>.<span class="number">00</span>        <span class="number">92</span>.<span class="number">51</span>          <span class="number">0</span>         <span class="number">92</span></span><br></pre></td></tr></table></figure><p>可见，缓冲区确实有一定的IO性能影响，但是测试过程中dd数据量较大，能够覆盖buffer并触发磁盘flush，因此不论带不带缓冲，两种dd测试都触及了磁盘IO峰值性能。</p><blockquote><p>iostat统计磁盘的实际IO，不受buffer影响</p></blockquote><h3 id="2-2-伸缩IO资源发现对数据库测试成绩影响有限"><a href="#2-2-伸缩IO资源发现对数据库测试成绩影响有限" class="headerlink" title="2.2 伸缩IO资源发现对数据库测试成绩影响有限"></a>2.2 伸缩IO资源发现对数据库测试成绩影响有限</h3><p>设计一个实验来<strong>降低系统分配给数据库测试工具的IO资源。假设该实验中数据库测试成绩变化有限，可以一定程度地说明数据库CRUD性能测试的瓶颈与IO性能关联不大</strong>。</p><p>通过后台dd占用不同程度的IO资源的方式实现伸缩：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function command0() &#123;</span><br><span class="line">    <span class="attribute">output</span>=test/test$_depth_</span><br><span class="line">    dd <span class="attribute">if</span>=/dev/zero <span class="attribute">of</span>=<span class="variable">$output</span> <span class="attribute">bs</span>=1k <span class="attribute">count</span>=4096</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function command() &#123;</span><br><span class="line">    <span class="keyword">while</span> (( --_depth_ &gt;= 0 )); <span class="keyword">do</span></span><br><span class="line">        command0</span><br><span class="line">        sleep 0.2</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生一定的IO压力：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn</span><br><span class="line"><span class="attribute">mmcblk0</span>         <span class="number">102</span>.<span class="number">97</span>         <span class="number">0</span>.<span class="number">00</span>        <span class="number">47</span>.<span class="number">56</span>          <span class="number">0</span>         <span class="number">48</span></span><br></pre></td></tr></table></figure><p>在这套脚本运行时，启动数据库测试，得出跑分成绩仅仅只比空负载时降低了16%左右。<strong>如果IO性能是数据库跑分瓶颈的话，那么此时跑分成绩应该显著下降</strong>。</p><ul><li>小结：通过<strong>IO加压的方式缩减了能够分配给数据库测试工具的IO资源，但是跑分变化远低于瓶颈预期值。表明IO性能目前不是性能瓶颈</strong>。</li></ul><h2 id="3-CPU资源制约数据库跑分"><a href="#3-CPU资源制约数据库跑分" class="headerlink" title="3. CPU资源制约数据库跑分"></a>3. CPU资源制约数据库跑分</h2><p>排除数据库设计、使用方案的影响，也排除掉IO性能的影响，还有一个瓶颈嫌疑是CPU性能。</p><p>设计一个实验来伸缩CPU资源。<strong>如果跑分对CPU资源的变化很敏感、显著地影响了数据库成绩</strong>，那么即可确定瓶颈。</p><p>通过削减数据库跑分软件的CPU资源来实现CPU资源的控制，主要采取<strong>数据库跑分线程绑定到专用核心，并在该核心上附加一定的压力</strong>来实现。</p><ol><li>首先在默认情况下的跑分，可见此时跑分线程会随机地在任意的CPU上运行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B_cpu%E6%A0%B8%E5%BF%83%E4%BF%A1%E6%81%AF.gif" alt="数据库测试过程CPU核心信息"></p><blockquote><p>注：top1就是数据库跑分线程，top2&#x2F;3分别是跑分应用的UI线程和渲染线程，它们用于在界面上显示跑分进度条。从数据上看，它们本身也占有一些CPU资源。</p></blockquote><ol start="2"><li>将跑分线程绑定到CPU0～3，将其他线程绑定到4～7</li></ol><p>可见，跑分线程只会在CPU0～3中调度。最终测试成绩与默认情况一致，没有差异。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E8%B7%91%E5%88%86%E7%BA%BF%E7%A8%8B0-3%E5%85%B6%E4%BB%964-7.gif" alt="数据库跑分线程0-3"></p><ol start="3"><li>将跑分线程和其他线程都绑定到CPU7</li></ol><p>让跑分线程绑定到CPU7，并因CPU7调度了其他线程而损失一些CPU资源。（本例主要是被跑分工具自己的UI线程和渲染线程分走）</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E5%85%A8%E9%83%A8%E7%BB%91%E5%AE%9A%E5%88%B0CPU7.gif" alt="全部绑定到CPU7"></p><p>可以看到，三个线程全部在CPU7上运行。跑分结果中，成绩较默认情况下降30%，证明该跑分在该设备上是CPU资源敏感型。</p><ol start="4"><li>将跑分线程和其他所有线程都绑定到CPU3</li></ol><p>与“3”相同，但是绑定CPU3。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%85%A8%E9%83%A8%E7%BB%91%E5%AE%9A%E5%88%B0CPU3.gif"></p><p>成绩较默认下降50%左右。</p><ul><li>各场景梳理：</li></ul><table><thead><tr><th>场景(SQLite Delete)</th><th>成绩(QPS of SQLite Delete)</th><th>说明</th></tr></thead><tbody><tr><td>默认场景</td><td>849</td><td></td></tr><tr><td>后台dd命令制造峰值IO速率30%左右的IO压力</td><td>790</td><td>成绩略微下降</td></tr><tr><td>允许跑分线程在CPU0-3调度，其他为4-7调度</td><td>833</td><td>CPU资源几乎没有差异；成绩几乎没有差异</td></tr><tr><td>跑分线程和UI线程+渲染线程都绑定到CPU7</td><td>532</td><td>成绩下降～36%</td></tr><tr><td>都绑定到CPU3</td><td>392</td><td>成绩下降～52%</td></tr></tbody></table><p>小结：<strong>该机器在数据库跑分场景的性能瓶颈为CPU性能</strong>。</p><h3 id="绑定到不同核心得出的跑分成绩-大小核性能差异"><a href="#绑定到不同核心得出的跑分成绩-大小核性能差异" class="headerlink" title="绑定到不同核心得出的跑分成绩: 大小核性能差异"></a>绑定到不同核心得出的跑分成绩: 大小核性能差异</h3><p>可以看到绑定到不同CPU会产生比较显著的跑分成绩差异，实际上是CPU的大小核架构中大核和小核之间的性能差异。</p><p><code>cat /proc/cpuinfo</code>可知该机器有两种架构的CPU核。其中<code>CPU part</code>字段代表不同的架构：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ...</span><br><span class="line"></span><br><span class="line"><span class="attribute">processor       </span>: 3</span><br><span class="line"><span class="attribute">BogoMIPS        </span>: 26.00</span><br><span class="line"><span class="attribute">Features        </span>: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br><span class="line"><span class="attribute">CPU implementer </span>: 0x41</span><br><span class="line"><span class="attribute">CPU architecture</span>: 8</span><br><span class="line"><span class="attribute">CPU variant     </span>: 0x0</span><br><span class="line"><span class="attribute">CPU part        </span>: 0xd03</span><br><span class="line"><span class="attribute">CPU revision    </span>: 4</span><br><span class="line"></span><br><span class="line">... ... ... ...</span><br><span class="line"></span><br><span class="line"><span class="attribute">processor       </span>: 7</span><br><span class="line"><span class="attribute">BogoMIPS        </span>: 26.00</span><br><span class="line"><span class="attribute">Features        </span>: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br><span class="line"><span class="attribute">CPU implementer </span>: 0x41</span><br><span class="line"><span class="attribute">CPU architecture</span>: 8</span><br><span class="line"><span class="attribute">CPU variant     </span>: 0x0</span><br><span class="line"><span class="attribute">CPU part        </span>: 0xd09</span><br><span class="line"><span class="attribute">CPU revision    </span>: 2</span><br></pre></td></tr></table></figure><p>查阅Kernel <code>cputype.h</code>可知CPU3为0xd03即小核（Contex-A53），CPU7为0xd09即大核（Contex-A57）。大小核之间的性能差异使之在绑定核心后跑出了不同的分数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A35         0xD04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A55         0xD05</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A57         0xD07</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A72         0xD08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A53         0xD03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A73         0xD09</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A75         0xD0A</span></span><br></pre></td></tr></table></figure><h3 id="定频带来跑分提升-强制提高CPU频率"><a href="#定频带来跑分提升-强制提高CPU频率" class="headerlink" title="定频带来跑分提升: 强制提高CPU频率"></a>定频带来跑分提升: 强制提高CPU频率</h3><p>经过测试发现CPU资源下降将显著影响跑分成绩，表明性能瓶颈在CPU。由于在默认情况下CPU在数据库跑分场景可能没有以最高性能运行，因此通过将CPU频率固定到最高频率进行跑分测试。</p><p>固定到CPU最高频率运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find <span class="string">/proc/cpufreq/MT_CPU_DVFS_</span>*<span class="string">/cpufreq_oppidx</span> | xargs cat</span><br><span class="line"></span><br><span class="line">[MT_CPU_DVFS_L/4]</span><br><span class="line">cpufreq_oppidx = 0</span><br><span class="line"><span class="string">...</span> <span class="string">...</span> <span class="string">...</span> <span class="string">...</span></span><br><span class="line">[MT_CPU_DVFS_LL/0]</span><br><span class="line">cpufreq_oppidx = 0</span><br></pre></td></tr></table></figure><table><thead><tr><th>场景(SQLite Delete)</th><th>成绩(QPS of SQLite Delete)</th><th>说明</th></tr></thead><tbody><tr><td>将大核、小核均固定到最高频率</td><td>1417.1</td><td>提升~70%</td></tr><tr><td>将大核固定到最高频率</td><td>1233.2</td><td>提升~48%</td></tr><tr><td>将小核固定到最高频率</td><td>1103.3</td><td>提升~33%</td></tr><tr><td>将大核关闭、小核仅开两颗核心并固定到最低频率</td><td>253.4</td><td>下降~69%</td></tr></tbody></table><blockquote><p>Info：这里为了测试选取固定到最高频率，对于复杂的实际场景，不能笼统地认为最高频率&#x3D;最佳性能&#x2F;最好的用户体验。</p></blockquote><ul><li>小结：可以看到，在该数据库测试方法测试情况下，该平台的性能瓶颈为CPU。</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对于该设备，<code>AndroBench V5.0.1</code>的数据库性能测试方法中，跑分瓶颈是CPU性能，跑分成绩是CPU敏感的。</p><p>优化方案：提升CPU单核性能。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.androbench.org/">AndroBench</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;10:59 am&lt;br&gt;Tuesday, 1 November 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化工具：CPU性能分析、调试和定频（MTK）</title>
    <link href="https://nasdaqgodzilla.github.io/2022/11/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9ACPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E5%AE%9A%E9%A2%91%EF%BC%88MTK%EF%BC%89/"/>
    <id>https://nasdaqgodzilla.github.io/2022/11/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9ACPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E5%AE%9A%E9%A2%91%EF%BC%88MTK%EF%BC%89/</id>
    <published>2022-11-03T12:02:29.000Z</published>
    <updated>2022-11-03T12:04:33.614Z</updated>
    
    <content type="html"><![CDATA[<hr><p>9:51 am<br>Thursday, 3 November 2022 (HKT)<br>Time in Hong Kong</p><hr><ul><li><a href="#%E8%8E%B7%E5%8F%96">获取</a><ul><li><a href="#%E5%9C%A8%E7%BA%BFcpu">在线CPU</a></li><li><a href="#ppm%E4%BD%BF%E8%83%BD">PPM使能</a></li><li><a href="#cpu%E9%A2%91%E7%8E%87(proc)">CPU频率(proc)</a></li><li><a href="#cpu%E9%A2%91%E7%8E%87(sys)">CPU频率(sys)</a></li><li><a href="#cpu%E6%A1%A3%E4%BD%8Doppidx(%E9%A2%91%E7%82%B9)">CPU档位OPPidx(频点)</a></li><li><a href="#cpu%E5%92%8C%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%94%B5%E5%8E%8B">CPU和高速缓存电压</a></li><li><a href="#cpu%E7%AE%97%E5%8A%9B">CPU算力</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%B0%83%E9%A2%91%E7%AD%96%E7%95%A5">支持的调频策略</a></li><li><a href="#%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B0%83%E9%A2%91%E7%AD%96%E7%95%A5">正在使用的调频策略</a></li><li><a href="#%E8%B0%83%E9%A2%91%E9%A9%B1%E5%8A%A8">调频驱动</a></li><li><a href="#%E5%BD%93%E5%89%8D%E5%90%AF%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83">当前启用的核心</a></li><li><a href="#%E5%BD%93%E5%89%8D%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%A2%91%E7%8E%87">当前固定的频率</a></li></ul></li><li><a href="#%E8%AE%BE%E7%BD%AE">设置</a><ul><li><a href="#%E5%BC%80%E5%85%B3cpu%E6%A0%B8%E5%BF%83%E4%B8%AA%E6%95%B0">开关CPU核心个数</a></li><li><a href="#%E5%AE%9A%E9%A2%91">定频</a></li><li><a href="#%E7%BB%91%E6%A0%B8">绑核</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81">相关源码</a></li><li><a href="#%E6%9C%AF%E8%AF%AD">术语</a></li><li><a href="#%E8%B0%83%E9%A2%91%E7%AD%96%E7%95%A5">调频策略</a></li></ul><h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><h2 id="在线CPU"><a href="#在线CPU" class="headerlink" title="在线CPU"></a>在线CPU</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu/online</span><br><span class="line"><span class="number">0</span>-<span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="PPM使能"><a href="#PPM使能" class="headerlink" title="PPM使能"></a>PPM使能</h2><blockquote><p>性能管理模块</p></blockquote><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/ppm/enabled<span class="title"></span></span><br><span class="line"><span class="title">ppm</span> is<span class="title"> enabled</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">echo</span> 0 &gt; /<span class="keyword">proc</span>/ppm/enabled<span class="title"></span></span><br><span class="line"><span class="title">ppm</span> is<span class="title"> disabled</span></span><br></pre></td></tr></table></figure><h2 id="CPU频率-proc"><a href="#CPU频率-proc" class="headerlink" title="CPU频率(proc)"></a>CPU频率(proc)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_freq</span><br><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_LL/</span>cpufreq_freq</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_freq</span><br><span class="line"><span class="number">1326000</span> KHz</span><br><span class="line"></span><br><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_LL/</span>cpufreq_freq</span><br><span class="line"><span class="number">793000</span> KHz</span><br></pre></td></tr></table></figure><blockquote><p>proc节点优先级可能（通常，平台差异）低于thermal</p></blockquote><h2 id="CPU频率-sys"><a href="#CPU频率-sys" class="headerlink" title="CPU频率(sys)"></a>CPU频率(sys)</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu</span><br><span class="line">cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 cpu6 cpu7 cpufreq cpuidle cputopo eas hotplug isolated kernel_max modalias offline online possible <span class="keyword">power</span> present rq-stats sched sched_isolated uevent</span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu</span><br><span class="line"></span><br><span class="line">cat cpu[<span class="number">0</span>-<span class="number">7</span>]<span class="regexp">/cpufreq/</span>cpuinfo_cur_freq</span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1846000</span></span><br><span class="line"><span class="number">1846000</span></span><br><span class="line"><span class="number">1846000</span></span><br><span class="line"><span class="number">1846000</span></span><br></pre></td></tr></table></figure><h2 id="CPU档位OPPidx（频点）"><a href="#CPU档位OPPidx（频点）" class="headerlink" title="CPU档位OPPidx（频点）"></a>CPU档位OPPidx（频点）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_oppidx</span><br><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_LL/</span>cpufreq_oppidx</span><br></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpufreq/MT_CPU_DVFS_L/cpufreq_oppidx</span><br><span class="line"></span><br><span class="line">[MT_CPU_DVFS_L/<span class="number">4</span>]</span><br><span class="line">cpufreq_oppidx = <span class="number">15</span></span><br><span class="line">        <span class="number">0</span>  <span class="comment">(1989000, 103125)</span></span><br><span class="line">        <span class="number">1</span>  <span class="comment">(1924000, 101875)</span></span><br><span class="line">        <span class="number">2</span>  <span class="comment">(1846000, 99375)</span></span><br><span class="line">        <span class="number">3</span>  <span class="comment">(1781000, 98125)</span></span><br><span class="line">        <span class="number">4</span>  <span class="comment">(1716000, 96250)</span></span><br><span class="line">        <span class="number">5</span>  <span class="comment">(1677000, 94375)</span></span><br><span class="line">        <span class="number">6</span>  <span class="comment">(1625000, 92500)</span></span><br><span class="line">        <span class="number">7</span>  <span class="comment">(1586000, 91250)</span></span><br><span class="line">        <span class="number">8</span>  <span class="comment">(1508000, 88750)</span></span><br><span class="line">        <span class="number">9</span>  <span class="comment">(1417000, 86250)</span></span><br><span class="line">        <span class="number">10</span> <span class="comment">(1326000, 83750)</span></span><br><span class="line">        <span class="number">11</span> <span class="comment">(1248000, 81250)</span></span><br><span class="line">        <span class="number">12</span> <span class="comment">(1131000, 78750)</span></span><br><span class="line">        <span class="number">13</span> <span class="comment">(1014000, 76250)</span></span><br><span class="line">        <span class="number">14</span> <span class="comment">(910000, 73750)</span></span><br><span class="line">        <span class="number">15</span> <span class="comment">(793000, 71250)</span></span><br><span class="line"></span><br><span class="line">cat MT_CPU_DVFS_LL/cpufreq_oppidx</span><br><span class="line"></span><br><span class="line">[MT_CPU_DVFS_LL/<span class="number">0</span>]</span><br><span class="line">cpufreq_oppidx = <span class="number">13</span></span><br><span class="line">        <span class="number">0</span>  <span class="comment">(1989000, 93750)</span></span><br><span class="line">        <span class="number">1</span>  <span class="comment">(1924000, 92500)</span></span><br><span class="line">        <span class="number">2</span>  <span class="comment">(1846000, 90000)</span></span><br><span class="line">        <span class="number">3</span>  <span class="comment">(1781000, 88750)</span></span><br><span class="line">        <span class="number">4</span>  <span class="comment">(1716000, 87500)</span></span><br><span class="line">        <span class="number">5</span>  <span class="comment">(1677000, 85625)</span></span><br><span class="line">        <span class="number">6</span>  <span class="comment">(1625000, 83750)</span></span><br><span class="line">        <span class="number">7</span>  <span class="comment">(1586000, 82500)</span></span><br><span class="line">        <span class="number">8</span>  <span class="comment">(1508000, 80000)</span></span><br><span class="line">        <span class="number">9</span>  <span class="comment">(1417000, 77500)</span></span><br><span class="line">        <span class="number">10</span> <span class="comment">(1326000, 75000)</span></span><br><span class="line">        <span class="number">11</span> <span class="comment">(1248000, 71875)</span></span><br><span class="line">        <span class="number">12</span> <span class="comment">(1131000, 69375)</span></span><br><span class="line">        <span class="number">13</span> <span class="comment">(1014000, 66250)</span></span><br><span class="line">        <span class="number">14</span> <span class="comment">(910000, 63125)</span></span><br><span class="line">        <span class="number">15</span> <span class="comment">(793000, 60000)</span></span><br></pre></td></tr></table></figure><ul><li>输出解析：</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CPU</span>名称_核心簇/<span class="keyword">CPUID</span>]</span><br><span class="line">cpufreq_oppidx = 目前使用的opp档位</span><br><span class="line">        档位 (频率, 供电电压uV)</span><br></pre></td></tr></table></figure><blockquote><p>簇分为LL、L、B。CPUID一般是每个簇中的第一个CPU的ID。</p><p>如4+4的CPU中，会有两个簇分别是MT_CPU_DVFS_LL（CPU0-3）和MT_CPU_DVDS_L（CPU4-7），其id分别使用每个簇的第一个CPU即0和4。</p></blockquote><blockquote><p>OPP即CPU能够“挂得上的档”，包含一个频率和对应的供电电压（uV）</p></blockquote><blockquote><p>由上可见该CPU的大小核的最高频率相同（不代表实际性能相同），但是供电差异较大</p></blockquote><h2 id="CPU和高速缓存电压"><a href="#CPU和高速缓存电压" class="headerlink" title="CPU和高速缓存电压"></a>CPU和高速缓存电压</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_volt</span><br><span class="line">Vproc: <span class="number">812500</span> uV</span><br><span class="line">Vsram: <span class="number">912500</span> uV</span><br></pre></td></tr></table></figure><h2 id="CPU算力"><a href="#CPU算力" class="headerlink" title="CPU算力"></a>CPU算力</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu4/</span>cpu_capacity <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpu_capacity</span><br><span class="line"></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu</span><br><span class="line"></span><br><span class="line"><span class="keyword">find</span> cpu*/cpu_capacity | xargs cat</span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure><h2 id="支持的调频策略"><a href="#支持的调频策略" class="headerlink" title="支持的调频策略"></a>支持的调频策略</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat cpu[<span class="number">04</span>]<span class="regexp">/cpufreq/</span>scaling_available_governors</span><br><span class="line">ondemand userspace powersave performance schedutil</span><br><span class="line">ondemand userspace powersave performance schedutil</span><br></pre></td></tr></table></figure><h2 id="正在使用的调频策略"><a href="#正在使用的调频策略" class="headerlink" title="正在使用的调频策略"></a>正在使用的调频策略</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat cpu[<span class="number">04</span>]<span class="regexp">/cpufreq/</span>scaling_governor</span><br><span class="line">schedutil</span><br><span class="line">schedutil</span><br></pre></td></tr></table></figure><h2 id="调频驱动"><a href="#调频驱动" class="headerlink" title="调频驱动"></a>调频驱动</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat cpu[<span class="number">04</span>]<span class="regexp">/cpufreq/</span>scaling_driver</span><br><span class="line">mt-cpufreq</span><br><span class="line">mt-cpufreq</span><br></pre></td></tr></table></figure><h2 id="当前启用的核心"><a href="#当前启用的核心" class="headerlink" title="当前启用的核心"></a>当前启用的核心</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/ppm/policy/ut_fix_core_num<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> core<span class="title"> num</span> = -1<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> core<span class="title"> num</span> = 1</span><br></pre></td></tr></table></figure><ul><li>输出解析：</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">簇<span class="number"> 0 </span>指定使用核心个数 = -1</span><br><span class="line">簇<span class="number"> 1 </span>指定使用核心个数 = 1</span><br></pre></td></tr></table></figure><blockquote><p>-1表示不做任何指定，默认启用所有核心</p></blockquote><h2 id="当前固定的频率"><a href="#当前固定的频率" class="headerlink" title="当前固定的频率"></a>当前固定的频率</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/ppm/policy/ut_fix_freq_idx<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> freq<span class="title"> idx</span> = -1<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> freq<span class="title"> idx</span> = -1</span><br></pre></td></tr></table></figure><ul><li>输出解析：</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">簇<span class="number"> 0 </span>指定频点索引 = -1</span><br><span class="line">簇<span class="number"> 1 </span>指定频点索引 = 0</span><br></pre></td></tr></table></figure><blockquote><p>-1表示不做任何指定，系统会由调频管理程序自动根据当前工作负载选择合适的档位</p></blockquote><blockquote><p>数字不为-1时忽略调度程序，指定要求该簇（簇中的全部核心）工作到指定档位（但是可能被优先级更高的调度程序、设置、温度&#x2F;功耗策略影响）</p></blockquote><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>ppm/policy</span><br></pre></td></tr></table></figure><h2 id="开关CPU核心个数"><a href="#开关CPU核心个数" class="headerlink" title="开关CPU核心个数"></a>开关CPU核心个数</h2><p>开、关掉一些CPU核心。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">2</span> <span class="number">1</span> &gt; /<span class="keyword">proc</span>/ppm/policy/ut_fix_core_num<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">cat</span> /<span class="keyword">proc</span>/ppm/policy/ut_fix_core_num<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> core<span class="title"> num</span> = 2<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> core<span class="title"> num</span> = 1</span><br></pre></td></tr></table></figure><ul><li>效果，小核簇(簇0)之CPU2、3下线，大核簇(簇1)之CPU5、6、7下线：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> /sys/devices/system/cpu/online</span><br><span class="line"><span class="attribute">0</span>-<span class="number">1</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Mem</span>: <span class="number">1555028</span>K used, <span class="number">2402960</span>K free, <span class="number">0</span>K shrd, <span class="number">4040146952</span>K buff, <span class="number">1432</span>K cached</span><br><span class="line"><span class="attribute">CPU0</span>: <span class="number">76</span>.<span class="number">1</span>% usr <span class="number">23</span>.<span class="number">8</span>% sys  <span class="number">0</span>.<span class="number">0</span>% nic  <span class="number">0</span>.<span class="number">0</span>% idle  <span class="number">0</span>.<span class="number">0</span>% io  <span class="number">0</span>.<span class="number">0</span>% irq  <span class="number">0</span>.<span class="number">0</span>% sirq</span><br><span class="line"><span class="attribute">CPU1</span>: <span class="number">88</span>.<span class="number">5</span>% usr <span class="number">11</span>.<span class="number">4</span>% sys  <span class="number">0</span>.<span class="number">0</span>% nic  <span class="number">0</span>.<span class="number">0</span>% idle  <span class="number">0</span>.<span class="number">0</span>% io  <span class="number">0</span>.<span class="number">0</span>% irq  <span class="number">0</span>.<span class="number">0</span>% sirq</span><br><span class="line"><span class="attribute">CPU2</span>: <span class="number">98</span>.<span class="number">8</span>% usr  <span class="number">1</span>.<span class="number">1</span>% sys  <span class="number">0</span>.<span class="number">0</span>% nic  <span class="number">0</span>.<span class="number">0</span>% idle  <span class="number">0</span>.<span class="number">0</span>% io  <span class="number">0</span>.<span class="number">0</span>% irq  <span class="number">0</span>.<span class="number">0</span>% sirq</span><br><span class="line"><span class="attribute">Load</span> average: <span class="number">28</span>.<span class="number">04</span> <span class="number">26</span>.<span class="number">40</span> <span class="number">24</span>.<span class="number">93</span> <span class="number">7</span>/<span class="number">1432</span> <span class="number">12912</span></span><br></pre></td></tr></table></figure><blockquote><p>echo送入的数字个数取决于处理器具有多少个簇（Cluster），一般大+小核处理器为2，超大+大+小核处理器为3。</p></blockquote><ul><li>设置为-1恢复默认</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -<span class="number">1</span> -<span class="number">1</span> &gt; <span class="regexp">/proc/</span>ppm<span class="regexp">/policy/u</span>t_fix_core_num</span><br></pre></td></tr></table></figure><ul><li>命令解析：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 簇<span class="number">0</span>允许使用的核心数 簇<span class="number">1</span>允许使用的核心数 &gt; <span class="regexp">/proc/</span>ppm<span class="regexp">/policy/u</span>t_fix_core_num</span><br></pre></td></tr></table></figure><h2 id="定频"><a href="#定频" class="headerlink" title="定频"></a>定频</h2><p>定频，固定CPU频率（频点），固定到具体档位。频率的档位，即频点，为OPP index，故固定频率实际上是强制将CPU挂至对应的各个index。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> <span class="number">-1</span> &gt; /<span class="keyword">proc</span>/ppm/policy/ut_fix_freq_idx<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">cat</span> /<span class="keyword">proc</span>/ppm/policy/ut_fix_freq_idx<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> freq<span class="title"> idx</span> = 0<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> freq<span class="title"> idx</span> = -1</span><br></pre></td></tr></table></figure><ul><li>命令解析：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 簇<span class="number">0</span>档位 簇<span class="number">1</span>档位 &gt; <span class="regexp">/proc/</span>ppm<span class="regexp">/policy/u</span>t_fix_freq_idx</span><br></pre></td></tr></table></figure><ul><li>效果，命令要求将簇0（小核簇）内的所有CPU运行在最高频率：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/devices/system/cpu/cpu[<span class="number">0</span>-<span class="number">7</span>]/cpufreq/cpuinfo_cur_freq | xargs cat</span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1248000</span></span><br><span class="line"><span class="number">1248000</span></span><br><span class="line"><span class="number">1248000</span></span><br><span class="line"><span class="number">1248000</span></span><br></pre></td></tr></table></figure><blockquote><p>可见，簇0的所以CPU（CPU0-4）全部工作在最高频率</p></blockquote><h2 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h2><p>将指定的进程绑定到一个或一些CPU上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskset -ap <span class="attribute">MASK</span> PID</span><br><span class="line"></span><br><span class="line">taskset -<span class="selector-tag">p</span> <span class="attribute">MASK</span> PID</span><br></pre></td></tr></table></figure><h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel-<span class="number">4.14</span><span class="regexp">/drivers/mi</span>sc<span class="regexp">/mediatek/</span>base<span class="regexp">/power/</span>ppm_v3/src</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum mt_cpu_dvfs_id &#123;</span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_LL,</span></span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_L,</span></span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_B,</span></span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_CCI,</span></span><br><span class="line"><span class="built_in">        NR_MT_CPU_DVFS,</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">enum mt_dvfs_debug_id &#123;</span><br><span class="line"><span class="built_in">        DEBUG_FREQ_CLUSTER0,</span></span><br><span class="line"><span class="built_in">        DEBUG_FREQ_CLUSTER1,</span></span><br><span class="line"><span class="built_in">        DEBUG_FREQ_CLUSTER2,</span></span><br><span class="line"><span class="built_in">        DEBUG_FREQ_ALL,</span></span><br><span class="line">        DEBUG_FREQ_DISABLED = <span class="number">100</span>,</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>cpufreq_freq proc节点</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cpufreq_freq_proc_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">cpufreq_freq_proc_write</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>cpufreq_oppidx proc节点</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mtk_cpufreq_interface<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cpufreq_oppidx_proc_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">cpufreq_oppidx_proc_write</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>定频、核数开关</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mtk_ppm_policy_ut</span><span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line"># 核数</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_core_num_proc_show</span>()</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_core_num_proc_write</span>()</span><br><span class="line"></span><br><span class="line"># 定频：读取设置、更新设置</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_freq_idx_proc_show</span>()</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_freq_idx_proc_write</span>()</span><br></pre></td></tr></table></figure><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>DVFS</td><td>Dynamic Voltage and Frequency Scaling 通过调整CPU频率、电压来匹配工作负载，取得节能目的的技术</td></tr><tr><td>freq</td><td>Frequency 频率</td></tr><tr><td>OPP</td><td>Operating Performance Points 频点、频率档位</td></tr><tr><td>PPM</td><td>Power Policy Manager</td></tr><tr><td>oppidx</td><td>OPP的Index 各档位的频率对应为一个index， 0对应最高频率</td></tr><tr><td>LL</td><td>小核</td></tr><tr><td>L</td><td>大核</td></tr><tr><td>B</td><td>超大核</td></tr><tr><td>Jade</td><td>BIG.LITTLE架构的CPU（大小端模式）</td></tr><tr><td>Everest</td><td>小核-大核-超大核架构的CPU</td></tr><tr><td>Olympus</td><td>小核-大核架构的CPU</td></tr><tr><td>Cluster</td><td>CPU簇；CPU的几个核心在同一簇中管理，一个CPU可能有多个簇，一般将效能核、性能核、超大核分别分入一个簇中</td></tr></tbody></table><h1 id="调频策略"><a href="#调频策略" class="headerlink" title="调频策略"></a>调频策略</h1><table><thead><tr><th>策略名称</th><th>说明</th></tr></thead><tbody><tr><td>performance</td><td>运行于最大频率</td></tr><tr><td>powersave</td><td>运行于最小频率</td></tr><tr><td>userspace</td><td>运行于用户指定的频率</td></tr><tr><td>ondemand</td><td>按需快速动态调整CPU频率， 一有cpu计算量的任务，就会立即达到最大频率运行; 空闲时间占比增加则降低频率</td></tr><tr><td>conservative</td><td>按需快速动态调整CPU频率，比 ondemand 的调整更保守，不会迅速达到最大频率</td></tr><tr><td>schedutil</td><td>由调度程序管理</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;9:51 am&lt;br&gt;Thursday, 3 November 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96&quot;&gt;获取&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>紫光展锐展讯SPRD刷机包pac文件解包提取img步骤</title>
    <link href="https://nasdaqgodzilla.github.io/2022/10/10/%E7%B4%AB%E5%85%89%E5%B1%95%E9%94%90%E5%B1%95%E8%AE%AFSPRD%E5%88%B7%E6%9C%BA%E5%8C%85pac%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8F%96img%E6%AD%A5%E9%AA%A4/"/>
    <id>https://nasdaqgodzilla.github.io/2022/10/10/%E7%B4%AB%E5%85%89%E5%B1%95%E9%94%90%E5%B1%95%E8%AE%AFSPRD%E5%88%B7%E6%9C%BA%E5%8C%85pac%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8F%96img%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-10-10T02:24:35.000Z</published>
    <updated>2022-10-10T02:28:10.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UNISOC-SPRD-PAC-UNPAC"><a href="#UNISOC-SPRD-PAC-UNPAC" class="headerlink" title="UNISOC_SPRD_PAC_UNPAC"></a>UNISOC_SPRD_PAC_UNPAC</h1><p>紫光展锐展讯SPRD刷机包pac文件解包提取img文件。</p><p>Extract Images from .pac file from Spreadtrum Unisoc SPRD.</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><ol><li>pac文件 *1</li><li><code>Perl</code>环境</li></ol><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>展锐官方自带一套分别用Python和Perl实现的将各img打包为pac文件的工具，也实现了对应的解包工具。其中，<code>pac_tools/unpac_perl/unpac.pl</code>是<code>Perl</code>实现的解包工具，能将pac文件中的各img提取出来。</p><p>下载：<a href="https://github.com/NasdaqGodzilla/UNISOC_SPRD_PAC_UNPAC">地址</a>（Clone源码或下载Release包）</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>请根据系统权限机制确保unpac.pl具有执行权限</li><li>第一个参数为需要提取的pac文件</li><li>第二个参数为提取产物的存储路径</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/pac_tools/u</span>npac_perl<span class="regexp">/unpac.pl ROM/y</span>our_pac_file.pac pac_unpac_path/</span><br></pre></td></tr></table></figure><h2 id="添加-S参数加快提取"><a href="#添加-S参数加快提取" class="headerlink" title="添加-S参数加快提取"></a>添加-S参数加快提取</h2><p><code>unpac.pl</code>在提取之前会校验pac文件的完整性。它非常耗时，可以在命令的最后追加<code>-S</code>跳过CRC校验。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/pac_tools/u</span>npac_perl<span class="regexp">/unpac.pl ROM/y</span>our_pac_file.pac pac_unpac_path/ -S</span><br></pre></td></tr></table></figure><ul><li>注意，-S参数必须放在最后面，不能放置️前两个参数之前</li></ul><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>在命令的最后添加参数<code>-D</code>要求<code>unpac.pl</code>打印调试信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UNISOC-SPRD-PAC-UNPAC&quot;&gt;&lt;a href=&quot;#UNISOC-SPRD-PAC-UNPAC&quot; class=&quot;headerlink&quot; title=&quot;UNISOC_SPRD_PAC_UNPAC&quot;&gt;&lt;/a&gt;UNISOC_SPRD_PAC_UNPAC&lt;/</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>记一次带宽压榨：多线多拨（多WAN口）实现网络性能改善</title>
    <link href="https://nasdaqgodzilla.github.io/2022/09/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B8%A6%E5%AE%BD%E5%8E%8B%E6%A6%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E5%A4%9A%E6%8B%A8%EF%BC%88%E5%A4%9AWAN%E5%8F%A3%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%94%B9%E5%96%84/"/>
    <id>https://nasdaqgodzilla.github.io/2022/09/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B8%A6%E5%AE%BD%E5%8E%8B%E6%A6%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E5%A4%9A%E6%8B%A8%EF%BC%88%E5%A4%9AWAN%E5%8F%A3%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%94%B9%E5%96%84/</id>
    <published>2022-09-30T10:51:06.000Z</published>
    <updated>2022-09-30T10:52:37.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当谈及上网体验时，总是会涉及网络性能优化的探索。</p><p>其中，对于提升网速这一块，最直接最有效的莫过于增加带宽、增加物理链路来实现更大更快的网络网络流量。通常在家庭场景、商业场景会向ISP订购更多的宽带服务，通过<code>单线多拨</code>、<code>多线多拨</code>机制实现「网速叠加」。</p><p>而对于办公场景等具有多层交换机、NAT内网的环境而言，网速优化的首要目标不是增加更多的链路，而是<strong>「避开内网网速限制」和「压榨内网带宽」</strong>，让内网终端能够最大化利用内网出口带宽。</p><p>本文讨论「多WAN口」实现内网带宽压榨，并亲测wan口数量带来的网速提升效果。</p><h1 id="多线多拨与单线多拨"><a href="#多线多拨与单线多拨" class="headerlink" title="多线多拨与单线多拨"></a>多线多拨与单线多拨</h1><p>在最舒服的理想状况下，路由器每一次拨号，便能从ISP获取一个 IP，运营商会分配对应的带宽，每个IP独立计算一个带宽大小。</p><p>将路由器的端口模拟成多个拨号端口（或者是，本来路由器就支持多端口拨号），多个端口分别拨号，成功连接的前提下，如果将网络通信分配到这些端口进行传输，那么实际上就实现了「网速叠加」。</p><blockquote><p>注意是在最舒服的状况下能实现：运营商支持&#x2F;套餐支持、猫支持、路由器支持、操作系统支持…</p></blockquote><p>单线多拨：实际上就是实现了多拨，但是“每个拨”的出口都是同一个链路（同一个宽带）</p><p>多线多拨：多拨，并且出口并不都是同一个链路（比如办理移动千兆+电信百兆两个套餐，配置双拨分别使用这两条宽带）</p><blockquote><p>多拨除了「网速叠加」以外，一大用途是作为链路备份。当某条链路故障时，多拨的其他链路可以维持正常服务，保证可用性。</p></blockquote><h1 id="多WAN口压榨带宽"><a href="#多WAN口压榨带宽" class="headerlink" title="多WAN口压榨带宽"></a>多WAN口压榨带宽</h1><p>对于办公场景，一个典型的网络架构就是「多层交换机+多层NAT」。通常，会带有流量控制、带宽配额。因此，对于存在网络瓶颈或网络加速需求的时候，「多拨将不是首要关注点（显然，首先过掉内网的网速限制，让自己分配到更多带宽才是重点）」。</p><p>事实上，一种常见的网速控制&#x2F;带宽分配方案就是按交换机客户端接入点来定额分配。在不「入侵计算机系统」的前提下，每个接入点的配额不能被随意修改。</p><p>按照多拨的思路，容易想到，如果上网终端能够<strong>同时连接交换机的多个端口，再像多拨一样将流量分配到这些端口上</strong>，即可实现和多拨原理一样的「网速叠加」。</p><blockquote><p>事实上是最大带宽叠加，每条链路本身的速度还是固定不变的。它不能让一个小的数据包传输的更快。</p></blockquote><p>实现这一方案（同时连接到交换机的多个端口上）对软件（路由器软件或操作系统）来说是已经就绪可行的（都已实现）。对于硬件也有要求，即使用的路由器（用来通过网线连接到交换机的）必须支持「多WAN口」（便宜的家庭路由器通常只有一个WAN口）；或不使用路由器，上网终端直接通过多个自带的&#x2F;扩展的网口连接交换机。</p><blockquote><p>还有一些隐性的硬件要求，比如你必须有多根网线，并且要靠近交换机或老板在你的工位安装了多个网口（不然你怎么实现接入到交换机的多个口？）此外，上网终端配备的网卡必须是千兆网卡，否则实现多WAN口后网卡性能跟不上，还是会降级减速。</p></blockquote><p>小结：</p><ol><li>对于内网有带宽限制的场景，突破带宽限制成为第一关注点</li><li>类似多拨，上网终端通过多WAN口接入交换机，多个WAN口的带宽可以实现叠加，提高极限带宽，「变相绕路」避开了内网带宽配额</li><li>多WAN口有硬件条件——起码是实施条件</li></ol><blockquote><p>移动端有一种技术——iPhone的Wifi信号不佳时自动转数据、手游网络优化（Wifi卡顿时允许使用数据），这些实现了链路备份，并从技术上来说，可以（或已经）实现了「多拨」</p></blockquote><h1 id="环境、配置"><a href="#环境、配置" class="headerlink" title="环境、配置"></a>环境、配置</h1><p>在某个环境中尝试一下多WAN口的效果。</p><ul><li>工具：提供上网服务的交换机（有多个空余接入口）；该交换机单个接入口带宽在50~100M左右（测速数据，见下一节单WAN口，非ISP提供）</li><li>工具：路由器TL-WAR1208L（9口路由器，可以配置最大支持将其中4个口配置成WAN口）。在测试过程中，分别配置1～4个WAN口并连接到交换机进行测速</li><li>上网终端：Apple M1 Pro 2021 14寸，Chrome 105，通过speedtest.cn测速。该终端通过雷雳接口连接一个绿联hub，引出网线连接路由器LAN口实现上网</li></ul><p>网络拓扑简单描述：终端-&gt;网线-&gt;路由器-&gt;（1～4根网线）连接交换机（1～4个接入口）</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>注意到上述我使用的路由器是最大支持4个WAN口。因此这里通过多个WAN口压榨带宽的极限就是4，下列分别是1～4个WAN口时的表现。</p><p>（不展示怎么配置多WAN口了，通常系统配置或路由器配置即可。）</p><ul><li>没有使用多WAN口（单WAN口）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%8D%95WAN%E5%8F%A3.png" alt="单WAN口"></p><ul><li>两个WAN口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%8F%8Cwan%E5%8F%A3.png" alt="双WAN口"></p><ul><li>三个WAN口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E4%B8%89wan%E5%8F%A3.png" alt="三WAN口"></p><ul><li>四个WAN口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%9B%9Bwan%E5%8F%A3.png" alt="四WAN口"></p><p>可以看到，多WAN口带来的测速成绩（极限带宽）提升很明显。<strong>在1、2、3个WAN口的情况下，随着WAN口数量提升，测速成绩也不断攀升</strong>。</p><p>但是，当WAN口数量到第4个的时候，测速成绩反而下降了。<strong>这提示一个违反常理的结果：明显带宽提高了，测速成绩却更低了？</strong>虽然没有找到根本原因，但从对路由器性能参数的观察发现，<strong>四WAN口同时启用，可能对路由器CPU带来了较大压力，不堪重负的CPU在更多WAN口的调度压力下表现更差了</strong>。因此，多WAN口配置还需要考虑硬件&#x2F;软件性能，一味提高链路带宽不一定保证提高实际的最大带宽。</p><blockquote><p>其实来到「三WAN口」已经能“睥睨”出一点路由器性能瓶颈了。带宽叠加的结果一般都是测速翻倍（注意是测速，没说你打开网页也翻倍）。但是可以看到，双WAN比单WAN的下载速度刚好翻倍，而三WAN则没有对双WAN有翻倍的效果了——实际上这里就是因为路由器性能没跟上，发挥不出来三WAN的完整带宽了（到了四WAN由于调度工作拖累，反而更差了）。</p></blockquote><p>总结：</p><ol><li>多拨、多WAN口有机会优化网络访问速度，还有链路备份功能、高可用功能</li><li>多拨、多WAN口需要硬件支持</li><li>链路带宽一定程度上受制于路由器性能，可能出现带宽提高反而测速降低的现象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;当谈及上网体验时，总是会涉及网络性能优化的探索。&lt;/p&gt;
&lt;p&gt;其中，对于提升网速这一块，最直接最有效的莫过于增加带宽、增加物理链路来实现更</summary>
      
    
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android SystemWebview Chromoum源码拉取与编译</title>
    <link href="https://nasdaqgodzilla.github.io/2022/08/17/Android-SystemWebview-Chromoum%E6%BA%90%E7%A0%81%E6%8B%89%E5%8F%96%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    <id>https://nasdaqgodzilla.github.io/2022/08/17/Android-SystemWebview-Chromoum%E6%BA%90%E7%A0%81%E6%8B%89%E5%8F%96%E4%B8%8E%E7%BC%96%E8%AF%91/</id>
    <published>2022-08-17T03:44:37.000Z</published>
    <updated>2022-08-29T11:29:39.195Z</updated>
    
    <content type="html"><![CDATA[<hr><p>2:52 pm<br>Monday, 15 August 2022 (HKT)<br>Time in Hong Kong</p><hr><h1 id="拉取步骤"><a href="#拉取步骤" class="headerlink" title="拉取步骤"></a>拉取步骤</h1><h2 id="拉取depot-tools"><a href="#拉取depot-tools" class="headerlink" title="拉取depot_tools"></a>拉取depot_tools</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//</span>chromium.googlesource.com<span class="regexp">/chromium/</span>tools/depot_tools.git</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">&quot;<span class="variable">$PATH</span>:/path/to/depot_tools&quot;</span></span><br></pre></td></tr></table></figure><h2 id="拉取Android-Chromium源码"><a href="#拉取Android-Chromium源码" class="headerlink" title="拉取Android Chromium源码"></a>拉取Android Chromium源码</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="string">/chromium</span> &amp;&amp; <span class="keyword">cd</span> <span class="string">/chromium</span></span><br></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">fetch</span> --<span class="comment">nohooks</span> --<span class="comment">no</span><span class="literal">-</span><span class="comment">history</span> <span class="comment">android</span></span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="keyword">sync</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来继续之前，额外一个可选步骤：切换到指定版本（查阅“切换到指定版本”节）</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">.<span class="regexp">/build/i</span>nstall-build-deps-android.sh</span><br><span class="line">gclient runhooks</span><br></pre></td></tr></table></figure><p>代码拉取完成。</p><h2 id="可选-查看当前版本"><a href="#可选-查看当前版本" class="headerlink" title="(可选)查看当前版本"></a>(可选)查看当前版本</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> src</span><br><span class="line"><span class="keyword">cat</span> chrome/<span class="keyword">VERSION</span></span><br></pre></td></tr></table></figure><h2 id="可选-切换到指定版本"><a href="#可选-切换到指定版本" class="headerlink" title="(可选)切换到指定版本"></a>(可选)切换到指定版本</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> src</span><br><span class="line"><span class="attribute">git</span> fetch origin <span class="number">74</span>.<span class="number">0</span>.<span class="number">3729</span>.<span class="number">186</span></span><br><span class="line"><span class="attribute">git</span> checkout -b <span class="number">74</span>.<span class="number">0</span>.<span class="number">3729</span>.<span class="number">186</span> FETCH_HEAD</span><br><span class="line"><span class="attribute">gclient</span> sync --with_branch_heads -D</span><br></pre></td></tr></table></figure><h2 id="（用于平时更新代码）同步一下代码"><a href="#（用于平时更新代码）同步一下代码" class="headerlink" title="（用于平时更新代码）同步一下代码"></a>（用于平时更新代码）同步一下代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="keyword">sync</span></span><br></pre></td></tr></table></figure><h1 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h1><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gn</span> gen out/Release --<span class="built_in">args</span>=&#x27;target_os=<span class="string">&quot;android&quot;</span> is_debug=<span class="literal">false</span> is_official_build=<span class="literal">true</span> enable_nacl=<span class="literal">false</span> is_chrome_branded=<span class="literal">false</span> use_official_google_api_keys=<span class="literal">false</span> enable_resource_whitelist_generation=<span class="literal">true</span> ffmpeg_branding=<span class="string">&quot;Chrome&quot;</span> proprietary_codecs=<span class="literal">true</span> enable_remoting=<span class="literal">true</span>&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out<span class="regexp">/Release/</span> system_webview_apk -j32</span><br></pre></td></tr></table></figure><blockquote><p>或者使用autoninja进行编译：</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>ninja -C <span class="keyword">out</span>/Release/ system_webview_apk </span><br></pre></td></tr></table></figure><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="Error-Could-not-create-the-Java-Virtual-Machine"><a href="#Error-Could-not-create-the-Java-Virtual-Machine" class="headerlink" title="Error: Could not create the Java Virtual Machine."></a>Error: Could not create the Java Virtual Machine.</h2><p>编译需要JDK，而且是特定版本的JDK（截至目前要求JDK 8）</p><p>JDK版本是可以动态切换的，查看（并修改）JDK版本：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config java  </span></span><br><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config javac</span></span><br></pre></td></tr></table></figure><blockquote><p>根据提示输入数字，选择jdk 8即可</p></blockquote><p>命令输出长得像下面这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="number">2</span> choices <span class="keyword">for</span> the alternative java (providing <span class="regexp">/usr/</span>bin/java).</span><br><span class="line"></span><br><span class="line">  Selection    Path                                            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* <span class="number">0</span>            <span class="regexp">/usr/</span>lib<span class="regexp">/jvm/</span>java-<span class="number">11</span>-openjdk-amd64<span class="regexp">/bin/</span>java      <span class="number">1111</span>      auto mode</span><br><span class="line">  <span class="number">1</span>            <span class="regexp">/usr/</span>lib<span class="regexp">/jvm/</span>java-<span class="number">11</span>-openjdk-amd64<span class="regexp">/bin/</span>java      <span class="number">1111</span>      manual mode</span><br><span class="line">  <span class="number">2</span>            <span class="regexp">/usr/</span>lib<span class="regexp">/jvm/</span>java-<span class="number">8</span>-openjdk-amd64<span class="regexp">/jre/</span>bin/java   <span class="number">1081</span>      manual mode</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md">https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;2:52 pm&lt;br&gt;Monday, 15 August 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;拉取步骤&quot;&gt;&lt;a href=&quot;#拉取步骤&quot; class=&quot;headerlink&quot; title=&quot;拉取步骤&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Clash配置暴露代理服务</title>
    <link href="https://nasdaqgodzilla.github.io/2022/08/15/Clash%E9%85%8D%E7%BD%AE%E6%9A%B4%E9%9C%B2%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
    <id>https://nasdaqgodzilla.github.io/2022/08/15/Clash%E9%85%8D%E7%BD%AE%E6%9A%B4%E9%9C%B2%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-08-15T05:16:03.000Z</published>
    <updated>2022-08-29T11:29:39.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>通常在PC中启动了clash提供上网功能，需要将上网能力共享到WSL终端、Linux终端等不直接配置clash的场景中使用。</p><p>方案：使用clash内建的LAN mode、Linux&#x2F;WSL等提供的代理功能。</p><h1 id="1-clash启动代理服务"><a href="#1-clash启动代理服务" class="headerlink" title="1. clash启动代理服务"></a>1. clash启动代理服务</h1><p>clash启动lan服务，并且记录下IP和端口。</p><p><img src="https://s2.loli.net/2022/08/15/47GSyevF5TZVh2A.png"></p><h1 id="2-终端配置代理"><a href="#2-终端配置代理" class="headerlink" title="2. 终端配置代理"></a>2. 终端配置代理</h1><p>配置代理仅需一行命令（注意生效范围是本终端）：</p><p><img src="https://s2.loli.net/2022/08/15/l2GXUTkQEYVFoxJ.png"></p><h1 id="3-测试代理"><a href="#3-测试代理" class="headerlink" title="3. 测试代理"></a>3. 测试代理</h1><p>下面命令可以检测代理是否生效。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="regexp">//myi</span>p.ipip.net/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;通常在PC中启动了clash提供上网功能，需要将上网能力共享到WSL终端、Linux终端等不直接配置clash的场景中使用。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
