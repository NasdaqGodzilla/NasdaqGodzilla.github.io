<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PeaceMaker</title>
  
  <subtitle>神在码先，绵绵不绝！</subtitle>
  <link href="https://nasdaqgodzilla.github.io/atom.xml" rel="self"/>
  
  <link href="https://nasdaqgodzilla.github.io/"/>
  <updated>2024-03-20T11:36:49.203Z</updated>
  <id>https://nasdaqgodzilla.github.io/</id>
  
  <author>
    <name>Niko aug3073911@outlook.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Emulator运行自定义的AOSP镜像</title>
    <link href="https://nasdaqgodzilla.github.io/2024/03/20/Android-Emulator%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84AOSP%E9%95%9C%E5%83%8F/"/>
    <id>https://nasdaqgodzilla.github.io/2024/03/20/Android-Emulator%E8%BF%90%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84AOSP%E9%95%9C%E5%83%8F/</id>
    <published>2024-03-20T10:11:01.000Z</published>
    <updated>2024-03-20T11:36:49.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>介绍在Mac上通过Android官方Emulator启动自己编译的AOSP模拟器镜像,实现自定义AOSP在Mac Android模拟器上的调试.</p><h1 id="Emulator准备"><a href="#Emulator准备" class="headerlink" title="Emulator准备"></a>Emulator准备</h1><p>直接下载官方的Emulator,这个模拟器用于启动AOSP编译出来的模拟器镜像</p><p>下载地址: <a href="https://github.com/google/android-emulator-m1-preview/releases">https://github.com/google/android-emulator-m1-preview/releases</a></p><h1 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h1><p>完成AOSP的编译,得到模拟器镜像.可以参考: <a href="https://nasdaqgodzilla.github.io/2024/03/20/%E5%9C%A8Apple-Mac-M1%E4%B8%8A%E7%BC%96%E8%AF%91AOSP-ARM-Android%E6%A8%A1%E6%8B%9F%E5%99%A8/">在Apple Mac M1上编译AOSP ARM Android模拟器</a>和<a href="https://nasdaqgodzilla.github.io/2024/03/19/%E6%8B%89%E5%8F%96%E5%B9%B6%E7%BC%96%E8%AF%91AOSP-Android-14%E6%A8%A1%E6%8B%9F%E5%99%A8/">拉取并编译AOSP Android 14模拟器</a></p><ol start="2"><li>打包镜像,可以参考:<a href="https://github.com/NasdaqGodzilla/aosp_image_pack">aosp_image_pack</a></li></ol><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ol><li>将打包好的镜像解压放入Mac Android Emulator目录<code>/Applications/Android Emulator.app/Contents/MacOS/</code></li></ol><blockquote><p>假设镜像解压到目录&#x2F;Applications&#x2F;Android Emulator.app&#x2F;Contents&#x2F;MacOS&#x2F;api30-gphone-arm64-v8a</p></blockquote><ol start="2"><li>选择镜像,启动模拟器</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PATH_EMULATOR</span>=<span class="string">&#x27;/Applications/Android Emulator.app/Contents/MacOS&#x27;</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ANDROID_PRODUCT_OUT</span>=<span class="string">&quot;<span class="variable">$PATH_EMULATOR</span>&quot;</span>/api30-gphone-arm64-v8a</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ANDROID_BUILD_TOP</span>=<span class="variable">$ANDROID_PRODUCT_OUT</span></span><br><span class="line"><span class="variable">$PATH_EMULATOR</span>/emulator/emulator</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;介绍在Mac上通过Android官方Emulator启动自己编译的AOSP模拟器镜像,实现自定义AOSP在Mac Android模拟器上的调</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在Apple Mac M1上编译AOSP ARM Android模拟器</title>
    <link href="https://nasdaqgodzilla.github.io/2024/03/20/%E5%9C%A8Apple-Mac-M1%E4%B8%8A%E7%BC%96%E8%AF%91AOSP-ARM-Android%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://nasdaqgodzilla.github.io/2024/03/20/%E5%9C%A8Apple-Mac-M1%E4%B8%8A%E7%BC%96%E8%AF%91AOSP-ARM-Android%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2024-03-20T08:43:32.000Z</published>
    <updated>2024-03-20T09:59:47.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>旨在让你能在Mac上运行可自行定制的模拟器和Android系统.</p><p>分两个部分,分别编译模拟器emulator和AOSP模拟器镜像, 其中以Android 14为例.</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="DepotTools"><a href="#DepotTools" class="headerlink" title="DepotTools"></a>DepotTools</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//</span>chromium.googlesource.com<span class="regexp">/chromium/</span>tools/depot_tools.git</span><br><span class="line">export PATH=<span class="regexp">/path/</span>to/depot_tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>显然你必须将&#x2F;path&#x2F;to&#x2F;depot_tools正确替换为实际路径</p></blockquote><blockquote><p>其中,export命令最好加到.bashrc中,让你的所有终端都能生效</p></blockquote><h2 id="拉取qemu源码并编译"><a href="#拉取qemu源码并编译" class="headerlink" title="拉取qemu源码并编译"></a>拉取qemu源码并编译</h2><p>用于将编译得到的镜像运行起来</p><p>注意:这一步可以跳过,因为AOSP源码自带一个emulator.如果你想研究emulator的实现才需要自行编译</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> emu</span><br><span class="line"><span class="keyword">cd</span> emu</span><br><span class="line">repo init -<span class="keyword">u</span> http<span class="variable">s:</span>//android.googlesource.<span class="keyword">com</span>/platform/external/qemu --depth=<span class="number">1</span></span><br><span class="line">repo <span class="keyword">sync</span> -qcj <span class="number">4</span></span><br><span class="line"><span class="keyword">cd</span> external/qemu</span><br><span class="line"><span class="keyword">python</span> android/build/<span class="keyword">python</span>/cmake.<span class="keyword">py</span> --target=darwin_aarch64</span><br></pre></td></tr></table></figure><blockquote><p>如果repo init有问题,可以改用git.可以切到一个稳定的分支,如aosp-emu-30-release</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//</span>android.googlesource.com<span class="regexp">/platform/</span>external/qemu</span><br></pre></td></tr></table></figure><p>其中,emu的源码在这,感兴趣可以研究</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>android.googlesource.com<span class="regexp">/platform/</span>external<span class="regexp">/qemu/</span>+<span class="regexp">/refs/</span>heads/emu-master-dev</span><br></pre></td></tr></table></figure><ul><li>最后一个python命令会进行大量target的初始化.当你看到终端输出表明编译已经开始了,那么终止这个编译,直接用如下这个命令能让你编译更快</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C objs <span class="keyword">install</span>/strip</span><br></pre></td></tr></table></figure><p>编译产物:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/path/</span>to<span class="regexp">/external/</span>qemu<span class="regexp">/objs/</span>distribution/emulator</span><br></pre></td></tr></table></figure><p>签名:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="keyword">sign</span>-objs-binaries.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>这一步将编译得到的emulator及其相关产物进行签名</p></blockquote><h2 id="编译Android"><a href="#编译Android" class="headerlink" title="编译Android"></a>编译Android</h2><p>编译Android比较麻烦.因为Mac的文件系统并不区分大小写…并不兼容AOSP.</p><p>因此,请在Linux下编译AOSP</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mkdir</span> aosp<span class="number">14</span></span><br><span class="line"><span class="attribute">cd</span> aosp<span class="number">14</span></span><br><span class="line"><span class="attribute">repo</span> init -u https://android.googlesource.com/platform/manifest -b android-<span class="number">14</span>.<span class="number">0</span>.<span class="number">0</span>_r<span class="number">20</span> --depth=<span class="number">1</span></span><br><span class="line"><span class="attribute">repo</span> sync -qcj <span class="number">4</span></span><br></pre></td></tr></table></figure><p>把这个patch打到<code>build/make/target/board/emulator_arm64/BoardConfig.mk</code>,移除32位支持: <a href="https://android-review.googlesource.com/c/platform/build/+/1518218">https://android-review.googlesource.com/c/platform/build/+/1518218</a></p><p>启动编译:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> build/envsetup.<span class="keyword">sh</span></span><br><span class="line">lunch sdk_phone_arm64-userdebug</span><br><span class="line"><span class="keyword">make</span> -j12</span><br></pre></td></tr></table></figure><blockquote><p>其中,lunch的target有平板:sdk_tablet_x86_64, GooglePhone: sdk_gphone_arm64; 当然,它们都可以添加’-userdebug’</p></blockquote><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>把产物打包到zip，放到Mac下面<code>/Applications/Android\ Emulator.app/Contents/MacOS/aosp-master-arm64-v8a/</code></p><blockquote><p>其中,产物打包脚本如下</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ANDROID_PRODUCT_OUT</span></span><br><span class="line">export ZIPPED_NAME=<span class="variable">$1</span></span><br><span class="line">mkdir <span class="literal">-p</span> <span class="variable">$ZIPPED_NAME</span>/files</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$ZIPPED_NAME</span>/files</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/system<span class="literal">-qemu</span>.img system.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/vendor.img vendor.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/ramdisk.img ramdisk.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/ramdisk.img ramdisk.img</span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/<span class="type">kernel</span>-<span class="type">ranchu</span>-<span class="number">64</span> ]; then</span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/kernel<span class="literal">-ranchu</span><span class="literal">-64</span> kernel<span class="literal">-ranchu</span><span class="literal">-64</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/kernel<span class="literal">-ranchu</span> kernel<span class="literal">-ranchu</span></span><br><span class="line">fi;</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/<span class="keyword">data</span> .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/advancedFeatures.ini advancedFeatures.ini</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/userdata.img .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/encryptionkey.img .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/build.prop .</span><br><span class="line">mkdir system</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/build.prop system/build.prop</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/VerifiedBootParams.textproto .</span><br><span class="line"><span class="built_in">cp</span> <span class="literal">-r</span> <span class="variable">$ANDROID_PRODUCT_OUT</span>/source.properties .</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">zip <span class="literal">-1rq</span> <span class="variable">$ZIPPED_NAME</span>.zip files</span><br><span class="line"><span class="built_in">ls</span> <span class="literal">-l</span> <span class="variable">$ZIPPED_NAME</span>.zip</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>直接打开Mac中emulator应用的图标,或者敲命令:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Android Emulator.app<span class="regexp">/Contents/</span>MacOS<span class="regexp">/emulator/</span>emulator -avd foo</span><br></pre></td></tr></table></figure><blockquote><p>其中-avd是设备名称</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;旨在让你能在Mac上运行可自行定制的模拟器和Android系统.&lt;/p&gt;
&lt;p&gt;分两个部分,分别编译模拟器emulator和AOSP模拟器镜</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="虚拟化" scheme="https://nasdaqgodzilla.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>拉取并编译AOSP Android 14模拟器</title>
    <link href="https://nasdaqgodzilla.github.io/2024/03/19/%E6%8B%89%E5%8F%96%E5%B9%B6%E7%BC%96%E8%AF%91AOSP-Android-14%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://nasdaqgodzilla.github.io/2024/03/19/%E6%8B%89%E5%8F%96%E5%B9%B6%E7%BC%96%E8%AF%91AOSP-Android-14%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2024-03-19T06:33:46.000Z</published>
    <updated>2024-03-20T06:32:53.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">repo</span> init -u https://android.googlesource.com/platform/manifest -b android-<span class="number">14</span>.<span class="number">0</span>.<span class="number">0</span>_r<span class="number">20</span></span><br><span class="line"><span class="attribute">repo</span> sync</span><br></pre></td></tr></table></figure><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> .<span class="regexp">/build/</span>envsetup.sh</span><br><span class="line">lunch sdk_phone_x86_64</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>当想要编译平板镜像时</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lunch</span> sdk_tablet_x<span class="number">86</span>_<span class="number">64</span></span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">emulator</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拉取&quot;&gt;&lt;a href=&quot;#拉取&quot; class=&quot;headerlink&quot; title=&quot;拉取&quot;&gt;&lt;/a&gt;拉取&lt;/h1&gt;&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android bpf简单上手教程</title>
    <link href="https://nasdaqgodzilla.github.io/2023/08/23/Android-bpf%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B/"/>
    <id>https://nasdaqgodzilla.github.io/2023/08/23/Android-bpf%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B/</id>
    <published>2023-08-23T12:10:37.000Z</published>
    <updated>2023-08-23T12:16:29.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>业界对Android的性能监控、hook、系统分析、抓包、逆向等领域的关注和投入在不断提升，作为Linux Kernel中新兴的优美的一套技术框架，bpf逐渐在Android中被用于监控、分析、优化和逆向，产出了众多的工具。此外，Google原生系统的上层服务（如网络流量统计、网络黑白名单）也转向使用ebpf来实现。</p><p>bpf可以理解成Kernel的虚拟机字节码，它借助C语言编译成特定的ELF，通过专用的系统调用注册到Kernel，挂载到指定的tracepoint，进行代码流程的hook，与App的插桩、性能优化的检查点非常类似。</p><p>本文以Android源码AOSP为基础，讲解一个bpf程序应该如何被编译、集成到系统、在系统中启动&#x2F;运行，并使用C语言编写了一个可以实际运行的bpf程序（<a href="https://github.com/NasdaqGodzilla/cpuprobe%EF%BC%89%E3%80%82">https://github.com/NasdaqGodzilla/cpuprobe）。</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>常规的C语言bpf程序需要编译为Kernel BPF子系统能够识别的专用字节码，Android采用了一套独特的编译系统（Android.bp）来包装包含bpf程序在内的编译流程。</p><p>一个最简单的bpf编译描述如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">bpf </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">&quot;cpu_stats.o&quot;</span>,</span><br><span class="line"><span class="symbol">    srcs:</span> [<span class="string">&quot;cpu_stats.c&quot;</span>],</span><br><span class="line"><span class="symbol">    cflags:</span> [</span><br><span class="line">        <span class="string">&quot;-Wall&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-Werror&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段写在Android.bp内的bpf代码声明了需要编译一个名称为cpu_stats.o的bpf程序，srcs指定了其源文件，cflags指定了向编译器传递的编译参数。</p><p>前面说过，一个bpf程序，从结构上说是一个elf，从逻辑上说是一个被Kernel BPF虚拟机加载后才能执行的字节码（类似JS解释器加载JS），因此它编译期间不会发生链接，不会产生可执行bin文件，也不能直接执行。</p><p>通过AOSP的模块编译指令即可编译：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">m</span> cpu_stats.o</span><br></pre></td></tr></table></figure><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>常规的bpf程序有多种集成方式，包括调用bpf()、通过python、bpftrace等（本质也是bpf()）调用。但出于安全和效率的原因，Android屏蔽了bpf()，仅提供了bpf loader在开机阶段加载预置的bpf程序，在开机后，系统就不能再加载任何bpf程序了。</p><p>bpf loader会加载存放在&#x2F;system&#x2F;etc&#x2F;bpf目录下的所有bpf程序，因此将我们编译出来的bpf程序放入该路径（或通过Android.bp、Android.mk等预置）即可让系统自动为我们加载我们的bpf程序：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">push</span> cpu_stats.o <span class="regexp">/system/</span>etc/bpf</span><br><span class="line">adb <span class="keyword">push</span> cpu_stats_client <span class="regexp">/system/</span>bin/</span><br></pre></td></tr></table></figure><p>这里我们还push了一个cpu_stats_client，稍后解释它的作用。<br>push后，重启设备，让Android自动加载这个bpf程序，加载成功的话日志大概长这样：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LibBpfLoader: Loading ELF object <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o with license GPL</span><br><span class="line">LibBpfLoader: Loaded code section <span class="number">3</span> (tracepoint_sched_sched_switch)</span><br><span class="line">LibBpfLoader: Loaded relo section <span class="number">3</span> (.reltracepoint<span class="regexp">/sched/</span>sched_switch)</span><br><span class="line">LibBpfLoader: Adding section <span class="number">3</span> to cs list</span><br><span class="line">LibBpfLoader: bpf_create_map name cpu_stats_map, ret: <span class="number">27</span></span><br><span class="line">LibBpfLoader: map_fd found at <span class="number">0</span> is <span class="number">27</span> in <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o</span><br><span class="line">LibBpfLoader: applying relo to instruction at <span class="keyword">byte</span> offset: <span class="number">144</span>,               insn offset <span class="number">18</span> , insn <span class="number">118</span></span><br><span class="line">LibBpfLoader: <span class="keyword">New</span> bpf core prog_load <span class="keyword">for</span> <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o (tracepoint_sched_sched_switch) returned: <span class="number">28</span></span><br><span class="line">bpfloader: Attempted load object: <span class="regexp">/system/</span>etc<span class="regexp">/bpf/</span>cpu_stats.o, ret: Success</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>系统启动时，会自动把上述目录的bpf程序交给内核进行加载。内核为了安全，会进行字节码分析，检测待加载的bpf程序是否带有Bug如越界、空指针、死循环等，以此来排除崩溃风险和恶意攻击。如果程序没有什么问题，就会成功加载。</p><p>加载成功的一个标志是，bpf程序定义的map（bpf的数据结构，稍后解释）会出现在指定目录下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local@device:<span class="regexp">/ # ls /</span>sys<span class="regexp">/fs/</span>bpf/map_cpu_stats_cpu_stats_map</span><br><span class="line"><span class="regexp">/sys/</span>fs<span class="regexp">/bpf/m</span>ap_cpu_stats_cpu_stats_map</span><br></pre></td></tr></table></figure><p>这个map由bpf程序在代码里面通过函数定义得到，当bpf程序hook命中时，Kernel会回调bpf程序，bpf程序通常将其业务逻辑中产生的需要存储的数据保存在这个map里面。这个map的两大主要作用，一是让bpf程序能够保存数据（因为bpf程序即不能使用内核的栈、堆，也不能使用被hook命中的应用程序的栈、堆），二是这个map可以让应用程序读取到，是一种bpf程序向应用程序进行通信的方式，bpf程序可以往这个map写东西，向用户态应用程序通信。</p><h1 id="程序解释"><a href="#程序解释" class="headerlink" title="程序解释"></a>程序解释</h1><p>从bpf程序本身的结构来看，bpf程序主要有两大部分组成：1. 指定的hook点以及这个hook点的处理函数，用于hook；2. 定义的bpf map，用于存储数据。</p><h2 id="执行hook并保存数据"><a href="#执行hook并保存数据" class="headerlink" title="执行hook并保存数据"></a>执行hook并保存数据</h2><ol><li>通过DEFINE_BPF_MAP来创建bpf map</li><li>通过SEC()来指定hook点，当kernel对应事件发生时，会回调SEC指定的函数</li><li>SEC指定的回调函数内执行hook逻辑，可以向bpf map读写数据，用于存储数据，或用于向用户态应用程序传递信息</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">DEFINE_BPF_MAP(<span class="params">cpu_stats_map</span>, LRU_HASH, CPU_STATS_BPFMAP_KEY, CPU_STATS_BPFMAP_VALUE, CPU_STATS_MAXENTRIES)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEFINE_BPF_PROG(&quot;tracepoint/sched/sched_switch&quot;, AID_ROOT, AID_NET_ADMIN, cpu_stats_tp_sched_switch) (struct switch_args* args) &#123;</span></span><br><span class="line"><span class="constructor">SEC(<span class="string">&quot;tracepoint/sched/sched_switch&quot;</span>)</span></span><br><span class="line"><span class="built_in">int</span> cpu<span class="constructor">_stats_tp_sched_switch(<span class="params">struct</span> <span class="params">switch_args</span><span class="operator">*</span> <span class="params">args</span>)</span> &#123;</span><br><span class="line">    CPU_STATS_BPFMAP_KEY ktime_ns = bpf<span class="constructor">_ktime_get_ns()</span>;</span><br><span class="line">    CPU_STATS_BPFMAP_VALUE record = &#123;</span><br><span class="line">        .ktime_ns = ktime_ns,</span><br><span class="line">        .smp_id = bpf<span class="constructor">_get_smp_processor_id()</span>,</span><br><span class="line">        .uid_gid = bpf<span class="constructor">_get_current_uid_gid()</span>,</span><br><span class="line">        .pid_tgid = bpf<span class="constructor">_get_current_pid_tgid()</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    memset(record.comm, <span class="character">&#x27;\0&#x27;</span>, sizeof(record.comm));</span><br><span class="line">    memcpy(record.comm, args-&gt;next_comm, sizeof(record.comm));</span><br><span class="line"></span><br><span class="line">    bpf<span class="constructor">_cpu_stats_map_update_elem(&amp;<span class="params">ktime_ns</span>, &amp;<span class="params">record</span>, BPF_ANY)</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> _license<span class="literal">[]</span> <span class="constructor">SEC(<span class="string">&quot;license&quot;</span>)</span> = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>前面“集成”小节里面示例命令有将一个cpu_stats_client push到&#x2F;system&#x2F;bin，实际上它就是用来读取数据的工具。</p><ol><li>通过bpf_obj_get()来取得bpf程序和bpf map的句柄（不是使用常规的fd open）</li><li>通过android::bpf::BpfMap来遍历bpf map里面的所有数据（Key-Value对）</li></ol><p>可以访问文章开头的Github链接查看完整代码</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>bpf提供了强大的功能，凭借数量众多的tracepoint和kprobe，绝大多数位置都能提供hook，在不修改内核的情况下能实现非常精彩的业务逻辑，在Android上必然能发挥重要作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;业界对Android的性能监控、hook、系统分析、抓包、逆向等领域的关注和投入在不断提升，作为Linux Kernel中新兴的优美的一套技</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="稳定性" scheme="https://nasdaqgodzilla.github.io/categories/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="稳定性" scheme="https://nasdaqgodzilla.github.io/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android BatteryStats服务功耗统计流程详解</title>
    <link href="https://nasdaqgodzilla.github.io/2023/06/17/Android-BatteryStats%E6%9C%8D%E5%8A%A1%E5%8A%9F%E8%80%97%E7%BB%9F%E8%AE%A1%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nasdaqgodzilla.github.io/2023/06/17/Android-BatteryStats%E6%9C%8D%E5%8A%A1%E5%8A%9F%E8%80%97%E7%BB%9F%E8%AE%A1%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-06-17T10:18:39.000Z</published>
    <updated>2023-06-17T10:27:37.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>BatteryStatsService和BatterStatsImpl是系统中用于估算电流消耗的关键对象，能够估算并存储软件功耗和硬件功耗。其中主要流程分为事件回调时记录耗电信息、触发读取时计算并统计耗电信息两大流程。本文介绍耗电信息的读取和统计过程。</p><h1 id="BatteryStatsService和BatteryStatsImpl"><a href="#BatteryStatsService和BatteryStatsImpl" class="headerlink" title="BatteryStatsService和BatteryStatsImpl"></a>BatteryStatsService和BatteryStatsImpl</h1><p>BatteryStatsService提供App和硬件的功耗，是通过BatteryStatsImpl的接口<code>getUidStats()</code>方法取得的，在分析该方法的流程前先简单介绍一些关键成员。</p><p>BatteryStatsHelper关键成员：</p><ol><li>BatterySipper：按照Uid和drain type来过滤存储的功耗记录，从BatteryStatsImpl中提取。可以理解为从系统记录的全部功耗信息中，按照Uid和Drain type提取出来。其中Drain type是耗电类型，如屏幕耗电、Wi-Fi耗电、App耗电等</li><li>mUsageList：以BatterySipper的形式记录各Uid的功耗</li><li>mWifiSippers、mBluetoothSippers：Wi-Fi、蓝牙专用的功耗记录（也是BatterySipper的形式）</li><li>mUserSippers：mUsageList只存储<code>refresh</code>方法传入的参数内的uid的耗电。当uid不在refresh方法指定的uid范围内时，不存储到mUsageList而是存储到这里</li><li>mMobilemsppList：各App的milliseconds per packets：各App的每个数据包的平均时间</li><li>mRawRealtimeUs mRawUptimeUs : refresh()调进来的传入的elapsed time和uptime</li><li>mBatteryUptimeUs mBatteryRealtimeUs mRaw*timeUs下当前battery*time</li><li>mTypeBatteryUptimeUs mTypeBatteryRealtimeUs：当前版本的Android只支持上一次充满电后的记录，因此等同于mBattery*timeUs</li><li>mBatteryTimeRemainingUs 根据上一次充满电后的掉电量&#x2F;掉电时间估算出来还需要多久用光电池</li><li>mChargeTimeRemainingUs 根据充电量&#x2F;充电时间估算出来的还需要多久充满电池</li><li>mMinDrainedPower mMaxDraingedPower 上次充电后的最小&#x2F;最大的一次掉电量范围</li><li>BatteryStatsImpl.TimeBase：拔掉电源、熄屏等各有一个TimeBase，封装了成员用于计算这些事件后的事件</li></ol><h2 id="BatteryStatsHelper-refreshStats：获取功耗记录主入口"><a href="#BatteryStatsHelper-refreshStats：获取功耗记录主入口" class="headerlink" title="BatteryStatsHelper.refreshStats：获取功耗记录主入口"></a>BatteryStatsHelper.refreshStats：获取功耗记录主入口</h2><p><code>refreshStats()</code>方法用于获取系统记录的耗电情况，流程如下。</p><ol><li>功耗记录是借助Binder从BatteryStatsService获取的：BatteryStatsService.getStats()-&gt;getActiveStatistics()获取BatteryStatsImpl（binder parcel传递）</li><li>调用processAppusage计算各Uid App的电耗</li><li>调用processMiscUsage()计算硬件功耗</li><li>计算mUsageList内记录的最高功耗到mMaxRealPower、mMaxPower</li><li>计算mUsageList内记录的各Uid的总功耗到mComputedPower、mTotalPower</li><li>根据mMinDrainedPower和mMaxDrainedPower，确定UNAACCOUNTED、OVERCOUNTED的电耗量，更新mTotalPower和mMaxPower，将over count和un count的电耗量加入到mUsageList中</li><li>进行电耗摊派。部分电耗属于系统需要隐藏的（shouldHideSipper），或者是要分摊给Uid们的。其中，要分摊的种类是需要隐藏的种类的子集，也就是说部分需要隐藏的电耗是不需要摊派的（或者之前已经摊派了，不用重复分摊）。其中屏幕功耗的分摊方式是，根据几个sipper的前台时间来算比例，根据前台时间的多少来承担对应比例的屏幕功耗，将屏幕功耗按前台时间分出去；承担了屏幕功耗的sipper会将自己分担的屏幕功耗记录到proportionalSmearMah，并调用sumPower()更新自己的总功耗</li><li>至此，详细功耗信息就记录到了mUsageList中了，通过BatteryStatsHelper.getUsageList()即可取得，遍历该集合的BatterySipper即可取得各uid的耗电记录</li></ol><h2 id="processAppUsage-：读取并按uid来计算App耗电"><a href="#processAppUsage-：读取并按uid来计算App耗电" class="headerlink" title="processAppUsage()：读取并按uid来计算App耗电"></a>processAppUsage()：读取并按uid来计算App耗电</h2><p>该方法根据uid和drain type来统计App的耗电情况。</p><ol><li>BatteryStatsImpl.getUsageStats()取得所有Uid，遍历processAppUsage()传入指定的需要统计的uid</li><li>创建BatterySipper；BatterySipper用于提取Uid里面指定消耗类型；因为Uid里面记录了App、硬件等不同类型的消耗，这里只统计App自己的消耗（排除硬件）；Sipper的作用其实就是从Uid里面提取Type对应的数据并存储下来</li><li>通过几大类的PowerCalculator.calculateApp()将Uid内的信息提取出来，进行计算，将数据存储进sipper</li><li>最后调用sipper.sumPower()将几大类的功耗全部加起来得到总功耗</li><li>接着当这个Uid sumpower &gt; 0时，就根据uid来添加到对应的sipper集合中。<ol><li>Wifi、蓝牙对应的Uid会独立存储在它们的特定的sipper集合</li><li>当该Uid不是processAppUsage()参数指定的要读取的uid时、且该UID是App的Uid（≥FISTST_APPLICATION_UID）时，存储到mUserSippers中</li><li>都不是时，存储到mUsageList这个sipper集合中</li><li>UID &#x3D;&#x3D; 0（ROOT）时，处理为uid为0的实体的Wakelock的功耗，相当于将uid为0的drain type为App的情况算作系统的唤醒功耗（设备唤醒的时间可能比屏幕亮起时间和应用程序唤醒锁定时间要长。如果可能，将此余数分配给操作系统）；记录到uid为0的drain type为app的记录时，表明应用可能都已经停止耗电，但系统还有服务或逻辑在运行，或进入睡眠前的一段间隔，这些内容会算作系统的功耗，并在Uid记录中体现</li></ol></li></ol><h3 id="PowerCalculator：9大耗电类别计算App耗电"><a href="#PowerCalculator：9大耗电类别计算App耗电" class="headerlink" title="PowerCalculator：9大耗电类别计算App耗电"></a>PowerCalculator：9大耗电类别计算App耗电</h3><p>PowerCalculator是abstract类，用于App的9大类别的耗电计算，分别为：CPU、WakeLock、移动网络、Wifi、蓝牙、传感器、摄像头、闪光灯、媒体：9大类。</p><p>主要方法：</p><ol><li>reset()：清除掉本计算器内的所有状态和数据</li><li>calculateApp(BatterySipper，BatteryStats.Uid，rawRealtimeUs，rawUptimeUs，statsType)：计算App在这个类别下消耗的电量；其中sipper用于从Uid提取对应的信息，可以理解成一个提供过滤能力的吸管，用于存储返回给调用者的信息，包括类型、uid、各项细节功耗值；real&#x2F;upTime：系统当前的real time和uptime；realtime就是linux系统记录的系统启动以来经过的时间，uptime是realtime去掉休眠的时间；statsType是如何统计，Android Q以后只有一种方式：从上一次充满电后开始的所有数据</li><li>calculateRemaining()，参数与calApp()完全一致；作用是当Uid内部记录的电量消耗不能全部算给App时，剩余的电量消耗</li></ol><h3 id="class-Uid"><a href="#class-Uid" class="headerlink" title="class Uid"></a>class Uid</h3><p>BatteryStats有个内部类<code>Uid</code>，它封装了各uid（应用、系统等）以及它们的运行时长、耗电信息、网络收发情况、CPU时间等等一切和功耗有关的信息。各个PowerCalculator基于这个对象内存储的数据来进行计算。</p><h3 id="CpuPowerCalculator：计算App消耗在CPU上的功耗"><a href="#CpuPowerCalculator：计算App消耗在CPU上的功耗" class="headerlink" title="CpuPowerCalculator：计算App消耗在CPU上的功耗"></a>CpuPowerCalculator：计算App消耗在CPU上的功耗</h3><p>BatterySipper与CPU相关的主要是：cpuTimeMs、cpuFgTimeMs、cpuPowerMah、packageWithHighestDrain，CpuPowerCalculator主要就是读取并计算这些值，存储到上述sipper的这些成员中，最后存储到mUsageList或mUserSippers。</p><p>calculateApp：</p><ol><li>调用Uid的方法取得Uid记录的uid对应的CPU时间（分不同的cluster（簇，不同的簇，因大小核、架构而功耗不一样）、不同的CPU速度），将这些数据与power_profile.xml记录的硬件功耗相乘后相加，得到Uid在CPU上消耗的时间和电量。其中CPU电量的计算公式是：总电耗&#x3D;总CPU时间*CPU激活状态下的功耗 + 各频率运行时长*各频率对应额外运行功耗</li><li>一个uid可以有多个进程，Uid.Proc对象表示一个进程的唤醒时长等统计信息，同一个uid的进程的信息对应的若干Proc存储在Uid内的ArrayMap中；取得Uid内所有Proc的foreground time求和得到uid对应的总的cpuFdTimeMs，存入sipper；并总时间（user time、system time、fg time）最大的Proc存储到sipper的packageWithHighestDrain用于表示该Uid下CPU消耗最大的Proc</li></ol><p>calculateRemaining：空实现</p><h3 id="WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗"><a href="#WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗" class="headerlink" title="WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗"></a>WakeLockPowerCalculator：计算App持有唤醒锁的时间和功耗</h3><p>calculateApp:</p><ol><li>WakeLock专门存储于一个集合，用Uid.Wakelock表示，里面记录的Wake time取出后累加记录到sipper的wakeLockTimeMs</li><li>电量计算公式为：wakeLockTimeMs * CPU idle电耗</li></ol><p>calculateRemaining：</p><ol><li>calculateApp只统计了Uid自己的wakelock时长对应的电耗，当Uid内记录的电池时间大于sum(WakeLockTime + ScreenOnTime)时，大于的部分算作app wake，同样算入wakeLockTimeMs、及对应电耗</li></ol><h3 id="MobileRationPowerCalculator：计算App进行的移动网络射频功耗"><a href="#MobileRationPowerCalculator：计算App进行的移动网络射频功耗" class="headerlink" title="MobileRationPowerCalculator：计算App进行的移动网络射频功耗"></a>MobileRationPowerCalculator：计算App进行的移动网络射频功耗</h3><p>calculateApp：根据App收发的数据包数量结合power_profile计算电耗</p><p>calculateRemaining：根据信号强度、扫描次数结合power_profile计算电耗</p><h3 id="WifiPowerCalculator：计算App进行的Wifi收发功耗"><a href="#WifiPowerCalculator：计算App进行的Wifi收发功耗" class="headerlink" title="WifiPowerCalculator：计算App进行的Wifi收发功耗"></a>WifiPowerCalculator：计算App进行的Wifi收发功耗</h3><p>calculateApp：根据收发时长、空闲时长结合power_profile计算电耗；获取Uid存储的收发字节数、数据包数量存储到sipper</p><h3 id="MediaPowerCalculator：计算App音视频功耗"><a href="#MediaPowerCalculator：计算App音视频功耗" class="headerlink" title="MediaPowerCalculator：计算App音视频功耗"></a>MediaPowerCalculator：计算App音视频功耗</h3><p>calculateApp：Audio、Video时长*对应功耗得出电耗</p><h2 id="processMiscUsage-：统计硬件功耗"><a href="#processMiscUsage-：统计硬件功耗" class="headerlink" title="processMiscUsage()：统计硬件功耗"></a>processMiscUsage()：统计硬件功耗</h2><p>该方法用于统计硬件的功耗，与App功耗一致，都是根据Uid、Drain type借助sipper来计算的。</p><h3 id="addUserUsage"><a href="#addUserUsage" class="headerlink" title="addUserUsage"></a>addUserUsage</h3><p>前面统计App用量时提到，如果不是App的uid或没有在refreshStats方法传入的参数中没包含这个uid，那么不会存到mUsageList里面，而是在mUserSippers内；这个方法将mUserSippers内的DrainType为User的sipper提取出来放入mUsageList内。</p><p>注意前面processAppUsage处理的DrainType是APP，这里是USER。</p><h3 id="addPhoneUsage"><a href="#addPhoneUsage" class="headerlink" title="addPhoneUsage"></a>addPhoneUsage</h3><p>添加”Phone On”类型的功耗；这里统计的是Ratio功能active的功耗，可以认为是不开飞行模式时、上了基站的通话网络情况下功耗；形象理解为：设备正常放着，不进行基带射频、扫描、上网、通话时的功耗</p><h3 id="addScreenUsage"><a href="#addScreenUsage" class="headerlink" title="addScreenUsage"></a>addScreenUsage</h3><p>添加屏幕的功耗，DrainType.Screen加入到mUsageList</p><h3 id="addAmbientDisplayUsage"><a href="#addAmbientDisplayUsage" class="headerlink" title="addAmbientDisplayUsage"></a>addAmbientDisplayUsage</h3><p>添加屏幕微光情况下的功耗（Display Doze)，DrainType.Ambient加入到mUsageList</p><h3 id="addWiFiUsage"><a href="#addWiFiUsage" class="headerlink" title="addWiFiUsage"></a>addWiFiUsage</h3><p>统计除分摊给App以外的剩余Wifi消耗，从mWifiSippers中提取，以DrainType.WIFI的新的sipper加入到mUsageList。</p><h3 id="addBluetoothUsage"><a href="#addBluetoothUsage" class="headerlink" title="addBluetoothUsage"></a>addBluetoothUsage</h3><p>蓝牙消耗的电量不会像WiFi一样会分摊给各个使用的App，它没有进行摊派全部统计在这里。该方法统计蓝牙的整体消耗；同WIFI，DrainType.BLUETOOTH加入mUsageList</p><h3 id="addMemoryUsage"><a href="#addMemoryUsage" class="headerlink" title="addMemoryUsage"></a>addMemoryUsage</h3><p>类似蓝牙的情况</p><h3 id="addIdleUsage"><a href="#addIdleUsage" class="headerlink" title="addIdleUsage"></a>addIdleUsage</h3><p>统计设备休眠、空闲时的AP（App Processor，即CPU）的功耗——也就是说，不包含BP（基带）的功耗，由于外设已经关闭或挂起、系统已经休眠，可以认为是深度待机状态下的整机功耗，可以说是开机状态下设备的最低功耗了</p><p>DrainType.IDLE sipper加入到mUsageList</p><h3 id="addRadioUsage"><a href="#addRadioUsage" class="headerlink" title="addRadioUsage"></a>addRadioUsage</h3><p>射频也和Wifi一样进行了摊派，同样是将没有摊派出去的独立出来到DrainType.CELL。其中，射频会额外关注信号强度，信号强度对射频功率、模组功耗影响大，进而影响对电耗的估算</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BatteryStatsService从系统各服务、驱动节点、Linux文件系统节点中取得的数据，在需要时，通过BatteryStatsImpl.refresh()取出、过滤、计算。其中，按照App电耗、硬件电耗两大部分来分别计算。耗电信息从Uid中取得，经过PowerCalculator处理后放入BatterySipper。一些类别的硬件电耗会分摊到使用它的几个App中，最终会以uid和Drain Type的形式来存储到多个BatterySipper中，交给调用者完成整个功耗信息获取过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;BatteryStatsService和BatterStatsImpl是系统中用于估算电流消耗的关键对象，能够估算并存储软件功耗和硬件功耗。</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/categories/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/tags/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>Android后台驻留：保活和回收的机制</title>
    <link href="https://nasdaqgodzilla.github.io/2023/06/03/Android%E5%90%8E%E5%8F%B0%E9%A9%BB%E7%95%99%EF%BC%9A%E4%BF%9D%E6%B4%BB%E5%92%8C%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://nasdaqgodzilla.github.io/2023/06/03/Android%E5%90%8E%E5%8F%B0%E9%A9%BB%E7%95%99%EF%BC%9A%E4%BF%9D%E6%B4%BB%E5%92%8C%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2023-06-03T07:10:56.000Z</published>
    <updated>2023-06-03T07:11:51.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>众所周知，Android平台的管理机制下，App进入后台后，为了提供持续的及时服务（如推送、音乐），或进行驻留获取收益（跟踪、信息收集、广告）等，会利用一些方法来让自身保持活跃，躲过被Android系统或用户发觉、清理，实现后台驻留。</p><p>其中，后台驻留的广义概念，除了保持在后台运行外，被其他组件拉起也属于驻留（唤醒）。</p><p>由于驻留会对系统的性能、响应延迟、续航、发热等带来负面影响，令系统的资源管理效果降低，属于违背用户意愿和知情的恶劣行为，因此将这些App称为顽固（Diehard）应用，其利用的方法称为顽固方法。</p><p>除了App利用的一些黑科技（甚至是在违法边缘的擦边手段）以外，Android系统本身自带的机制也可以实现保活和拉起。这些保活、拉起机制，粗略划分为两类：</p><ol><li>保持活跃，在后台运行不被清理、回收</li><li>被其他组件唤醒，包括被其他App唤醒、被系统提供的功能唤醒</li></ol><p>本文总结上述这两类会被顽固App利用的机制。</p><h1 id="进程和Task管理"><a href="#进程和Task管理" class="headerlink" title="进程和Task管理"></a>进程和Task管理</h1><p>首先简单梳理一下Android Framework层基本的进程管理。</p><p>Android平台基于Linux，除了基于Linux的“进程”维度来进行管理外，还按照Task的概念来管理应用进程，分别为ProcessRecord和TaskRecord。系统可以按Task也可以按Process来管理进程。</p><p>Android提供接口直接杀死Linux进程：1. ProcessRecord的kill()方法，其实现是向对应的进程发送SIGNAL_KILL信号；2. libc的kill()函数，也是发送信号</p><h2 id="OOM终止进程（LMK）"><a href="#OOM终止进程（LMK）" class="headerlink" title="OOM终止进程（LMK）"></a>OOM终止进程（LMK）</h2><p>App进程在系统中根据OOM（Out of Memory）ADJ（Adjustment）级别和进程状态来确定优先级，当系统需要杀死进程来释放内存时，优先级越低的会优先终止。OOM ADJ分数越小优先级越高。</p><p>由于顽固App进程后台驻留时可能会被系统回收，因此顽固App通常通过一些手段（services、弹窗）等来降低OOM（提高优先级），减少自身被系统回收的几率。</p><h2 id="最近任务列表结束Task"><a href="#最近任务列表结束Task" class="headerlink" title="最近任务列表结束Task"></a>最近任务列表结束Task</h2><p>用户在多任务界面（Recents）移除应用，系统会结束应用对应的Task：Removing Recent Task Item（RRT）。</p><p>该操作会结束掉与Task关联的进程，但在一些场景下仍然会有对应App的进程没有被杀死。</p><ol><li>当App通过”Exclude from recents”功能（不在最近任务列表显示自己）时，没有提供给用户结束的机会，就没有手动结束掉Task的入口</li><li>当一个进程属于多个Task时（该进程还需要为其他Task服务）</li></ol><p>这类终止机制由用户操作触发，当顽固应用借助多进程、多任务、唤醒拉起、互拉等操作，被终止后仍在后台运行（或后续又被唤醒），给用户感受为“杀不干净”。</p><h2 id="强制结束App"><a href="#强制结束App" class="headerlink" title="强制结束App"></a>强制结束App</h2><p>强制结束（Force-Stop）时Android内建的功能，由ActivityManagerService提供接口，可以在设置-应用程序界面由用户手动调用。</p><p>强制结束的范畴是App对应的所有Task（即可以杀死一般App所有进程）。FSA还额外会将App设置为“STOPPED“状态，禁止应用在下一次被用户手动启用或应用跳转前被广播、服务等唤醒。强制结束对顽固App的效果不佳，许多顽固App具备Native保活能力、互拉保活、唤醒拉起等对抗措施。</p><p>此外，Android提供KILL_BACKGROUND_PROCESSES权限，允许具备权限的App调用API杀死ADJ大于SERVICE_ADJ的后台进程（即没有Service的后台进程可以被杀掉）。</p><h1 id="保持活跃或唤醒"><a href="#保持活跃或唤醒" class="headerlink" title="保持活跃或唤醒"></a>保持活跃或唤醒</h1><h2 id="从最近任务隐藏或多个最近任务"><a href="#从最近任务隐藏或多个最近任务" class="headerlink" title="从最近任务隐藏或多个最近任务"></a>从最近任务隐藏或多个最近任务</h2><p>Android平台提供的excludeFromRecents功能可以让App的Task在多任务中隐藏。此外一个进程可以属于不同的Task，产生多个Task并隐藏其中几个Task可以实现”杀不干净“的效果。</p><h2 id="提升App进程优先级、阻止部分回收场景"><a href="#提升App进程优先级、阻止部分回收场景" class="headerlink" title="提升App进程优先级、阻止部分回收场景"></a>提升App进程优先级、阻止部分回收场景</h2><p>LMK和OOM ADJ会受到进程状态和优先级的影响，提高优先级可以降低被系统回收的几率，阻止部分会杀进程的场景。</p><p>其中，将借助前台进程绑定后台服务进程保活的手段，是较常见的“杀不死、杀不干净”的情况（最近任务移除后仍有进程）。</p><ol><li>接收广播，启动Receiver，具有Receiver的后台进程优先级高于无Receiver的后台进程</li><li>创建前台Service（高版本Android前台service需要带有通知），OOM ADJ更低（SERVICE_ADJ），杀死概率更低，此时进程不会被“杀死后台进程”杀掉（会跳过ADJ小于等于SERVICE_ADJ的进程）</li><li>保持前台Activity，OOM ADJ更低（用户可见的Task）</li><li>创建前台窗口（悬浮窗）或覆盖窗口（将窗口盖在前台App上面）</li><li>将后台服务绑定到前台进程，赋予后台服务在的进程更低的OOM，提升该进程的优先级，减少被杀的几率；同时对应进程不再属于后台进程，不会被“杀死后台进程”杀死，且该进程转为“需要为其他Task服务”，同样不会被最近任务移除时杀死</li><li>对于涉及Service的场景，ContentProvider也适用</li></ol><h2 id="借助Sticky-Service唤醒"><a href="#借助Sticky-Service唤醒" class="headerlink" title="借助Sticky Service唤醒"></a>借助Sticky Service唤醒</h2><p>黏性Service是系统提供的机制，被杀死后会由系统调度进行重启。前述的force-stop杀死的进程，由于设置的“STOPPED”状态是会被跳过的，因此这种情况杀死的进程不会再自动重启。大多数ROM对此都有限制（次数、频率）。</p><h2 id="借助广播唤醒"><a href="#借助广播唤醒" class="headerlink" title="借助广播唤醒"></a>借助广播唤醒</h2><p>通过系统或其他App、组件发出的广播可以唤醒应用，顽固应用可以借助广播来完成唤醒自启。同样的，force-stop设置的“STOPPED”状态也会让广播跳过这些App，不会唤醒这些App来传递广播。但广播带有一个特例功能，带有FLAG_INCLUDE_STOPPED_PACKAGES的广播可以无视“STOPPED状态”，仍会唤醒force-stop的App。通常系统广播没有这个FLAG，基本上是其他应用发出的广播带有。</p><p>高版本的Android已经不再触发静态广播和隐式广播，这种唤醒方式少了很多。（但有FLAG_RECEIVER_INCLUDE_BACKGROUND和FLAG_INCLUDE_STOPPED_PACKAGES规避）</p><h2 id="借助Alarm-Service定时器唤醒"><a href="#借助Alarm-Service定时器唤醒" class="headerlink" title="借助Alarm Service定时器唤醒"></a>借助Alarm Service定时器唤醒</h2><p>Alarm是Android提供的定时器功能，定时器timeout时会唤醒App。被force-stop的应用会自动移除掉注册的定时器，因此不会被唤醒。</p><h2 id="借助Job-Scheduling-Service任务调度唤醒"><a href="#借助Job-Scheduling-Service任务调度唤醒" class="headerlink" title="借助Job Scheduling Service任务调度唤醒"></a>借助Job Scheduling Service任务调度唤醒</h2><p>与Alarm类似，定时唤醒App。但是受到电源管理策略、功耗管理策略、系统休眠状态、WorkManager等的影响，唤醒的定时精度较低，且不同ROM可能表现一致性较差。同样的，会跳过被force-stop的App。</p><h2 id="借助其他App拉起唤醒"><a href="#借助其他App拉起唤醒" class="headerlink" title="借助其他App拉起唤醒"></a>借助其他App拉起唤醒</h2><p>这是国内互联网App最恶心的一种机制，一群App（或集成的SDK）互相拉起对方、互相绑定提高优先级、互相拉起唤醒。其中，唤醒方式除了常规的四大组件外，还有一些黑科技、Native的方法。其中，App发出的广播带上FLAG_RECEIVER_INCLUDE_BACKGROUND和FLAG_INCLUDE_STOPPED_PACKAGES完全可以规避force-stop后”STOPPED”的应用，实现唤醒。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以说，Android本身的管理机、提供的组件间通信功能，叠加App们的流氓行为，可以说后台驻留、拉起唤醒是防不胜防的，实现较好的后台驻留管理需要较高的投入，且对系统稳定性、App基本功能的影响较大，是高投入高难度的研究方向。其中，App互拉唤醒和保活的机制，让force-stop机制做不到太好的效果，其”STOPPED”实现的类似的轻度冻结状态几乎报废，也是各大ROM厂商在后台管理部分大展身手的重要因素。</p><p>为了实现好的功耗、续航、性能，就需要在应用唤醒、冻结、暂停执行等方面下功夫了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;众所周知，Android平台的管理机制下，App进入后台后，为了提供持续的及时服务（如推送、音乐），或进行驻留获取收益（跟踪、信息收集、广告</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/categories/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="功耗续航" scheme="https://nasdaqgodzilla.github.io/tags/%E5%8A%9F%E8%80%97%E7%BB%AD%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>Android性能监控：主循环性能统计LooperStatsService详解</title>
    <link href="https://nasdaqgodzilla.github.io/2023/05/05/Android%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9A%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1LooperStatsService%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nasdaqgodzilla.github.io/2023/05/05/Android%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9A%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1LooperStatsService%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-05-05T09:38:02.000Z</published>
    <updated>2023-05-05T09:39:14.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在Android性能监控和优化领域，一个会影响App性能表现的因素与Handler Message Looper机制有关。当Looper里面的Message处理不及时、或数量太多占用过多处理时间时，可能会出现卡顿感，并且不容易定位到卡顿的Message和慢方法。</p><p>Android本身提供了LooperStats机制来统计和监测Message的处理，并且可以通过LooperStatsService来统计和记录，方便调试和分析。</p><h1 id="LooperStatsService详解"><a href="#LooperStatsService详解" class="headerlink" title="LooperStatsService详解"></a>LooperStatsService详解</h1><h2 id="由SystemServer创建、Settings数据库变更触发启动"><a href="#由SystemServer创建、Settings数据库变更触发启动" class="headerlink" title="由SystemServer创建、Settings数据库变更触发启动"></a>由SystemServer创建、Settings数据库变更触发启动</h2><p>LooperStatsService是一个系统服务，由SystemServer在开机阶段启动。按照系统服务的接口要求，它是通过LooperStatsService.Lifecycle这个类被启动的。</p><p>启动流程主要是初始化LooperStats、LooperStatsService和SettingsObserver。</p><p>SettingsObserver在Settings数据库的值发生变化时回调，回调方法中根据特定格式来解析数据库的内容，根据解析的内容确定是否开始监控、监控频率等。</p><p>数据库是Settings.Global.looper_stats，对应的数据库格式如下：使用键值对（key&#x3D;value）来表示一个参数和它的值，多个键值对之间用逗号分隔。参数包括：sampling_interval控制采样频率（毫秒，默认1000），track_screen_state控制是否跟踪屏幕状态（默认false）。</p><p>也就是说，执行如下adb指令，写入Settings数据库，就能让LooperStatsService开始采样监控App的主循环Looper：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings <span class="keyword">put</span> <span class="keyword">global</span> looper_stats sampling_interval=<span class="number">100</span>,track_screen_state=<span class="literal">true</span>,enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动流程非常简单，先参数值初始化，然后将Observer设置到Looper。</p><p>也可以采用adb命令的方式来控制：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd looper_stats</span></span><br><span class="line"><span class="attr">looper_stats commands:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="string">Enable</span> <span class="string">collecting</span> <span class="string">stats.</span></span><br><span class="line">  <span class="attr">disable:</span> <span class="string">Disable</span> <span class="string">collecting</span> <span class="string">stats.</span></span><br><span class="line">  <span class="attr">sampling_interval:</span> <span class="string">Change</span> <span class="string">the</span> <span class="string">sampling</span> <span class="string">interval.</span></span><br><span class="line">  <span class="attr">reset:</span> <span class="string">Reset</span> <span class="string">stats.</span></span><br></pre></td></tr></table></figure><h2 id="Looper-Message-Dispatch流程实现监控"><a href="#Looper-Message-Dispatch流程实现监控" class="headerlink" title="Looper Message Dispatch流程实现监控"></a>Looper Message Dispatch流程实现监控</h2><p>我们知道Android的主线程的死循环被Looper封装，在Looper内部取出MessageQueue内排队的Message，根据Message.target和callback，将其派发到对应的处理方法中，实现消息循环。实现监控的流程也很容易，在消息派发前回调到监控者，消息由处理函数处理完成后，回调监控者，即可实现让监控着感知消息处理的进度。</p><p>Looper本身提供了内部接口类Observer提供回调接口来实现上述需求：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">Object</span> messageDispatchStarting();</span><br><span class="line">        <span class="keyword">void</span> messageDispatched(<span class="keyword">Object</span> token, Message msg);</span><br><span class="line">        <span class="keyword">void</span> dispatchingThrewException(<span class="keyword">Object</span> token, Message msg, <span class="built_in">Exception</span> <span class="built_in">exception</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前两个接口分别在一个消息处理前、一个消息完成处理时回调。第三个接口是Message处理过程中抛出了异常时回调。</p><p>App主事件循环实际上可以抽象为如下流程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// LooperStatsService打开的情况下，会设置sObserver</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line"></span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单来说Looper每次处理Message的流程就是，在消息发给App处理之前、之后分别回调Observer的接口，实现记录。其中，慢速的Message处理也会在这里检查并打印日志。</p><p>LooperStatsService实际上利用了Looper提供的Observer机制，打开后它设置了sObserver，接受Message Loop的回调，在回调中记录数据并做统计。</p><h2 id="LoopStats实现性能数据记录"><a href="#LoopStats实现性能数据记录" class="headerlink" title="LoopStats实现性能数据记录"></a>LoopStats实现性能数据记录</h2><p>LooperStatsService借助LoopStats实现数据记录。在Message派发前，记录三个数据：开机后经过的时间（elpased real time，包含系统休眠）、开机后经过的时间（uptime，不包括系统休眠）、当前线程消耗的时间。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">Object</span> messageDispatchStarting() &#123;</span><br><span class="line">        <span class="keyword">if</span> (deviceStateAllowsCollection() &amp;&amp; shouldCollectDetailedData()) &#123;</span><br><span class="line">            DispatchSession <span class="keyword">session</span> = mSessionPool.poll();</span><br><span class="line">            <span class="keyword">session</span> = <span class="keyword">session</span> == <span class="keyword">null</span> ? <span class="built_in">new</span> DispatchSession() : <span class="keyword">session</span>;</span><br><span class="line">            <span class="keyword">session</span>.startTimeMicro = getElapsedRealtimeMicro();</span><br><span class="line">            <span class="keyword">session</span>.cpuStartMicro = getThreadTimeMicro();</span><br><span class="line">            <span class="keyword">session</span>.systemUptimeMillis = getSystemUptimeMillis();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">session</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DispatchSession.NOT_SAMPLED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，deviceStateAllowsCollection()的判断逻辑是“设备未在充电状态”，shouldCollectDetailedData()用于实现上述设置的采样时间间隔。</p><p>LooperStatsService区分不同的Message分别进行统计，统计的信息存储于Entry中：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> workSourceUid;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> messageName;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isInteractive;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> messageCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> recordedMessageCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> exceptionCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> totalLatencyMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> maxLatencyMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> cpuUsageMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> maxCpuUsageMicro;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> recordedDelayMessageCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> delayMillis;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> maxDelayMillis;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，主要信息是messageName，messageCount记录消息派发的次数，recordedMessageCount记录消息被LooperStats采样并记录到的次数。</p><p>messageCount和recordedMessageCount的差异是：每个消息都让messageCount +1，而满足前述参数设置的采样时间间隔的消息才会被采样、记录，被采样的消息才会让recordedMessageCount +1。</p><p>totalLatencyMicro记录该类型的消息花费的总时间，计算方法是消息派发前、处理完成后两者的elpased time（开机后经过的时间，包含系统或进程休眠）时间差。</p><p>maxLatencyMicro计算该类型的消息在某一次派发、处理花费的最大时间，同样是elpased time。</p><p>cpuUsageMicro和maxCpuUsageMicro，分别计算该类型消息处理时间的总和、最大耗时。计算方法是取得线程运行时间，减去派发前的线程运行时间（即messageDispatchStarting()记录的起始值）即可得到线程处理该消息的耗时（线程实际工作时间，不包含休眠）</p><p>App Message Loop还有一个很大的特点，就是其Message可以指定某个时间再出发（如postDelayed()发出的Message）。那么在一些场景下，要求定时处理的Message可能不能准时触发，而是有一定的延时，可能也会存在性能问题或体验问题，甚至是功能异常。delayMills、maxDelayMills就用于记录发生这些延时的总时间、最大延时。计算方法是，计算派发前、处理后两者的uptime时间差（系统或进程休眠时不计时），大于Message的目标时间的值就是delay的大小。对应的，recordedDelayMessageCount记录延时发生的次数。注意这三个delay数据只针对Message.when有值（即指定了触发时间的Message）的情况才会统计。</p><h2 id="dumpsys获取性能监控数据"><a href="#dumpsys获取性能监控数据" class="headerlink" title="dumpsys获取性能监控数据"></a>dumpsys获取性能监控数据</h2><p>可以在adb shell执行dumpsys looper_stats获取性能统计数据。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dumpsys looper_stats</span><br><span class="line">Start <span class="selector-tag">time</span>: <span class="number">2023</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">08</span></span><br><span class="line">On battery <span class="selector-tag">time</span> (ms): <span class="number">54297</span></span><br><span class="line">work_source_uid,thread_name,handler_class,message_name,is_interactive,message_count,recorded_message_count,total_latency_micros,max_latency_micros,total_cpu_micros,max_cpu_micros,recorded_delay_message_count,total_delay_millis,max_delay_millis,exception_count</span><br><span class="line">-<span class="number">1</span>,PowerManagerService,android<span class="selector-class">.os</span><span class="selector-class">.Handler</span>,<span class="number">0</span>x2,false,<span class="number">5</span>,<span class="number">1</span>,<span class="number">72</span>,<span class="number">72</span>,<span class="number">68</span>,<span class="number">68</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">com<span class="selector-class">.android</span>.systemui/u0a139,WifiHandlerThread,com<span class="selector-class">.android</span><span class="selector-class">.wifi</span><span class="selector-class">.x</span><span class="selector-class">.com</span><span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.util</span>.StateMachine<span class="variable">$SmHandler</span>,<span class="number">0</span>x20053,false,<span class="number">9</span>,<span class="number">1</span>,<span class="number">31576</span>,<span class="number">31576</span>,<span class="number">9055</span>,<span class="number">9055</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">com<span class="selector-class">.tencent</span><span class="selector-class">.android</span>.qqdownloader/u0a164,PowerManagerService,android<span class="selector-class">.os</span><span class="selector-class">.Handler</span>,<span class="number">0</span>x2,false,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1360</span>,<span class="number">1360</span>,<span class="number">98</span>,<span class="number">98</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>如上，当CPU时间、消息处理时间、消息延迟时间等出现异常数值时，即可通过对应的线程、消息来确定耗时的消息、执行缓慢的流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在Android性能监控和优化领域，一个会影响App性能表现的因素与Handler Message Looper机制有关。当Looper里面</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LutFilter：3D LUT简介与应用</title>
    <link href="https://nasdaqgodzilla.github.io/2023/04/24/LutFilter%EF%BC%9A3D-LUT%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://nasdaqgodzilla.github.io/2023/04/24/LutFilter%EF%BC%9A3D-LUT%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2023-04-24T08:13:00.000Z</published>
    <updated>2023-04-24T08:15:12.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LUT是“Look-Up-Table”——查找表的缩写。它是数据的一种容器，类似字典、map等，将索引与值对应起来的一种描述方式。</p><p>3D LUT，顾名思义，描述索引与值之间的对应方式是三维的，可以被理解为三个维度的索引-值对应方式的结合，通过三个维度的索引，可以查找到一个值。与一本普通的字典一样，输入固定的值作为索引，可以查到固定的结果作为输出。</p><p>3D LUT被广泛地在电影工业和显示工业广泛使用，用于在不同的显示器、不同的颜色空间之间做色彩校正、显示调节、效果和优化等方面。也就是说，3D LUT实际上是颜色的转换，是RGB的映射。借助3D LUT的颜色映射，将颜色进行调节，达成3D LUT即定的显示效果。</p><p>1D LUT只能控制gamma值、RGB平衡（灰阶）和白场（white point），而3D LUT能以全立体色彩空间的控制方式影响色相、饱和度、亮度等。简单描述来说3D LUT可以影响到颜色，而1D LUT只能影响亮度值。</p><p>由于颜色空间、gamma、色域等会影响颜色的呈现效果，因此想要让LUT有较好的效果，一般要求输入的颜色和输出的颜色在同一个显示环境下（颜色空间、色域、伽马一致）。</p><p>得益于颜色映射，富有创意的艺术家们能调出效果绝伦的LUT，通常会用于显示效果调节、色彩管理、美颜P图、显示器校正等方面，有很大的实用价值。</p><ul><li>技术型LUT：用于颜色转换，校准显示器，显示补偿，硬件矫正，色彩管理，色彩过滤，失真弥补，硬件偏色改善</li><li>创意型LUT（风格LUT）：用于显示风格的转换、美化、调色、多图合成（图像叠加）</li></ul><h1 id="直观了解3D-LUT"><a href="#直观了解3D-LUT" class="headerlink" title="直观了解3D LUT"></a>直观了解3D LUT</h1><p>先来看看LUT能达到的效果，看上去就是平平无奇的滤镜。</p><p>下图为两位特邀模特的演示图，图的右半部分分别应用了一个黑白化、鲜艳化的3D LUT：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LutFilter%E6%A1%88%E4%BE%8BW%E6%88%AA%E5%9B%BE.png"></p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%94.png"></p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%942.png"></p><p>一个调整对比度的案例：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%94_%E5%AF%B9%E6%AF%94%E5%BA%A6%E8%B0%83%E8%8A%82.png"></p><p>一个调整对比度+明度的案例：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUT%E5%AF%B9%E6%AF%94_%E5%AF%B9%E6%AF%94%E5%BA%A6+%E6%98%8E%E5%BA%A6%E8%B0%83%E8%8A%82.png"></p><h1 id="3D-LUT的基本结构和表示方法"><a href="#3D-LUT的基本结构和表示方法" class="headerlink" title="3D LUT的基本结构和表示方法"></a>3D LUT的基本结构和表示方法</h1><p>3D LUT是一种统称，表示RGB三个维度的颜色映射规则表，有很多种文件格式，包括文本类型的cube，图片类型的png等。</p><p>立体地来理解3D LUT，就像一个有X、Y、Z三轴的三维坐标系，分别是RGB三个分量：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/3DLUT%E7%AB%8B%E4%BD%93%E5%9B%BE.png"></p><p>颜色的查找实际上就是将RGB当作XYZ，在表中查找得到映射后的RGB值：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>如前述，3D LUT有不同的文件格式，不同的文件格式有不同的使用方式和性能表现，在工业界平台的技术栈和性能要求，对3D LUT的文件格式的选型有决定性的影响。<br>实际应用时，3D LUT往往使用cube格式，其便利性、性能表现有明显优势，下文会简单介绍，其结构如下。</p><p>将LUT按立方体进行面分割并平铺每一个面，如下。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>cube格式的核心思想是，将三维维度转换为二维维度。将R与G分量组成小的二维坐标系（小方片），整个cube有N个小方片，每个小方片内部B分量固定，小方片B分量互相之间自然增长。<br>通俗来说，每一个小方格子里面的内部横坐标是红色，纵坐标是绿色。蓝色是固定不变的，只会随着小方片的序号的增长而增长。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.png"></p><p>左上角一点蓝色都没有，所以很红很绿；右下角蓝色很多，看上去很蓝。<br>3D LUT按照面划分就是16x16x16，32x32x32，64x64x64，256x256x256……，我们知道面由线段围成，而一根线段有两个端点，因此一个3D LUT按照端点来计算深度，那么就有17x17x17，33x33x33，65x65x65，257x257x257的表示方法。</p><p>上图的cube是一个64x64x64的3D LUT。我们知道RGB颜色空间取值有256个（0~255），因此64x64x64的3D LUT实际上是不能表示所有颜色的。</p><p>因此它有如下特点：</p><ul><li>每个输入的RGB，如果不是刚好落到整数点上，此时换算不那么直接（比如输入的R分量刚好是点1和点2中间的位置，此时到底用点1还是点2，还是点1和点2的平均值，还是插值计算）来映射</li><li>换算不那么直接，意味着有一定的精度差异，低精度误差大，高精度消耗内存、消耗LUT文件解析时间（256<em>256</em>256的cube大约占据48M左右的空间）</li><li>不论LUT层数是否足够高，都会碰见需要插值或降低采样的场景</li><li>人眼分辨能力、颜色学、内容颜色精度、显示器屏幕质素等因素客观上决定了，颜色的轻微偏差不会被察觉，不会对显示效果造成影响</li></ul><p>下图为256层的LUT：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE256%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>还有一种竖直排列各层的形式（这里将它做了旋转，变成横向排列。按照B分量的方向来看，它是竖向排列的）：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%AB%96%E7%9B%B41.png"></p><p>通过图片来存储的3D LUT，有个很突出的特点，就是图片本身的外观就是3D LUT提供的调色风格，如上面一个LUT的风格看上去是让图片更加鲜艳，而如下这个LUT则看上去让图片变的带有棕褐色色调：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%AB%96%E7%9B%B42.png"></p><p>这个则一眼能看出来可以抹掉色彩，让图片变成黑白图。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/LUTCUBE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%AB%96%E7%9B%B43.png"></p><h1 id="3D-LUT的优势"><a href="#3D-LUT的优势" class="headerlink" title="3D LUT的优势"></a>3D LUT的优势</h1><p>3D LUT具有一些突出的特性和优势。</p><ul><li>性能</li></ul><p>3D LUT本身是查找表，将本该经过计算得到的映射结果预先存储下来，用于直接读取，避免了对像素点的映射计算。是一种空间换时间的算法，有高响应速度的保证。</p><ul><li>灵活程度大，带来更好的效果</li></ul><p>常规的滤镜是单一映射，通常会将整个图像的所有像素机械地进行映射。如一个暖色调的普通滤镜会让图像内原本已经很暖的颜色变的更暖，甚至失真。而3D LUT则可以实现控制，不同像素值会有不同的非线性的映射效果。</p><ul><li>支持硬件加速</li></ul><p>高响应速度的图像处理通常需要GPU或FPGA进行加速。3D LUT可以加载为纹理，通过OpenGL进行绘图</p><ul><li>风格和效果的自定义自由度大、简单</li></ul><p>LUT文件的制作比较简单，风格和效果可以由富有创意的艺术家们随心所欲地随时创建</p><ul><li>用户自定义自由度大</li></ul><p>用户可以随时下载或制作符合规范的LUT，在不修改软件的前提下，任意地设置LUT，实现不同的效果</p><ul><li>兼容性高</li></ul><p>3D LUT实现的调色可以在任意没有接入调色功能的应用（如系统应用、三方应用、浏览器、视频流、相机流），无感、无侵入的实现调色，被调色的目标不会出现任何兼容性问题，也没有任何侵入性，跨平台的移植性也很高</p><ul><li>LUT的基本使用</li></ul><p>LUT的基本应用流程主要为创建LUT、导入LUT、根据LUT映射新的像素值并绘制三大流程。其中对于Android平台，流程的重点难点在于绘制过程，通常借助OpenGL在GPU进行绘制。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/OpenGL%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png"></p><p>OpenGL绘图的基本流程如上。使用3D LUT进行调色，可以实现为在片段着色器中读取原图像素的颜色值，根据LUT映射为新的颜色值，实现绘图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;LUT是“Look-Up-Table”——查找表的缩写。它是数据的一种容器，类似字典、map等，将索引与值对应起来的一种描述方式。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Graphics" scheme="https://nasdaqgodzilla.github.io/categories/Graphics/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Graphics" scheme="https://nasdaqgodzilla.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：getResources()与Binder交火导致的界面卡顿优化</title>
    <link href="https://nasdaqgodzilla.github.io/2023/02/10/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9AgetResources-%E4%B8%8EBinder%E4%BA%A4%E7%81%AB%E5%AF%BC%E8%87%B4%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/"/>
    <id>https://nasdaqgodzilla.github.io/2023/02/10/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9AgetResources-%E4%B8%8EBinder%E4%BA%A4%E7%81%AB%E5%AF%BC%E8%87%B4%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</id>
    <published>2023-02-10T08:51:13.000Z</published>
    <updated>2023-02-10T08:52:05.042Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E8%A7%82%E6%B5%8B">观测</a><ul><li><a href="#1-trace%E4%BD%93%E7%8E%B0ui%E7%BB%98%E5%88%B6%E6%93%8D%E4%BD%9C%E4%B8%A5%E9%87%8D%E8%80%97%E6%97%B6">1. trace体现UI绘制操作严重耗时</a></li><li><a href="#2-%E6%8E%92%E6%9F%A5measure%E5%92%8Clayout%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A%E5%8F%AF%E7%96%91%E7%9A%84%E5%A4%9A%E6%AC%A1binder">2. 排查measure和layout慢的原因：可疑的多次binder</a></li><li><a href="#3-binder%EF%BC%9A%E5%9C%A8%E5%93%AA%E3%80%81%E8%B0%81%E4%B8%BA%E3%80%81%E4%B8%BA%E4%BD%95%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8">3. binder：在哪、谁为、为何频繁调用</a></li><li><a href="#4-binder%EF%BC%9A%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9A%E4%BD%8D">4. binder：频繁调用的具体定位</a></li></ul></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li><li><a href="#%E6%96%B9%E6%A1%88">方案</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某轮测试发现，我们的设备运行一个第三方的App时，卡顿感非常明显：</p><ul><li>界面加载很慢，菊花转半天</li><li>滑屏极度不跟手，目测观感帧率低于15</li><li>对比机（竞品）也会稍微一点卡，但是好很多，基本不会有很大感觉的卡顿</li></ul><p>可以初步判定我们的设备存在性能问题，亟需优化，拉平到竞品水准。</p><p>最后发现，这个问题实际上是应用自身奇怪的实现（getResources()的重载），加上Binder过度调用（沉重的Binder耗时）导致的。</p><p>本文做记录和分享。</p><p>其中对比机配置、Android版本均与本机不同，不做变量参考。</p><h1 id="观测"><a href="#观测" class="headerlink" title="观测"></a>观测</h1><p>由于这个可爱的App是第三方的App（应用市场下载的），我们没有源码，只能从系统端去干涉。先抓一份trace。</p><h2 id="1-trace体现UI绘制操作严重耗时"><a href="#1-trace体现UI绘制操作严重耗时" class="headerlink" title="1. trace体现UI绘制操作严重耗时"></a>1. trace体现UI绘制操作严重耗时</h2><p>trace一抓一看，显然App主线程已经陷入困境。可以看到：</p><ol><li>CPU使用率并不高</li><li>主线程几乎完全在执行Traversal工作（mersure和layout）</li><li>measure和layout极度耗时，显然达不到合理的帧率要求（甚至连PPT帧率都赶不上）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/binder.png" alt="主线程挤满了traversal工作"></p><p>可以看到，这份trace表明App的整个measure和layout工作存在整体性的不合理耗时。但并不能准确提示细节，也不能看出问题部分。可以肯定，耗时工作位于App层（不是指耗时原因也来自App）。</p><h2 id="2-排查measure和layout慢的原因：可疑的多次binder"><a href="#2-排查measure和layout慢的原因：可疑的多次binder" class="headerlink" title="2. 排查measure和layout慢的原因：可疑的多次binder"></a>2. 排查measure和layout慢的原因：可疑的多次binder</h2><p>上面可以确认绘制缓慢造成耗时。但是一来App不是自己的，二来这么复杂的调用，通过分析调用、跟代码来定位慢方法、慢路径显然足够低效。</p><p>定位到Traversal，统计一下Traversal各部分的耗时占比，可以大致定位出耗时部分可能是什么业务的：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/traversal%E8%BF%87%E7%A8%8B%E6%9C%89%E5%A4%A7%E9%87%8Fbinder%E8%B0%83%E7%94%A8%E5%8D%A0%E6%8D%AE%E5%A4%A7%E9%87%8F%E8%80%97%E6%97%B6.png" alt="traversal过程有大量binder调用"></p><p>可以看到，traversal意外地包含了数量巨大的binder调用，它占据总耗时的80%+，使得应用层绘图超出生命线10倍以上：</p><ol><li>这次doFrame-&gt;travesal耗时接近200ms，属于”无法使用的垃圾”级别，不是性能问题而是故障</li><li>binder调用（binder transaction）次数很多，在几毫秒的时间里（预期的一次应用层绘图时间）进行了194次IPC</li><li>binder耗时占比很高：83%左右</li><li>还有一个ioctl调用次数也很多、很耗时；由于binder驱动调用talkWithDriver()需要使用ioctl，因此这里初步判断ioctl是binder IPC的伴生，无碍</li></ol><blockquote><p>生命线：对于60Hz的屏幕，生命线为16ms左右。但是16ms为图形栈全链路的极限时间，留给应用层的时间更低</p></blockquote><p>可以确认，过多的binder调用导致了这个恼火的性能问题。</p><h2 id="3-binder：在哪、谁为、为何频繁调用"><a href="#3-binder：在哪、谁为、为何频繁调用" class="headerlink" title="3. binder：在哪、谁为、为何频繁调用"></a>3. binder：在哪、谁为、为何频繁调用</h2><p>通常应用（和应用集成的库），出于一定的目的，会通过IBinder、AIDL、封装组件（如startService）、直接调用驱动节点（talkWithDriver）等方式来进行一次Binder IPC。</p><p>性能问题中，与Binder IPC相关的，最常见的主要如下：</p><ol><li>频繁调用Binder</li><li>关键、敏感、紧张的位置调用Binder</li><li>Binder对端响应太慢，对端繁忙</li><li>Binder传递的数据太大</li><li>Binder客户端线程数超限（发起请求的线程满）</li><li>Binder服务端线程数超限（处理请求的线程满）</li></ol><p>对于Binder传递数据太大、线程数导致的性能问题，由于应用不是自己的（不好干涉、不关注），且对比机卡顿不那么明显（可以粗略排除），因此不太值得去看。（另外我们是在滑屏的时候卡的，主线程UIHandler也做不到并发发出Binder IPC）</p><p>这里还是展示一下怎么分析。下列命令可以提供一些关于binder状态、traction状态、传递数据大小等内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>binder/failed_transaction_log</span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>binder/transaction_log</span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>binder/transactions</span><br></pre></td></tr></table></figure><p>同样的，我们不好关注应用为何调用binder（因为没有App的代码，最近也忙的不想逆向它；但实际上最后我们知道了为何调用），也很显然是在哪调用的（在App UI线程 performTraversal时调用的），因此先来看看这群IPC的对端是谁。</p><p>trace一看，binder调用确实很多（画蓝紫色线部分都是binder；本是细线，溢满则刚）：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%E8%BF%87%E5%A4%9A%E7%9A%84binder.png"></p><p>上图binder调用很多，其实很多是同一种类，各IPC都最终归属于一类Binder。分类看，数量巨大、占比最高的两类binder（称为第一部分binder和第二部分binder）是值得探讨的主要耗时部分。</p><p>首先，分析第一部分binder的对端。跟踪发现第一部分binder“飞”往SurafceFlinger，耗时较短，次数合理，评估正常，不再跟进，不贴图展示。</p><p>第二部分binder，从次数、耗时来看，确实可疑。它从App进程“飞”往System_server（Framework服务层）：</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86binder%E5%90%8E%E9%9D%A2%E8%BF%98%E8%B7%9F%E7%9D%80%E5%87%A0%E4%B8%AAbinder_%E6%97%B6%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%90%88%E5%B9%B3%E5%9D%87binder%E8%80%97%E6%97%B6.png"></p><h2 id="4-binder：频繁调用的具体定位"><a href="#4-binder：频繁调用的具体定位" class="headerlink" title="4. binder：频繁调用的具体定位"></a>4. binder：频繁调用的具体定位</h2><p>性能分析的其中一个关键方向是找到慢方法、慢路径。上面一步已经体现了，慢是因为App在敏感且关键的位置调用了Binder，这个binder的对端是Framework。</p><p>从系统侧分析这个binder的性能，难以像App那样轻松定位——因为App里面有多少个调用、系统里面暴露了多少个binder，在哪里触发的，都不好搞。</p><p>因此直接来粗暴的方法，把所有binder调用抓堆栈下来。</p><p>多次复现、多次抓取，阅读堆栈、总结分类，可以抓到蛛丝马迹。由于最长的堆栈高达33万行（包含合理的正常的binder和造成性能问题的binder），且抓了好几份，这里只能将问题的关键点做个展示输出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="number">20230209</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span>  binder.<span class="number">20230209.2</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209.4</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230210.1</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span></span><br><span class="line"><span class="number">20230209</span><span class="selector-class">.ok</span><span class="selector-class">.trace</span>  binder.<span class="number">20230209.3</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209.5</span><span class="selector-class">.fk</span><span class="selector-class">.trace</span><span class="selector-class">.log</span>  binder.<span class="number">20230209</span><span class="selector-class">.ok</span><span class="selector-class">.trace</span>.log</span><br></pre></td></tr></table></figure><blockquote><p>fk表示fuck，即不正常情况下的binder堆栈；ok表示正常。</p></blockquote><p>其中性能故障对应的堆栈如下（几类有性能问题的binder调用；仅截取关键位置）：</p><p>第一个堆栈放全一些，可以看出，在正常的traversal过程中，View体系正常调用getResources()，binder发生在getResources()内部：它调用了IWindowManager.getInitialDisplayDensity()，通过binder“飞”到system_server：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">15</span></span><br><span class="line">Trace: java<span class="selector-class">.lang</span><span class="selector-class">.Throwable</span></span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span><span class="selector-class">.transact</span>(BinderProxy<span class="selector-class">.java</span>:<span class="number">547</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.IWindowManager<span class="variable">$Stub</span><span class="variable">$Proxy</span><span class="selector-class">.getInitialDisplayDensity</span>(IWindowManager<span class="selector-class">.java</span>:<span class="number">3025</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.e5</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.getResources</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at androidx<span class="selector-class">.appcompat</span><span class="selector-class">.widget</span><span class="selector-class">.ContentFrameLayout</span><span class="selector-class">.onMeasure</span>(ContentFrameLayout<span class="selector-class">.java</span>:<span class="number">1</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureChildBeforeLayout</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1632</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureVertical</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">922</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">801</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">331</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureChildBeforeLayout</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1632</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureVertical</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">922</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">801</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">331</span>)</span><br><span class="line">at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.policy</span><span class="selector-class">.DecorView</span><span class="selector-class">.onMeasure</span>(DecorView<span class="selector-class">.java</span>:<span class="number">763</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.performMeasure</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">3665</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.measureHierarchy</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">2302</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.performTraversals</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">2564</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span><span class="selector-class">.doTraversal</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">2026</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.ViewRootImpl<span class="variable">$TraversalRunnable</span><span class="selector-class">.run</span>(ViewRootImpl<span class="selector-class">.java</span>:<span class="number">8469</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.Choreographer<span class="variable">$CallbackRecord</span><span class="selector-class">.run</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">972</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.Choreographer</span><span class="selector-class">.doCallbacks</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">796</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.Choreographer</span><span class="selector-class">.doFrame</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">731</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.Choreographer<span class="variable">$FrameDisplayEventReceiver</span><span class="selector-class">.run</span>(Choreographer<span class="selector-class">.java</span>:<span class="number">957</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span><span class="selector-class">.handleCallback</span>(Handler<span class="selector-class">.java</span>:<span class="number">938</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span><span class="selector-class">.dispatchMessage</span>(Handler<span class="selector-class">.java</span>:<span class="number">99</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.Looper</span><span class="selector-class">.loop</span>(Looper<span class="selector-class">.java</span>:<span class="number">223</span>)</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.main</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">8024</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span>.RuntimeInit<span class="variable">$MethodAndArgsCaller</span><span class="selector-class">.run</span>(RuntimeInit<span class="selector-class">.java</span>:<span class="number">605</span>)</span><br><span class="line">at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span><span class="selector-class">.ZygoteInit</span><span class="selector-class">.main</span>(ZygoteInit<span class="selector-class">.java</span>:<span class="number">947</span>)</span><br></pre></td></tr></table></figure><p>其实这里已经能看出问题，并且看清问题的严重性了。可以说，tarversal阶段是一个App最紧张、最重要的阶段之一，在这个关键时间窗口内，还调用了binder通信这一不可靠的方法（IPC是不可预期的），对性能影响很大。</p><p>该应用的View实现喜欢在traversal阶段调用上述Binder，包括但不限于如下几个：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">5</span></span><br><span class="line">Trace: java<span class="selector-class">.lang</span><span class="selector-class">.Throwable</span></span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span><span class="selector-class">.transact</span>(BinderProxy<span class="selector-class">.java</span>:<span class="number">547</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.IWindowManager<span class="variable">$Stub</span><span class="variable">$Proxy</span><span class="selector-class">.getInitialDisplayDensity</span>(IWindowManager<span class="selector-class">.java</span>:<span class="number">3025</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.e5</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.getResources</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">221</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureChildBeforeLayout</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1632</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureVertical</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">922</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">801</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.measureHorizontal</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">1463</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">803</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">20</span></span><br><span class="line">Trace: java<span class="selector-class">.lang</span><span class="selector-class">.Throwable</span></span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span><span class="selector-class">.transact</span>(BinderProxy<span class="selector-class">.java</span>:<span class="number">547</span>)</span><br><span class="line">at android<span class="selector-class">.view</span>.IWindowManager<span class="variable">$Stub</span><span class="variable">$Proxy</span><span class="selector-class">.getInitialDisplayDensity</span>(IWindowManager<span class="selector-class">.java</span>:<span class="number">3025</span>)</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Native Method)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.e5</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at refactor<span class="selector-class">.common</span><span class="selector-class">.base</span><span class="selector-class">.FActivity</span><span class="selector-class">.getResources</span>(FActivity<span class="selector-class">.java</span>:<span class="number">7</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.LinearLayout</span><span class="selector-class">.onMeasure</span>(LinearLayout<span class="selector-class">.java</span>:<span class="number">762</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.RelativeLayout</span><span class="selector-class">.measureChild</span>(RelativeLayout<span class="selector-class">.java</span>:<span class="number">849</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.RelativeLayout</span><span class="selector-class">.onMeasure</span>(RelativeLayout<span class="selector-class">.java</span>:<span class="number">652</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.measureChildWithMargins</span>(ViewGroup<span class="selector-class">.java</span>:<span class="number">7114</span>)</span><br><span class="line">at android<span class="selector-class">.widget</span><span class="selector-class">.FrameLayout</span><span class="selector-class">.onMeasure</span>(FrameLayout<span class="selector-class">.java</span>:<span class="number">331</span>)</span><br><span class="line">at androidx<span class="selector-class">.appcompat</span><span class="selector-class">.widget</span><span class="selector-class">.ContentFrameLayout</span><span class="selector-class">.onMeasure</span>(ContentFrameLayout<span class="selector-class">.java</span>:<span class="number">21</span>)</span><br><span class="line">at android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.measure</span>(View<span class="selector-class">.java</span>:<span class="number">25597</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>到此，已经定位到了慢路径了：</p><ul><li>App喜欢在View的关键回调里面调用IPC，产生巨大的性能问题</li><li>在measure和traversal阶段不厌其烦地调用一个通常情况很少调用的接口getInitialDisplayDensity()</li><li>View的加载阶段、traversal阶段，在measure、layout阶段因Binder IPC过度频繁触发了性能问题</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>App在多个不同的View（及其子类ViewGroup和ViewGroup的子类们），在不合适的时机频繁调用了Binder，以很低的CPU占用，领先性地实现了很卡的效果。</p><p>虽然卡顿的贡献来自不同的View调用的同名Binder，这个binder却是同一个接口（不易变的getInitialDisplayDensity()，这意味着返回值可以被缓存下来并确保有效），而且触发的直接原因是同一个——App在Context.getResources()方法内部调用了这个binder，getResources()在App运行时会被频繁调用（尤其是View创建、绘制阶段）。</p><blockquote><p>Context.getResources()默认实现是直接返回mResources，但是会有可爱的人会override它（或通过优美的kotlin扩展函数），往里面塞入耗时的慢方法。</p></blockquote><p>清晰的定位到了慢方法、卡顿根因后，还有一个残酷的问题：对比机不卡。</p><p>回答这个问题感觉像是对自己写出来的卡顿型代码有点欲盖弥彰的感觉。不过经过分析，排除掉竞品的优化、App在竞品的Android版本（Android版本和我们不一样）上业务逻辑不同、竞品的系统原生逻辑就不一样（Android版本原生逻辑差异）这三个变量因素后，结合代码阅读，发现我们的View Tree在Measure和Layout阶段，我们自己添加的功能会比原生要调用更多次的getResources()方法。</p><p>这在大多数情况下非常正常（逻辑上也正常，因为这个方法只有一行直接返回Resources对象实例的代码），碰到一个在超高频方法里面加慢调用、不可靠IPC的App后只能傻眼认栽。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>从App角度看，它错的很离谱。优化方案也很简单，去掉一个多余的、过度的Binder调用，一般是将调用集中在关键位置（临界区）以外、缓存返回值（确保返回值没有失效的前提下重用cache）、不在高频方法里面加东西、尽量不override sdk方法等等。</p><p>在系统侧，本着拉平甚至超越竞品的愿景，同样有减少binder调用的优化目标。不论是对应用自身问题的解决，还是对竞品的竞争性跟进，无所谓，都出手。主要有如下一些方案：</p><ol><li>Framework可以实现缓存，在Binder IPC发出前检查有效性，仅在失效后真正发出IPC</li><li>把我们加进去的额外的getResources()去掉、重构</li><li>在严酷的竞争、高标准的要求下，会将考虑一些非标准的操作（魔改）</li></ol><blockquote><p>有效性，是指IPC对端返回的内容没有发生改变（本质上是软件维护的状态并未发生改变）。比如，从未旋转过屏幕，那么我们上一次获取的屏幕宽高就仍然有效，不需要再次获取，而应复用缓存</p></blockquote><p>最终方案2采用并取得良好效果：帧率提升几倍、跟手了，还有一点卡卡的（App自己的+原生的getResources()调用），达到和竞品一致的水准了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ContextImpl.java?q=ContextImpl.getResources">Context.getResources()源码参考</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A7%82%E6%B5%8B&quot;&gt;观测&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-trace%E4%BD%93%E7%8E%B0ui%E7</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 13 WindowContainer窗口模型详解</title>
    <link href="https://nasdaqgodzilla.github.io/2023/01/25/Android-13-WindowContainer%E7%AA%97%E5%8F%A3%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nasdaqgodzilla.github.io/2023/01/25/Android-13-WindowContainer%E7%AA%97%E5%8F%A3%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-01-25T12:29:37.000Z</published>
    <updated>2023-03-08T09:33:04.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android 13后窗口模型系列架构存在较大变更，本文围绕WindowContainer总结窗口模型。</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><!--```@startumlclass ConfigurationContainer {}class WindowContainer {}class RootWindowContainer {    - child :DisplayContent}class WindowProcessController {    - parent :RootWindowContainer}class WindowToken {    - child :WindowState}class TaskFragment {    - child :ActivityRecord    - parent :DisplayArea}class Task {    - child :ActivityRecord    - parent :DisplayArea}class DisplayArea {    - child :Task // Or DisplayArea}class DisplayArea::Token {    - child :WindowToken}class DisplayArea::Dimmable {    - child :DisplayArea}class TaskDisplayArea {    - child :Task // Or TaskDisplayArea}class ActivityRecord {    - child :WindowState    - parent :TaskFragment}class WindowState {    - child :WindowState    - parent :ActivityRecord}class RootDisplayArea {}class DisplayContent {    // 由DisplayContent作为窗口架构的根节点    mTokenMap :Map<WindowToken>}class DisplayAreaGroup {}ConfigurationContainer <|-- WindowContainerConfigurationContainer <|-- WindowProcessControllerWindowContainer <|-- WindowTokenWindowContainer <|-- WindowStateWindowContainer <|-- TaskFragmentWindowContainer <|-- DisplayAreaWindowContainer <|-- RootWindowContainerTaskFragment <|-- TaskWindowToken <|-- ActivityRecordDisplayArea <|-- TaskDisplayAreaDisplayArea <|-- DisplayArea.TokenDisplayArea <|-- DisplayArea.DimmableDisplayArea.Dimmable <|-- RootDisplayAreaRootDisplayArea <|-- DisplayContentRootDisplayArea <|-- DisplayAreaGroup@enduml```--><p><img src="//www.plantuml.com/plantuml/png/fLJFIlj04BxFK-mBzDTxA3zQ53s9KWkUrsIjIpVPiDaeHNifFNdn8WWYHV3cpOjOmRUfZOzXcbOodMx_W3a4ClFDDt--cTGJourDGmM-uad2TdHq9jkfuLRgAF-mN4R2i2k07imX9p8AzANRrzJQBljP_bIOVovLmBnTcSIATwT-4LbAUsIqBv9awZLQAHGUSvFZcUT8GKbQkYCYcdVcEhRSYXBVuabdp_1sc5FJW8PlvOMqtQRmjGb85VCk6aRmHRQ_io0Z9IiILAliqB1DePxdd08Qa3iihoaC-QaID79bnrlLIv28Od50QrGZiyFIbMm8lpKLrQW7U9rnUtZLqHwNovFtcjszBhh6du_Zzu_ivVxhzdaoV9iC1zd3OF8q-hxfP_rH4HOMWXpmc7dvguP4-kzKQT_eD9vNi-9YQzUL2ZtLZLZ7_G7C70IDIdG2i11k0DRFYS0Dkm6kNm5WtZ8J0AfuPYQg0qfNnY7ZCW0P_XN4wo6_bmNWifOjuPn030MAx9uRGzS5wY8Aqb3z0000" alt="Android13窗口模型类图"></p><h1 id="窗口模型架构解析"><a href="#窗口模型架构解析" class="headerlink" title="窗口模型架构解析"></a>窗口模型架构解析</h1><p>新的窗口从WMS.addWindow()开始。首先根据DisplayId取得或创建对应的DisplayContent，然后创建WindowToken、WindowState，建立InputChannel，最后调用DisplayContent.sendNewConfiguration()。然后调用DisplayContent.updateOrientation()和sendNewConfiguration()来更新方向和conf。SurfaceControl由WindowToken管理。</p><h1 id="DisplayContent-sendNewConfiguration"><a href="#DisplayContent-sendNewConfiguration" class="headerlink" title="DisplayContent.sendNewConfiguration()"></a>DisplayContent.sendNewConfiguration()</h1><p>如果addWindow()后方向发生改变，会触发对应Display的Conf更新。</p><p>根据Rotation和DisplayInfo，计算当前屏幕宽高、方向，组装Configuration和WindowConfiguration，将新的Configuraion通过DisplayContent.updateDisplayOverrideConfigurationLocked()更新下去（这个过程还在整个体系中确认Conf是否真的发生了update，如果发生了更新，最后才会设置DisplayContent.mLayoutNeeded）。</p><h2 id="DisplayContent-updateDisplayOverrideConfigurationLocked"><a href="#DisplayContent-updateDisplayOverrideConfigurationLocked" class="headerlink" title="DisplayContent.updateDisplayOverrideConfigurationLocked()"></a>DisplayContent.updateDisplayOverrideConfigurationLocked()</h2><p>更新当前Display对应的conf。对于Default Display更新Global Conf，否则更新override conf。</p><p>对于DEFAULT_DISPLAY，实际上不是仅更新Override Conf，而是直接更新Global Conf（过程中同步更新了Override Conf）:ActivityTaskManagerService.updateGlobalConfigurationLocked()。</p><h3 id="ActivityTaskManagerService-updateGlobalConfigurationLocked"><a href="#ActivityTaskManagerService-updateGlobalConfigurationLocked" class="headerlink" title="ActivityTaskManagerService.updateGlobalConfigurationLocked()"></a>ActivityTaskManagerService.updateGlobalConfigurationLocked()</h3><p>该方法实际上首先更新system_server，然后更新所有App，接着发出Global Conf Changed的广播，最后更新RootWindowContainer。</p><p>首先将system_server所在的进程更新到新的Configuration（通过ActivityThread.applyConfigurationToResources()）。</p><h4 id="WindowProcessController-onConfigurationChanged"><a href="#WindowProcessController-onConfigurationChanged" class="headerlink" title="WindowProcessController.onConfigurationChanged()"></a>WindowProcessController.onConfigurationChanged()</h4><p>然后将新的Global Conf发给系统中所有应用进程：遍历ActivityTaskManagerService.mProcessMap，取得所有pid和对应的WindowProcessController。调用每个WindowProcessController.onConfigurationChanged()，内部使用ConfigurationChangeItem这个Binder，实现将Configuration changed发给Activity，触发Activity资源更新、回调Activity.onConfigurationChanged()。</p><h4 id="广播ACTION-CONFIGURATION-CHANGED"><a href="#广播ACTION-CONFIGURATION-CHANGED" class="headerlink" title="广播ACTION_CONFIGURATION_CHANGED"></a>广播ACTION_CONFIGURATION_CHANGED</h4><p>接着，App Conf更新完成后，调度发出广播ACTION_CONFIGURATION_CHANGED：ActivityTaskManagerService向自己的Handler发送Message，回调broadcastGlobalConfigurationChanged()，发出广播。对于App而言，可以动态监听该广播（在Manifest静态注册无效）。</p><h4 id="RootWindowContainer-onConfigurationChanged"><a href="#RootWindowContainer-onConfigurationChanged" class="headerlink" title="RootWindowContainer.onConfigurationChanged()"></a>RootWindowContainer.onConfigurationChanged()</h4><p>该方法更新系统中WindowContainer树，更新所有节点的Conf，包括ActivityRecord，实现应用新的Configuration。</p><h3 id="ActivityTaskManagerService-ensureConfigAndVisibilityAfterUpdate"><a href="#ActivityTaskManagerService-ensureConfigAndVisibilityAfterUpdate" class="headerlink" title="ActivityTaskManagerService.ensureConfigAndVisibilityAfterUpdate()"></a>ActivityTaskManagerService.ensureConfigAndVisibilityAfterUpdate()</h3><p>上一步updateGlobalConfigrautionLocked()后，紧接着调用ensureConfigAndVisibilityAfterUpdate()。该方法实际上调用top ActivityRecord.ensureActivityConfiguration()，用于应用最新的Conf。</p><p>该步骤的目的是确定Activity是否需要更新到新的Conf（即判断新旧Conf是否一致）并进行更新，然后根据Activity注册的ConfigChanges属性，判断是否需要重启Activity还是回调对应方法。</p><p>此时ActivityRecord的Conf可能已经在上一步updateGlobalConfigurationLocked()发生变化了。</p><p>判断Config不变，直接调用scheduleConfigurationChanged()并返回。</p><p>判断Config有变（shouldRelaunchLocked()），可能提前返回&#x2F;relaunchActivityLocked重启Activity，然后调用scheduleConfigurationChanged()。</p><h4 id="ActivityRecord-scheduleConfigurationChanged"><a href="#ActivityRecord-scheduleConfigurationChanged" class="headerlink" title="ActivityRecord.scheduleConfigurationChanged()"></a>ActivityRecord.scheduleConfigurationChanged()</h4><p>通过Binder ActivityConfigurationChangeItem回调Activity.onConfigurationChanged()。</p><p>这里Binder是ActivityConfigurationChangeItem，而WindowProcessController是ConfigurationChangeItem。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>新的窗口添加或者切换后，如果方向发生变化，会更新Global Conf，并通过WindowProcessController触发回调所有App。在发出广播后，以RootWindowContainer为起点更新各个WindowContainer，最后将顶层Activity的conf再次更新，并触发一次新的绘制。</p><h1 id="App"><a href="#App" class="headerlink" title="App"></a>App</h1><p>App会在WindowProcessController处通过ConfigurationChangeItem回调一次，在ActivityRecord处通过ActivityConfigurationChangeItem回调一次。</p><h2 id="ConfigurationChangeItem"><a href="#ConfigurationChangeItem" class="headerlink" title="ConfigurationChangeItem"></a>ConfigurationChangeItem</h2><p>回调ActivityThread.handleConfigurationChanged()：调用ConfigurationContainer.handleConfigurationChanged()，更新Resources，通过performConfigurationChanged()回调App内已有的各个onConfigurationChanged()回调。</p><h2 id="ActivityConfigurationChangeItem"><a href="#ActivityConfigurationChangeItem" class="headerlink" title="ActivityConfigurationChangeItem"></a>ActivityConfigurationChangeItem</h2><p>回调ActivityThread.handleActivityConfigurationChanged：调用performConfigurationChangedForActivity()-&gt;performActivityConfigurationChanged()：如果Conf的窗口模式变化时触发对应回调；判断当Conf和Resources有public域发生变化时，调用ResourcesManager.updateResourcesForActivity()更新Resources，回调Activity.onConfigurationChanged()。</p><p>然后，调用ViewRootImpl.updateConfiguration()。</p><h3 id="ViewRootImpl-updateConfiguration"><a href="#ViewRootImpl-updateConfiguration" class="headerlink" title="ViewRootImpl.updateConfiguration()"></a>ViewRootImpl.updateConfiguration()</h3><p>调用mView.dispatchConfigurationChanged()，从DecorView开始回调各View的onConfigurationChanged()。</p><p>最后，调用requestLayout()：向ChoreoGrapher注册回调，在下一次屏幕刷新中回调performTraversals()。该方法开始按照新的Configuration执行绘制工作（新的Configuration在上一步即ResourcesManager.updateResources()中更新了，ViewRootImpl.performTraversal()也是使用这个Resources.getConfiguration()来绘制的）。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>ActivityThread在Global Conf对应的从WindowProcessController的回调中，会将新的Configuration通过ConfigurationController进行更新，并回调各个onConfigurationChanged()。</p><p>窗口体系Configuration更新完成后，通过ActivityRecord会再次更新顶层Activity，此时更新的override conf可能和Global Conf并不一致。接着触发一次View Tree的重新绘制，按照新的Conf来显示应用画面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Android 13后窗口模型系列架构存在较大变更，本文围绕WindowContainer总结窗口模型。&lt;/p&gt;
&lt;h1 id=&quot;类图&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android单条日志太长导致被截断的问题分析和解决</title>
    <link href="https://nasdaqgodzilla.github.io/2022/12/28/Android%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E8%A2%AB%E6%88%AA%E6%96%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <id>https://nasdaqgodzilla.github.io/2022/12/28/Android%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E8%A2%AB%E6%88%AA%E6%96%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/</id>
    <published>2022-12-28T01:45:16.000Z</published>
    <updated>2022-12-28T01:47:57.411Z</updated>
    
    <content type="html"><![CDATA[<hr><p>9:20 AM<br>Wednesday, December 28, 2022 (GMT+8)<br>Time in Guangzhou, Guangdong Province, China</p><hr><p>[toc]</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通常在Android中使用<code>logcat</code>输出查阅日志，但有时日志很长，可能会被截断，显示不完整。</p><blockquote><p>注意，这里指的是单条日志太长了被截断了，不是指日志太多了被冲掉了</p></blockquote><p>本文研究日志被截断的原因，并给出修改方法。</p><p>首先日志被截断的原因有如下几种，其中第一种是首要原因：</p><ol><li>单条日志长度上限，日志如果太长，触及上限则会被截断</li><li>日志如果涉及序列化、binder传输，则受到binder传输上限的限制</li><li>底层（Linux、log设备）限制、系统调用限制</li></ol><p>注意，单条日志长度上限是指一次打印的日志的长度，不是指设置-开发者选项-日志缓冲区大小。</p><h1 id="查看日志缓冲区大小、单条日志大小"><a href="#查看日志缓冲区大小、单条日志大小" class="headerlink" title="查看日志缓冲区大小、单条日志大小"></a>查看日志缓冲区大小、单条日志大小</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#:/ logcat -g</span><br><span class="line">main: ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">15</span> MiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br><span class="line"><span class="built_in">system</span>: ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">6</span> MiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br><span class="line">crash: ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">13</span> KiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br><span class="line">kerne<span class="variable">l:</span> ring <span class="keyword">buffer</span> <span class="keyword">is</span> <span class="number">16</span> MiB (<span class="number">3</span> MiB consumed), <span class="built_in">max</span> entry <span class="keyword">is</span> <span class="number">5120</span> B, <span class="built_in">max</span> payload <span class="keyword">is</span> <span class="number">4068</span> B</span><br></pre></td></tr></table></figure><p>通过<code>logcat -g</code>指令可以读到各个分类的缓冲区上限、目前用量、每次读取量、单条日志长度的上限。</p><h1 id="调节日志缓冲区大小"><a href="#调节日志缓冲区大小" class="headerlink" title="调节日志缓冲区大小"></a>调节日志缓冲区大小</h1><ul><li>法1: 开发者模式-设置日志缓冲区大小</li><li>法2: 通过<code>logcat -G</code>即可设置，等同于法1</li></ul><h1 id="调节单条日志大小"><a href="#调节单条日志大小" class="headerlink" title="调节单条日志大小"></a>调节单条日志大小</h1><p>修改代码根目录下的<code>system/core/liblog/include/log/log_read.h</code>下的<code>LOGGER_ENTRY_MAX_PAYLOAD</code>和<code>LOGGER_ENTRY_MAX_LEN</code>。</p><p>修改后，需要重新编译如下三个模块: <code>liblog logd logcat</code>，推入设备，重启方能生效。(通过<code>logcat -g</code>可以验证修改)</p><p>不同Android版本在不同位置，<a href="https://cs.android.com/android/platform/superproject/+/master:system/logging/liblog/include/log/log_read.h;l=55?q=LOGGER_ENTRY_&sq=">比如这个</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;9:20 AM&lt;br&gt;Wednesday, December 28, 2022 (GMT+8)&lt;br&gt;Time in Guangzhou, Guangdong Province, China&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android三方应用UI自动化测试探索</title>
    <link href="https://nasdaqgodzilla.github.io/2022/11/07/Android%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8E%A2%E7%B4%A2/"/>
    <id>https://nasdaqgodzilla.github.io/2022/11/07/Android%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8E%A2%E7%B4%A2/</id>
    <published>2022-11-07T11:59:11.000Z</published>
    <updated>2022-11-07T12:00:38.558Z</updated>
    
    <content type="html"><![CDATA[<hr><p>3:49 pm<br>Thursday, 20 October 2022 (HKT)<br>Time in Hong Kong</p><hr><ul><li><a href="#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%BB%B7%E5%80%BC">三方应用UI自动化的价值</a><ul><li><a href="#%E4%B8%9A%E5%8A%A1%E7%97%9B%E7%82%B9">业务痛点</a></li></ul></li><li><a href="#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%BE%E9%A2%98%E5%92%8C%E9%9A%90%E6%82%A3">三方应用UI自动化的技术难题和隐患</a><ul><li><a href="#app-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E8%B7%B5">App UI自动化测试的一般实践</a></li><li><a href="#app-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF">App UI自动化的基础技术</a></li><li><a href="#%E4%B8%89%E6%96%B9app-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%BE%A7%E9%87%8D">三方App UI自动化的侧重</a></li></ul></li><li><a href="#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E9%80%89%E5%9E%8B">三方应用UI自动化的选型</a><ul><li><a href="#1-%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86">1. 自动遍历</a></li><li><a href="#2-%E5%9B%BE%E5%83%8F%E6%8A%80%E6%9C%AF">2. 图像技术</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li><li><a href="#%E5%8F%82%E8%80%83%E5%B7%A5%E5%85%B7">参考工具</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="三方应用UI自动化的价值"><a href="#三方应用UI自动化的价值" class="headerlink" title="三方应用UI自动化的价值"></a>三方应用UI自动化的价值</h1><p>从设备厂商的视角来看，Android App的UI实现方式错综复杂，采用的UI技术栈层出不穷，以及需要进行显示适配的新型场景（如平行世界、窗口模式、画中画、桌面模式和折叠屏）井喷式涌现。</p><p>大部分的三方应用测试通常仅关注UI功能、冒烟测试，测试流程枯燥、重复，且业界有成熟的UI自动化基础，因此通常在三方应用兼容性测试中接入一定程度的自动化测试。</p><p>在这个大背景下，相对于一方&#x2F;二方应用而言，数量庞大、纯黑盒、架构复杂多样的三方应用，主要<strong>在以下几个场景中存在几个痛点</strong>。</p><h2 id="业务痛点"><a href="#业务痛点" class="headerlink" title="业务痛点"></a>业务痛点</h2><h4 id="1-技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的"><a href="#1-技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的" class="headerlink" title="1. 技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的"></a>1. 技术、市场因素等构成的现状，决定了厂商对三方应用的兼容性的工作量是不自主的、单调增长的</h4><p>三方应用UI测试投入不小，但在没有直接经济效益的前提下又不得不投入。不论测试方法以手工进行、自动化测试、混合进行，对QA资源的消耗都是巨大且不受控的。</p><h4 id="2-效率显著低于一方应用"><a href="#2-效率显著低于一方应用" class="headerlink" title="2. 效率显著低于一方应用"></a>2. 效率显著低于一方应用</h4><p>高效的自动化要求QA<strong>掌握被测应用的业务、版本变更点</strong>，以及与QA配合的<strong>自动化测试友好的应用接口</strong>。</p><p>对于三方应用，业务的不透明决定了QA设计的case<strong>不能紧咬变更点</strong>，<strong>无法设计最符合业务逻辑的测试方案</strong>。</p><p>此外，被测三方应用可能<strong>没有自动化UI测试接口</strong>，或<strong>自动化测试接口本身就不易被非App自身人员使用</strong>。</p><blockquote><p>就算条件成立，也不可能对成百上千的应用都勤力投入，通常舍弃覆盖程度</p></blockquote><p>通常，高效的UI自动化测试会通过POA模型、Page Factory模型等，借助工业级的自动化框架和思想，由RD与QA配合，从设计-开发-测试形成闭环，产出可维可测性高的产品——但仅局限于一方应用之内，厂商和其他外部并不能从中受益，用起来自动测试。</p><blockquote><p>相当一部分应用并未设计自动化基建，即使是应用方自身都需要花费大量精力才能用起自动UI测试</p></blockquote><h4 id="3-测不到位或过度测试"><a href="#3-测不到位或过度测试" class="headerlink" title="3. 测不到位或过度测试"></a>3. 测不到位或过度测试</h4><p>三方应用并非自研，且属于纯黑盒，并在成本因素制约下，对三方应用的UI测试（包括UI自动化测试）<strong>追求高覆盖率是不现实的</strong>、不科学也不可能的，但是仍然尝试追求一定程度的覆盖。这个<strong>覆盖的程度难以衡量、覆盖率目标也难以估量制定</strong>，也不依靠分析和讨论得出。</p><p>三方应用在没有公开或共享其热点流程时，黑盒的UI测试（包括按照一定case进行的手工&#x2F;自动测试、Monkey测试）<strong>通常不能拦截全部的关键流程</strong>。</p><p>当然，也有过度测试或冗余测试的情况。</p><blockquote><p>总结来说就是测试覆盖目标、测试覆盖率、测到什么程度，是非曲直，难以论说</p></blockquote><h4 id="4-投入产出不理想"><a href="#4-投入产出不理想" class="headerlink" title="4. 投入产出不理想"></a>4. 投入产出不理想</h4><p>在三方应用UI自动化测试场景下，有时QA或RD完成一组自动化case的设计、编码、验证后，发现花费的时间是手工测试的10倍甚至更多。这一投入产出比若是常态，则显然不可接受。</p><p>在紧急情况下，有时手工测试一把梭哈更加可靠，甚至可能废弃掉团队积累的自动测试方法。</p><p>这一“轻舟已过万重山”的寓景还不是最严峻的挑战，当三方应用更新后，迫于三方应用实现的多样性、厂商侧的自主性等不可抗力，<strong>自动化脚本&#x2F;工具&#x2F;case可能会很遗憾地失效</strong>，失去其“Once write, run forever”的愿景。</p><blockquote><p>Martin Flower：“GUI测试用例还很脆弱，如对系统的一些修正可能导致很多用例的失败，这时候你需要重新录制。你可以放弃录制的方法来解决这个问题，通过写GUI测试代码，但是这样效率非常低。就算你已经很精通了GUI测试代码的编写，端到端的GUI测试用例也很容易出现不可预期结果的问题，因此，基于GUI的自动化测试是脆弱、耗时（包括用例维护和执行）的。GUI测试用例能覆盖到主业务流程即可。”</p></blockquote><h4 id="5-边际效益递减"><a href="#5-边际效益递减" class="headerlink" title="5. 边际效益递减"></a>5. 边际效益递减</h4><p>根据敏捷开发模型，也出于对三方应用UI测试的展望，随着<strong>UI自动化的加深，其收益是边际递减的</strong>。</p><blockquote><p>参考Mike Cohn，自动化金字塔模型</p></blockquote><p><img src="https://s1.ax1x.com/2022/10/20/xyzaQI.png" alt="UI边际效益递减.png"></p><p>事实上，三方应用UI测试的收益曲线更加复杂，它可能不是单调简单的，对三方应用UI测试投入地更多，最终综合效率和成果的收益可能不增长甚至反而下降。</p><h4 id="6-支撑自研应用商店"><a href="#6-支撑自研应用商店" class="headerlink" title="6. 支撑自研应用商店"></a>6. 支撑自研应用商店</h4><p>应用合规分析（静态、动态分析）、自动审核&#x2F;上架、UI自动化测试是应用商店运营的重要支撑。此时UI自动化测试将从研发质量、兼容性的范畴扩展到运营、对接层面。</p><p>除此之外，三方应用的UI测试与一方二方应用的UI测试的特点无异：</p><ol><li>枯燥，重复</li><li>成本，时间</li><li>扩展，重用</li><li>探索性case的测试</li></ol><blockquote><p>一方：指的是本团队的项目，如内置应用（易于进行白盒&#x2F;黑盒测试）<br>二方：一方使用的可能是其他部分研发的、外部引入的应用&#x2F;包&#x2F;库（不难进行白盒&#x2F;黑盒测试，通常集成到一方后进行测试）<br>三方：第三方的应用，如应用市场下载的应用（几乎没有通用的白盒方法，黑盒测试囿于复杂性难以实现通用化；不熟悉主程；难以衡量覆盖率；迭代不可控、测试节奏不自主）</p></blockquote><h1 id="三方应用UI自动化的技术难题和隐患"><a href="#三方应用UI自动化的技术难题和隐患" class="headerlink" title="三方应用UI自动化的技术难题和隐患"></a>三方应用UI自动化的技术难题和隐患</h1><p>实现对应用的UI自动化测试将给团队带来效率和体验的提升、研发质量的改善，基于这一类的愿景，业界提出了大量的测试思想，落地了强大了工具、框架。</p><p>但是对于三方应用UI自动化测试的实现，主要受限于纯黑盒的环境、数量众多的各三方App，以及有限的成本预算、紧迫的时间，尚无简单高效的方案可供直接使用或参考。</p><p>本节总结<strong>三方应用UI自动化测试的难点</strong>，并铺垫下文对三方应用UI自动化方案的探索。</p><h2 id="App-UI自动化测试的一般实践"><a href="#App-UI自动化测试的一般实践" class="headerlink" title="App UI自动化测试的一般实践"></a>App UI自动化测试的一般实践</h2><p>UI自动化测试通常要求App具有如下内在特点：</p><ol><li>软件需求变动不频繁<br> 否则建议在UI测试（包括对自动化的开发）中投入占比不超过20%（因为（半）手工方式更快，具体方案见敏捷类方法）</li><li>产品更新维护周期长<br> 否则跑UI自动化的次数不够多，收益不够大</li><li>比较频繁的回归测试<br> 根据自动化金字塔，UI测试属于（相对于金字塔底层的接口测试、单元测试而言）执行效率低、复杂度高（脆弱）、问题出现后分析链路长的一般在回归测试时进行的测试</li><li>自动化测试脚本可以重复使用、易于回放<br> 脚本如果不能重用，无法”回本”，即得不偿失</li></ol><p>也就是说，<strong>UI测试是分场景</strong>的，<strong>场景决定了UI自动化测试是否值得</strong>。</p><p>测试金字塔是一个理想状态下软件测试模型。三层分别是UI测试、集成测试和单元测试。金字塔从下往上，可维可调性越差，效率越低。越接近底层所能达到的覆盖率越高。</p><p><img src="https://s1.ax1x.com/2022/10/20/x6ZM6S.png" alt="测试金字塔.png"></p><blockquote><p>UI测试应该投入的资源就如金字塔塔尖一样，占比最小，且靠后进行</p></blockquote><p><img src="https://s1.ax1x.com/2022/10/20/x6mmM8.png" alt="测试金字塔及反模式.png"></p><blockquote><p>对三方应用的UI自动化测试无法像一方应用那样易于进行，投入占比也很难有成熟的模型来衡量。但三方应用本身的“三方”特性，我们可以肯定，三方应用相关的UI自动化测试代码越少越好，总体投入越少越好。</p></blockquote><p>对于三方应用UI自动化的场景，其更加尖锐的效率要求、恶劣的自动化条件（业务是黑盒、逻辑是黑盒、Apk内建自动化接口是黑盒），使之<strong>具有了象征更高要求的特点</strong>：</p><ol><li>自动化设施必须是跨UI技术栈的<br> 要满足各种UI技术栈，不像单个应用的UI自动化那样支持单一的特定的自动化框架即可。</li><li>低代码乃至于无代码<br> 三方应用众多且迭代不受控，自动化代码越多，其保值能力就越脆弱。</li></ol><p>在尽可能满足以上几点要求、兼顾低代码、高效率，可以推导出符合三方应用UI自动化测试需求的方案应该满足以下几点：</p><ol><li>具备识别各类型UI的能力：原生、WebView、Flutter、Cocos、Unity、React…</li><li>具备各类型UI的点击能力</li><li>对三方应用，不关注业务流程，只关注一定程度的不要太低的覆盖率（“界面点点点的深度、广度”）：要有自动“点点点”的能力，能划屏更佳</li><li>低代码，不&#x2F;少写保质期短、制作耗时的测试脚本</li></ol><p>那么总结来说，这个工具应该是<strong>自动遍历各类界面并点点点</strong>。</p><p>Android单个应用的UI自动化具有完善的工业级技术，我们看看这些基础技术能否使用或参考。</p><h2 id="App-UI自动化的基础技术"><a href="#App-UI自动化的基础技术" class="headerlink" title="App UI自动化的基础技术"></a>App UI自动化的基础技术</h2><p>Android UI自动化框架的主要能力是界面感知和界面操作。一个完整的自动化UI测试操作是首先完成<strong>待点击、滑动区域的识别</strong>，然后完成<strong>界面操作和导航</strong>。</p><p>对于业界先进的方案，主要如下。</p><p><img src="https://s1.ax1x.com/2022/10/21/x6cvWj.png" alt="AndroidUI自动化.png"></p><p>UI自动化测试中重要也是耗费精力的一环，就是借助UI技术提供的机制编写代码、操作、录制，实现UI感知，即UI控件识别、定位。主要分为如下两种类型的实现。</p><p><img src="https://s1.ax1x.com/2022/10/21/xcixZn.png" alt="UI自动化测试定位方法.png"></p><table><thead><tr><th>分类</th><th>原理</th><th>兼容能力</th><th>优点</th><th>缺点</th><th>代表作</th></tr></thead><tbody><tr><td>图像技术</td><td>通过图像识别来分析和查找操作区域</td><td>应用无侵入，依靠图像因而可以无视UI技术差异，兼容能力强</td><td>避免繁琐的界面分析定位、自动化脚本，上手更快；兼容各UI栈</td><td>图像识别在准确率、耗时、模型大小等需要投入</td><td>Airtest + Poco</td></tr><tr><td>原生定位能力</td><td>Android内置无障碍服务提供ViewTree解析能力，自动化工具借助它来分析UI结构、发出操作事件</td><td>三方应用UI实现具有随意性，存在相当比例的应用难以编写自动化脚本</td><td>定位准确；在稳定迭代的项目中发挥更佳</td><td>借助无障碍服务提供的ViewTree，存在IPC耗时、ViewTree解析耗时，测试速度慢；自动化脚本保质期短（尤其是三方应用）</td><td>Appium</td></tr></tbody></table><blockquote><p>兼容能力：Android UI技术栈众多，UI自动化测试得以进行的基础是这个UI技术栈维护的ViewTree或DOM易于获取、解析。多种不同技术栈之间差异较大，主要分为原生、WebView、React、Cocos、Unity、Flutter等。</p></blockquote><blockquote><p>应用侵入：为了满足自动化测试，必须注入到应用进程中，或者要求应用接入SDK</p></blockquote><h2 id="三方App-UI自动化的侧重"><a href="#三方App-UI自动化的侧重" class="headerlink" title="三方App UI自动化的侧重"></a>三方App UI自动化的侧重</h2><p>从上文两类界面感知方法及其配套的界面操作方法各有千秋，在不同的场景下各有优劣。在这些特性的基础上，三方应用UI自动化实际上更依赖于以下几个特性来确保效率。</p><ul><li>跨UI技术栈的兼容性</li><li>低代码</li><li>自动遍历Clickable、Scrollable控件并完成操作</li><li>进行的UI测试具有一定的深度、广度，能够测试到足够多的UI界面</li></ul><p>对于图像技术而言，实现上述功能在整体难度上暂且不表，而逻辑上则较简单——即通过图像技术分析画面，分类出符合的控件，并按照一定逻辑组织自动测试（深度优先、广度优先）流程。</p><p>前面分析过，图像技术本身的原理以及对UI的实现技术栈的独立性，天生就决定了其在跨UI技术栈兼容性会表现更佳，且模型的成熟度影响测试深度、广度。此外，由于图像分析避免了原生定位中要求的繁琐代码实现，因此其低代码属性也是与生俱来。</p><p>对比来看，在针对三方应用UI自动化而言，由于客观上UI技术的多样性、碎片化，以及主观上对原生定位接口即自动化脚本的开发具有脆弱性，原生定位方案在跨UI技术栈兼容性这一方面较弱，同时针对一个应用的一个场景，所投入的资源、产出的代码量也较大，不适合与大量三方应用的场景。</p><p>为了在三方应用UI自动化这种要求低代码、高兼容性的黑盒场景中取得更高的效率、更低的投入，要求自动化设施必须具有下面这些特性。</p><table><thead><tr><th>特性</th><th>目的</th><th>原理</th><th>技术方案</th></tr></thead><tbody><tr><td>兼容多UI技术栈</td><td>应对三方应用多样、脆弱的UI技术栈</td><td>同时具有原生定位能力和图像技术定位能力</td><td>原生定位方案+机器学习&#x2F;视觉方案</td></tr><tr><td>低代码甚至无代码</td><td>减少自动化脚本成本、防止陷入过低的投入产出比</td><td>避免进行界面定位工作、自动化脚本编码工作</td><td>将原生能力、图像技术能力得到的界面信息转化为树、图等进行遍历，抛弃xpath、图像匹配等的遍历</td></tr></tbody></table><h4 id="小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。"><a href="#小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。" class="headerlink" title="小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。"></a>小结：放弃xpath等“精确定位”的编码工作，通过自动遍历实现低代码；结合机器学习、机器视觉提高对多种UI技术栈的兼容性。</h4><h1 id="三方应用UI自动化的选型"><a href="#三方应用UI自动化的选型" class="headerlink" title="三方应用UI自动化的选型"></a>三方应用UI自动化的选型</h1><p>在常规的传统的UI自动化测试的基础上，由于原生定位能力相关的技术较完善成熟，对三方应用的UI自动化重点关注“自动遍历”和“图像技术”辅助。</p><h2 id="1-自动遍历"><a href="#1-自动遍历" class="headerlink" title="1. 自动遍历"></a>1. 自动遍历</h2><p>对于非图像处理技术的定位方案，通常自动化测试的主要投入是对界面的分析工作、对界面的自动化编码。这两大步骤是UI自动化测试中最大的投入之一，同时也是“脆弱性”即自动化脚本时效性的来源。</p><p>事实上，App的界面和控件可以被抽象成树型结构。</p><ul><li>App的所有UI界面可以抽象成树，界面之间的跳转即树的连接路径，各个界面为叶子或根节点</li><li>App的一个UI界面中的所有控件是树形结构组织的（ViewRootImpl树），各个控件总是能够从父节点经过路径到达</li><li>部分UI技术提供的“树”可能需要结合图像技术才能完整确定</li></ul><p>基于原生定位能力实现的自动化设施主要的耗时点（尤其是针对三方应用）在于分析该UI树，找到关键控件的关键信息，编写自动化脚本完成定位、操作和导航。</p><p>自动遍历的核心在于忽略“树”的细节，从根节点开始，遍历整个UI树和控件树，在摒弃自动化脚本的同时实现对UI的遍历，达成和自动化脚本接近的自动操作效果。</p><p><img src="https://s1.ax1x.com/2022/10/25/xRRqtP.png" alt="二叉树_前序遍历"></p><p>从策略上看，遍历通常有DFS（深度优先）和BFS（广度优先）。对大多数应用而言，DFS效率更高，需要跳转界面的频次较低。</p><p>从方案上看，由于原生定位能力和图像技术均能建立抽象UI树，因此自动遍历也有这两种方案。一般而言，原生定位能力实现的难度较低（因为UI树是App现成的自带的），但是考虑到UI多样性和跨UI栈兼容能力的脆弱性，图像技术是很重要的补充（尤其是针对三方应用）。</p><h2 id="2-图像技术"><a href="#2-图像技术" class="headerlink" title="2. 图像技术"></a>2. 图像技术</h2><p>图像技术最直接的作用是支持那些无法被原生定位能力所支撑的应用的自动化测试。但实践来看，图像技术对测试效率的提升、测试时长方面有显著的优势，这超出了其增强UI兼容性的最基本需要。</p><p>出于原生定位能力自身的局限、三方应用UI的脆弱性（技术栈多、保质期短、自动化不友好），为了提升原生定位能力不够用的多技术栈兼容能力，通过图像技术来识别和分析界面的研究已经在业界取得众多成果。</p><p><img src="https://s1.ax1x.com/2022/10/25/xRf6G6.png" alt="UI视觉分析.png"></p><p>图像技术超脱了UI技术实现的细节，因而摆脱了基于原生定位能力的自动化设施的脆弱性。在针对数量广大的三方应用的自动化测试场景中不可或缺，决定了自动遍历阶段的输入的完整性和高效性。</p><p>同时，图像技术在辅助甚至主导界面感知之外，还可能提供不菲的效率提升。原生定位能力所提供的界面感知能力的优点是精细，适合一方应用开发使用。在数量众多的三方应用的自动化测试方面，除了存在效率、脆弱性等隐患以外，其测试速度也较低。</p><p>原生定位能力基于UI树来进行界面感知、界面点击。由于对树（或图）的分析非常耗时（对树的节点们都进行分析若干个属性），且在设备端无障碍服务需要通过IPC（Binder）来与App交互。因此，从原理上（树的分析）和工程上（IPC）导致其效率不高。实践数据来看，其测试速度慢于图像技术。分部分来看，其界面感知速度较慢（树的分析慢于图像分析），操作速度也慢于直接发送触摸事件。</p><blockquote><p>原生定位能力对混合应用存在较大兼容问题。如React虚拟DOM的情况，每当页面更新会触发生成新的DOM，导致UI树变化，需要重新进行分析。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>三方应用的自动化测试工具，通过同时支持原生定位能力和图像能力作为界面感知技术来应对三方应用UI自动化的脆弱性，并在界面操作方面通过自动遍历来实现低代码，解决在投入产出比、效率方面的隐患。</p><h2 id="参考工具"><a href="#参考工具" class="headerlink" title="参考工具"></a>参考工具</h2><p>对于原生定位能力、图像技术、自动遍历等技术，较适合三方应用场景的有如下几个工具。</p><table><thead><tr><th>分类</th><th>方案</th><th>原理</th><th>描述</th></tr></thead><tbody><tr><td>原生定位能力</td><td>Appium</td><td>通过无障碍服务取得UI树</td><td>提供界面感知能力，对多种UI技术栈兼容性较佳，但是没有完整达到三方应用自动化的需求</td></tr><tr><td>自动遍历</td><td>AppCrawler</td><td>基于Appium，对UI树进行自动遍历</td><td>UI兼容性没有完整达到三方应用自动化的需求；测试速度较慢</td></tr><tr><td>图像技术</td><td>Poco Airtest</td><td>Poco进行图像匹配，Airtest进行测试流程</td><td>编码较原生定位能力更少，但是仍然需要编码</td></tr><tr><td>图像技术+自动遍历+原生定位能力混合</td><td>Fastbot</td><td>多种技术结合</td><td>兼容性强，能够自动遍历；但是自动遍历方案不是完整的深度遍历</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>RD: 研发</li><li>QA: 质量（包括测试、测开）</li><li>《Succeeding with Agile: Software Development using Scrum 》(Scrum敏捷软件开发) Mike Cohn</li><li><a href="https://developer.android.com/training/testing/fundamentals">Android Developer 测试最佳实践</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;3:49 pm&lt;br&gt;Thursday, 20 October 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8ui%E</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：分析数据库事务性能瓶颈与优化方案</title>
    <link href="https://nasdaqgodzilla.github.io/2022/11/03/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E4%B8%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>https://nasdaqgodzilla.github.io/2022/11/03/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E4%B8%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2022-11-03T13:08:48.000Z</published>
    <updated>2022-11-03T13:09:42.662Z</updated>
    
    <content type="html"><![CDATA[<hr><p>10:59 am<br>Tuesday, 1 November 2022 (HKT)<br>Time in Hong Kong</p><hr><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a><ul><li><a href="#%E7%9B%AE%E6%A0%87">目标</a></li></ul></li><li><a href="#%E7%8E%AF%E5%A2%83%E3%80%81%E5%B7%A5%E5%85%B7">环境、工具</a><ul><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E5%B7%A5%E5%85%B7">工具</a></li></ul></li><li><a href="#%E8%A7%82%E6%B5%8B">观测</a><ul><li><a href="#1-trace%E4%B8%8A%E7%9C%8B%E7%93%B6%E9%A2%88%E6%98%AF%E5%AD%98%E5%82%A8">1. Trace上看瓶颈是存储</a><ul><li><a href="#11-%E6%A3%80%E9%AA%8Cfdatasync%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%80%97%E6%97%B6">1.1 检验fdatasync是否真的耗时</a></li></ul></li><li><a href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%B2%A1%E6%9C%89%E8%B7%91%E6%BB%A1io%E6%9E%81%E9%99%90">2. 数据库测试没有跑满IO极限</a><ul><li><a href="#21-%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9dd%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D">2.1 系统缓冲区对dd性能的影响</a></li><li><a href="#22-%E4%BC%B8%E7%BC%A9io%E8%B5%84%E6%BA%90%E5%8F%91%E7%8E%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%88%90%E7%BB%A9%E5%BD%B1%E5%93%8D%E6%9C%89%E9%99%90">2.2 伸缩IO资源发现对数据库测试成绩影响有限</a></li></ul></li><li><a href="#3-cpu%E8%B5%84%E6%BA%90%E5%88%B6%E7%BA%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%91%E5%88%86">3. CPU资源制约数据库跑分</a><ul><li><a href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%8D%E5%90%8C%E6%A0%B8%E5%BF%83%E5%BE%97%E5%87%BA%E7%9A%84%E8%B7%91%E5%88%86%E6%88%90%E7%BB%A9:-%E5%A4%A7%E5%B0%8F%E6%A0%B8%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82">绑定到不同核心得出的跑分成绩: 大小核性能差异</a></li><li><a href="#%E5%AE%9A%E9%A2%91%E5%B8%A6%E6%9D%A5%E8%B7%91%E5%88%86%E6%8F%90%E5%8D%87:-%E5%BC%BA%E5%88%B6%E6%8F%90%E9%AB%98CPU%E9%A2%91%E7%8E%87">定频带来跑分提升: 强制提高CPU频率</a></li></ul></li></ul></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们的设备经过性能测试，在IO测试阶段、数据库操作部分的跑分显著与对比机拉开差距，且跑分结果怪异：常规的<strong>串行读写、随机读写与对比机成绩差距细微，但是数据库操作居然差距巨大</strong>。</p><p><img src="https://s1.ax1x.com/2022/11/01/xT7C0s.png" alt="数据库跑分对比"></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>从表中可以看到，两者<strong>常规IO成绩接近，但是数据库事务差距一倍以上</strong>。我们需要分析跑分差异的原因，并定位设备和系统的性能瓶颈。</p><ol><li>分析跑分差异根因；为什么数据库读写会意外地落差巨大？</li><li>定位性能瓶颈；性能瓶颈是来自存储吗？</li></ol><h1 id="环境、工具"><a href="#环境、工具" class="headerlink" title="环境、工具"></a>环境、工具</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table><thead><tr><th>设备</th><th>软件环境</th><th>硬件环境</th><th>跑分手法</th></tr></thead><tbody><tr><td>MT8183</td><td>Android 10 + 不加后台负载</td><td>MT8183 + 4GB LPDDR4X + mmc</td><td>AndroBench V5.0.1 测试data分区，数据库事务size&#x3D;1; 启用Index Usage; Journal Mode&#x3D;WAL;</td></tr><tr><td>对比机 QCOM 660 AIE</td><td>Android 9 + 不加后台负载</td><td>QCOM 660 AIE + 4GB LPDDR4</td><td>同上</td></tr></tbody></table><blockquote><p>注意，IO测试与存储芯片有相关性，这里用mmc来表示，忽略具体的存储芯片型号和性能。</p></blockquote><blockquote><p>具体原因是：1. 没有取得机器们的存储芯片的准确的型号和性能参数；2. 两者在Antutu BenchMark和AndroBench的串行读写、随机读写的成绩几乎一致——因此可以认为两个机器的存储性能接近（起码是跑分场景的性能接近），所以<strong>忽略存储芯片差异，不影响分析</strong>。</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>工具</th><th>目的</th><th>使用</th></tr></thead><tbody><tr><td>AndroBench V5.0.1</td><td>数据库跑分</td><td></td></tr><tr><td>strace</td><td>统计系统调用耗时</td><td>strace -qc -pPID</td></tr><tr><td>top</td><td>查看线程CPU、Per CPU Usage</td><td>busybox top -d1 转H、转1</td></tr><tr><td>top</td><td>查看线程状态</td><td>top -m15 -H -pPID</td></tr><tr><td>iostat</td><td>看IO信息</td><td>busybox iostat -cdtzm 1</td></tr><tr><td>TraceView</td><td>看Trace</td><td></td></tr><tr><td>taskset</td><td>对跑分软件绑核</td><td>taskset -ap MASK PID</td></tr><tr><td>drop_caches</td><td>强制系统丢弃cache</td><td>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</td></tr><tr><td>sync</td><td>写入脏buffer到磁盘</td><td>sync</td></tr><tr><td>CPU定频</td><td>让CPU运行在最高频</td><td><a href="https://nasdaqgodzilla.github.io/2022/11/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9ACPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E5%AE%9A%E9%A2%91%EF%BC%88MTK%EF%BC%89/">链接</a></td></tr></tbody></table><h1 id="观测"><a href="#观测" class="headerlink" title="观测"></a>观测</h1><p>本节通过一些观测手法来尝试分析和定位性能瓶颈。</p><h2 id="1-Trace上看瓶颈是存储"><a href="#1-Trace上看瓶颈是存储" class="headerlink" title="1. Trace上看瓶颈是存储"></a>1. Trace上看瓶颈是存储</h2><p>首先再次在机器上跑一次AndroBench数据库测试，并抓一次trace。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7FAl4.png" alt="8183_perfetto.png"></p><p>可以看到<code>sys_fdatasync</code>耗时很长，整个数据库事务提交过程绝大部分在<code>fdatasync()</code>。乍一看似乎瓶颈是存储性能，但由于trace机制粒度较粗，细节较少，其实目前还没有足够的证据证实。Anyway，先继续分析，暂时不做出性能瓶颈是存储的结论。</p><blockquote><p>Trace上有很多层的<code>sys_fdatasync</code>，虽然它记录的耗时很长但是不一定能真实反应data sync耗时真的很长。实际上很可能是对fdatasync trace end的调用放到了整个过程的后面，即实际上sync工作完成之后一段时间才结束这个tag的trace，因而data sync的记录很长，且记录的耗时可能远远高于实际耗时。</p></blockquote><ul><li><p>小结1：Trace目前没有可靠地提示一些信息</p></li><li><p>小结2: 根据Trace的实现机制，认为该Trace记录可能不准确</p></li></ul><h3 id="1-1-检验fdatasync是否真的耗时"><a href="#1-1-检验fdatasync是否真的耗时" class="headerlink" title="1.1 检验fdatasync是否真的耗时"></a>1.1 检验fdatasync是否真的耗时</h3><p>从Linux man可以查阅到，<code>fdatasync()</code>和<code>fsync()</code>都是会阻塞直到数据完成写入的。那么我们可以通过检查IO线程的挂起状态的占比即可确认线程是否在等待IO时消耗了过长的时间。</p><blockquote><p>The call blocks until the device reports that the transfer has completed。</p></blockquote><p><img src="https://s1.ax1x.com/2022/11/01/x71ZTS.png" alt="x71ZTS.png"></p><p>从trace可以看到，线程在IO等待方面耗时很小。</p><ul><li>小结：IO flush操作耗时不是性能瓶颈</li></ul><h2 id="2-数据库测试没有跑满IO极限"><a href="#2-数据库测试没有跑满IO极限" class="headerlink" title="2. 数据库测试没有跑满IO极限"></a>2. 数据库测试没有跑满IO极限</h2><p>从上面的分析来看，并没有严丝合缝的证据表明数据库事务测试碰到了IO瓶颈。本节通过一些方法检验该机器的数据库测试性能瓶颈不是IO，并设计一些实验来进行一些额外的观测。</p><p>与顺序&#x2F;随机读写测试对比而言，数据库CRUD的特点是QPS高，但是数据量低。表现在IO上，前者消耗更多的IO资源，而后者通常需要高并发来取得高IO占用。</p><p>顺序&#x2F;随机读写测试，消耗很低的CPU，触及IO极限：</p><p><img src="https://s1.ax1x.com/2022/11/01/x73Q4e.png" alt="顺序读写测试资源占用.png"></p><ul><li>上图结果可见，该机器的IO极限约90附近。CPU消耗低且处于IO wait。下图为数据库跑分阶段：</li></ul><p><img src="https://s1.ax1x.com/2022/11/01/x73ovR.png" alt="数据库事务测试资源占用.png"></p><ul><li><p>数据库CRUD测试远远达不到IO极限（仅峰值的10%+），但是需要付出巨大的CPU代价。注意，CPU消耗占比中，<strong>USER和SYS占比上升几倍，而IO wait接近可以忽略，表明此时CPU是“真忙”，而不是在等待IO中的“假忙”</strong>。</p></li><li><p>小结：<strong>数据库事务测试没有跑到IO极限，且针对该设备，数据库CRUD是计算资源敏感型</strong></p></li></ul><p>通常来说数据库性能除了与硬件相关，还与数据库库表设计、磁盘缓冲、内存操作容量等因素相关。但是在IO性能测试场景，由于和对比机使用的测试工具是一致的，因此需要忽略数据库的设计、操作方法、缓存方案、并发数、连接数，而重点关注其他的具有差异的因素对数据库性能的影响。如下：</p><ul><li>系统缓存策略</li><li>CPU性能</li><li>存储性能</li></ul><p>由于在数据库事务测试中发现没有跑满IO，因此<strong>尝试伸缩IO资源来检验性能瓶颈</strong>。</p><h3 id="2-1-系统缓冲区对dd性能的影响"><a href="#2-1-系统缓冲区对dd性能的影响" class="headerlink" title="2.1 系统缓冲区对dd性能的影响"></a>2.1 系统缓冲区对dd性能的影响</h3><p>Linux系统IO实现是分层的，一些上层的测试方法可能因缓冲区策略、大小不同而出现不同的测试成绩。本小结测试缓冲区对dd的性能影响。</p><blockquote><p><code>iostat</code>输出的数据实际上是磁盘真实IO速度，而不受缓冲区策略的影响</p></blockquote><p><strong>每次测试前，清空buffer，丢弃cache</strong>：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/data/local/tmp # free -k &amp;&amp; sync &amp;&amp; echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches &amp;&amp;<span class="title"> free</span> -k<span class="title"></span></span><br><span class="line"><span class="title">                total</span> <span class="title">       used</span> <span class="title">       free</span> <span class="title">     shared</span> <span class="title">    buffers</span></span><br><span class="line">Mem:          3957988     1429360     2528628        7048        4464</span><br><span class="line">-/+<span class="title"> buffers/cache:</span>        1424896     2533092<span class="title"></span></span><br><span class="line"><span class="title">Swap:</span>         2176888      302080     1874808<span class="title"></span></span><br><span class="line"><span class="title">                total</span> <span class="title">       used</span> <span class="title">       free</span> <span class="title">     shared</span> <span class="title">    buffers</span></span><br><span class="line">Mem:          3957988     1413012     2544976        7048         476</span><br><span class="line">-/+<span class="title"> buffers/cache:</span>        1412536     2545452<span class="title"></span></span><br><span class="line"><span class="title">Swap:</span>         2176888      302080     1874808</span><br></pre></td></tr></table></figure><ul><li>带缓冲区：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">time</span> dd if=/dev/zero of=test bs=<span class="number">1</span>k count=<span class="number">4096000</span> &amp;&amp; time sync</span><br><span class="line"></span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">4194304000</span> bytes (<span class="number">3</span>.<span class="number">9</span> G) copied, <span class="number">40</span>.<span class="number">776918</span> s, <span class="number">98</span> M/s</span><br><span class="line"><span class="attribute">0m40</span>.<span class="number">79</span>s real     <span class="number">0</span>m<span class="number">01</span>.<span class="number">93</span>s user     <span class="number">0</span>m<span class="number">28</span>.<span class="number">54</span>s system</span><br><span class="line"><span class="attribute">0m05</span>.<span class="number">11</span>s real     <span class="number">0</span>m<span class="number">00</span>.<span class="number">00</span>s user     <span class="number">0</span>m<span class="number">00</span>.<span class="number">08</span>s system</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn</span><br><span class="line"><span class="attribute">mmcblk0</span>         <span class="number">183</span>.<span class="number">17</span>         <span class="number">0</span>.<span class="number">00</span>        <span class="number">90</span>.<span class="number">60</span>          <span class="number">0</span>         <span class="number">91</span></span><br></pre></td></tr></table></figure><ul><li>不带缓冲区</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">time</span> dd if=/dev/zero of=test bs=<span class="number">1</span>k count=<span class="number">4096000</span> conv=fsync &amp;&amp; time sync</span><br><span class="line"></span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">4096000</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">4194304000</span> bytes (<span class="number">3</span>.<span class="number">9</span> G) copied, <span class="number">45</span>.<span class="number">229102</span> s, <span class="number">88</span> M/s</span><br><span class="line"><span class="attribute">0m45</span>.<span class="number">24</span>s real     <span class="number">0</span>m<span class="number">01</span>.<span class="number">79</span>s user     <span class="number">0</span>m<span class="number">29</span>.<span class="number">42</span>s system</span><br><span class="line"><span class="attribute">0m00</span>.<span class="number">03</span>s real     <span class="number">0</span>m<span class="number">00</span>.<span class="number">00</span>s user     <span class="number">0</span>m<span class="number">00</span>.<span class="number">01</span>s system</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn</span><br><span class="line"><span class="attribute">mmcblk0</span>         <span class="number">187</span>.<span class="number">00</span>         <span class="number">0</span>.<span class="number">00</span>        <span class="number">92</span>.<span class="number">51</span>          <span class="number">0</span>         <span class="number">92</span></span><br></pre></td></tr></table></figure><p>可见，缓冲区确实有一定的IO性能影响，但是测试过程中dd数据量较大，能够覆盖buffer并触发磁盘flush，因此不论带不带缓冲，两种dd测试都触及了磁盘IO峰值性能。</p><blockquote><p>iostat统计磁盘的实际IO，不受buffer影响</p></blockquote><h3 id="2-2-伸缩IO资源发现对数据库测试成绩影响有限"><a href="#2-2-伸缩IO资源发现对数据库测试成绩影响有限" class="headerlink" title="2.2 伸缩IO资源发现对数据库测试成绩影响有限"></a>2.2 伸缩IO资源发现对数据库测试成绩影响有限</h3><p>设计一个实验来<strong>降低系统分配给数据库测试工具的IO资源。假设该实验中数据库测试成绩变化有限，可以一定程度地说明数据库CRUD性能测试的瓶颈与IO性能关联不大</strong>。</p><p>通过后台dd占用不同程度的IO资源的方式实现伸缩：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function command0() &#123;</span><br><span class="line">    <span class="attribute">output</span>=test/test$_depth_</span><br><span class="line">    dd <span class="attribute">if</span>=/dev/zero <span class="attribute">of</span>=<span class="variable">$output</span> <span class="attribute">bs</span>=1k <span class="attribute">count</span>=4096</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function command() &#123;</span><br><span class="line">    <span class="keyword">while</span> (( --_depth_ &gt;= 0 )); <span class="keyword">do</span></span><br><span class="line">        command0</span><br><span class="line">        sleep 0.2</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生一定的IO压力：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Device</span>:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn</span><br><span class="line"><span class="attribute">mmcblk0</span>         <span class="number">102</span>.<span class="number">97</span>         <span class="number">0</span>.<span class="number">00</span>        <span class="number">47</span>.<span class="number">56</span>          <span class="number">0</span>         <span class="number">48</span></span><br></pre></td></tr></table></figure><p>在这套脚本运行时，启动数据库测试，得出跑分成绩仅仅只比空负载时降低了16%左右。<strong>如果IO性能是数据库跑分瓶颈的话，那么此时跑分成绩应该显著下降</strong>。</p><ul><li>小结：通过<strong>IO加压的方式缩减了能够分配给数据库测试工具的IO资源，但是跑分变化远低于瓶颈预期值。表明IO性能目前不是性能瓶颈</strong>。</li></ul><h2 id="3-CPU资源制约数据库跑分"><a href="#3-CPU资源制约数据库跑分" class="headerlink" title="3. CPU资源制约数据库跑分"></a>3. CPU资源制约数据库跑分</h2><p>排除数据库设计、使用方案的影响，也排除掉IO性能的影响，还有一个瓶颈嫌疑是CPU性能。</p><p>设计一个实验来伸缩CPU资源。<strong>如果跑分对CPU资源的变化很敏感、显著地影响了数据库成绩</strong>，那么即可确定瓶颈。</p><p>通过削减数据库跑分软件的CPU资源来实现CPU资源的控制，主要采取<strong>数据库跑分线程绑定到专用核心，并在该核心上附加一定的压力</strong>来实现。</p><ol><li>首先在默认情况下的跑分，可见此时跑分线程会随机地在任意的CPU上运行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B_cpu%E6%A0%B8%E5%BF%83%E4%BF%A1%E6%81%AF.gif" alt="数据库测试过程CPU核心信息"></p><blockquote><p>注：top1就是数据库跑分线程，top2&#x2F;3分别是跑分应用的UI线程和渲染线程，它们用于在界面上显示跑分进度条。从数据上看，它们本身也占有一些CPU资源。</p></blockquote><ol start="2"><li>将跑分线程绑定到CPU0～3，将其他线程绑定到4～7</li></ol><p>可见，跑分线程只会在CPU0～3中调度。最终测试成绩与默认情况一致，没有差异。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E8%B7%91%E5%88%86%E7%BA%BF%E7%A8%8B0-3%E5%85%B6%E4%BB%964-7.gif" alt="数据库跑分线程0-3"></p><ol start="3"><li>将跑分线程和其他线程都绑定到CPU7</li></ol><p>让跑分线程绑定到CPU7，并因CPU7调度了其他线程而损失一些CPU资源。（本例主要是被跑分工具自己的UI线程和渲染线程分走）</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E5%85%A8%E9%83%A8%E7%BB%91%E5%AE%9A%E5%88%B0CPU7.gif" alt="全部绑定到CPU7"></p><p>可以看到，三个线程全部在CPU7上运行。跑分结果中，成绩较默认情况下降30%，证明该跑分在该设备上是CPU资源敏感型。</p><ol start="4"><li>将跑分线程和其他所有线程都绑定到CPU3</li></ol><p>与“3”相同，但是绑定CPU3。</p><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%85%A8%E9%83%A8%E7%BB%91%E5%AE%9A%E5%88%B0CPU3.gif"></p><p>成绩较默认下降50%左右。</p><ul><li>各场景梳理：</li></ul><table><thead><tr><th>场景(SQLite Delete)</th><th>成绩(QPS of SQLite Delete)</th><th>说明</th></tr></thead><tbody><tr><td>默认场景</td><td>849</td><td></td></tr><tr><td>后台dd命令制造峰值IO速率30%左右的IO压力</td><td>790</td><td>成绩略微下降</td></tr><tr><td>允许跑分线程在CPU0-3调度，其他为4-7调度</td><td>833</td><td>CPU资源几乎没有差异；成绩几乎没有差异</td></tr><tr><td>跑分线程和UI线程+渲染线程都绑定到CPU7</td><td>532</td><td>成绩下降～36%</td></tr><tr><td>都绑定到CPU3</td><td>392</td><td>成绩下降～52%</td></tr></tbody></table><p>小结：<strong>该机器在数据库跑分场景的性能瓶颈为CPU性能</strong>。</p><h3 id="绑定到不同核心得出的跑分成绩-大小核性能差异"><a href="#绑定到不同核心得出的跑分成绩-大小核性能差异" class="headerlink" title="绑定到不同核心得出的跑分成绩: 大小核性能差异"></a>绑定到不同核心得出的跑分成绩: 大小核性能差异</h3><p>可以看到绑定到不同CPU会产生比较显著的跑分成绩差异，实际上是CPU的大小核架构中大核和小核之间的性能差异。</p><p><code>cat /proc/cpuinfo</code>可知该机器有两种架构的CPU核。其中<code>CPU part</code>字段代表不同的架构：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ...</span><br><span class="line"></span><br><span class="line"><span class="attribute">processor       </span>: 3</span><br><span class="line"><span class="attribute">BogoMIPS        </span>: 26.00</span><br><span class="line"><span class="attribute">Features        </span>: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br><span class="line"><span class="attribute">CPU implementer </span>: 0x41</span><br><span class="line"><span class="attribute">CPU architecture</span>: 8</span><br><span class="line"><span class="attribute">CPU variant     </span>: 0x0</span><br><span class="line"><span class="attribute">CPU part        </span>: 0xd03</span><br><span class="line"><span class="attribute">CPU revision    </span>: 4</span><br><span class="line"></span><br><span class="line">... ... ... ...</span><br><span class="line"></span><br><span class="line"><span class="attribute">processor       </span>: 7</span><br><span class="line"><span class="attribute">BogoMIPS        </span>: 26.00</span><br><span class="line"><span class="attribute">Features        </span>: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br><span class="line"><span class="attribute">CPU implementer </span>: 0x41</span><br><span class="line"><span class="attribute">CPU architecture</span>: 8</span><br><span class="line"><span class="attribute">CPU variant     </span>: 0x0</span><br><span class="line"><span class="attribute">CPU part        </span>: 0xd09</span><br><span class="line"><span class="attribute">CPU revision    </span>: 2</span><br></pre></td></tr></table></figure><p>查阅Kernel <code>cputype.h</code>可知CPU3为0xd03即小核（Contex-A53），CPU7为0xd09即大核（Contex-A57）。大小核之间的性能差异使之在绑定核心后跑出了不同的分数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A35         0xD04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A55         0xD05</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A57         0xD07</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A72         0xD08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A53         0xD03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A73         0xD09</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARM_CPU_PART_CORTEX_A75         0xD0A</span></span><br></pre></td></tr></table></figure><h3 id="定频带来跑分提升-强制提高CPU频率"><a href="#定频带来跑分提升-强制提高CPU频率" class="headerlink" title="定频带来跑分提升: 强制提高CPU频率"></a>定频带来跑分提升: 强制提高CPU频率</h3><p>经过测试发现CPU资源下降将显著影响跑分成绩，表明性能瓶颈在CPU。由于在默认情况下CPU在数据库跑分场景可能没有以最高性能运行，因此通过将CPU频率固定到最高频率进行跑分测试。</p><p>固定到CPU最高频率运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find <span class="string">/proc/cpufreq/MT_CPU_DVFS_</span>*<span class="string">/cpufreq_oppidx</span> | xargs cat</span><br><span class="line"></span><br><span class="line">[MT_CPU_DVFS_L/4]</span><br><span class="line">cpufreq_oppidx = 0</span><br><span class="line"><span class="string">...</span> <span class="string">...</span> <span class="string">...</span> <span class="string">...</span></span><br><span class="line">[MT_CPU_DVFS_LL/0]</span><br><span class="line">cpufreq_oppidx = 0</span><br></pre></td></tr></table></figure><table><thead><tr><th>场景(SQLite Delete)</th><th>成绩(QPS of SQLite Delete)</th><th>说明</th></tr></thead><tbody><tr><td>将大核、小核均固定到最高频率</td><td>1417.1</td><td>提升~70%</td></tr><tr><td>将大核固定到最高频率</td><td>1233.2</td><td>提升~48%</td></tr><tr><td>将小核固定到最高频率</td><td>1103.3</td><td>提升~33%</td></tr><tr><td>将大核关闭、小核仅开两颗核心并固定到最低频率</td><td>253.4</td><td>下降~69%</td></tr></tbody></table><blockquote><p>Info：这里为了测试选取固定到最高频率，对于复杂的实际场景，不能笼统地认为最高频率&#x3D;最佳性能&#x2F;最好的用户体验。</p></blockquote><ul><li>小结：可以看到，在该数据库测试方法测试情况下，该平台的性能瓶颈为CPU。</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对于该设备，<code>AndroBench V5.0.1</code>的数据库性能测试方法中，跑分瓶颈是CPU性能，跑分成绩是CPU敏感的。</p><p>优化方案：提升CPU单核性能。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.androbench.org/">AndroBench</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;10:59 am&lt;br&gt;Tuesday, 1 November 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化工具：CPU性能分析、调试和定频（MTK）</title>
    <link href="https://nasdaqgodzilla.github.io/2022/11/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9ACPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E5%AE%9A%E9%A2%91%EF%BC%88MTK%EF%BC%89/"/>
    <id>https://nasdaqgodzilla.github.io/2022/11/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9ACPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E5%AE%9A%E9%A2%91%EF%BC%88MTK%EF%BC%89/</id>
    <published>2022-11-03T12:02:29.000Z</published>
    <updated>2022-11-03T12:04:33.614Z</updated>
    
    <content type="html"><![CDATA[<hr><p>9:51 am<br>Thursday, 3 November 2022 (HKT)<br>Time in Hong Kong</p><hr><ul><li><a href="#%E8%8E%B7%E5%8F%96">获取</a><ul><li><a href="#%E5%9C%A8%E7%BA%BFcpu">在线CPU</a></li><li><a href="#ppm%E4%BD%BF%E8%83%BD">PPM使能</a></li><li><a href="#cpu%E9%A2%91%E7%8E%87(proc)">CPU频率(proc)</a></li><li><a href="#cpu%E9%A2%91%E7%8E%87(sys)">CPU频率(sys)</a></li><li><a href="#cpu%E6%A1%A3%E4%BD%8Doppidx(%E9%A2%91%E7%82%B9)">CPU档位OPPidx(频点)</a></li><li><a href="#cpu%E5%92%8C%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%94%B5%E5%8E%8B">CPU和高速缓存电压</a></li><li><a href="#cpu%E7%AE%97%E5%8A%9B">CPU算力</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%B0%83%E9%A2%91%E7%AD%96%E7%95%A5">支持的调频策略</a></li><li><a href="#%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B0%83%E9%A2%91%E7%AD%96%E7%95%A5">正在使用的调频策略</a></li><li><a href="#%E8%B0%83%E9%A2%91%E9%A9%B1%E5%8A%A8">调频驱动</a></li><li><a href="#%E5%BD%93%E5%89%8D%E5%90%AF%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83">当前启用的核心</a></li><li><a href="#%E5%BD%93%E5%89%8D%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%A2%91%E7%8E%87">当前固定的频率</a></li></ul></li><li><a href="#%E8%AE%BE%E7%BD%AE">设置</a><ul><li><a href="#%E5%BC%80%E5%85%B3cpu%E6%A0%B8%E5%BF%83%E4%B8%AA%E6%95%B0">开关CPU核心个数</a></li><li><a href="#%E5%AE%9A%E9%A2%91">定频</a></li><li><a href="#%E7%BB%91%E6%A0%B8">绑核</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81">相关源码</a></li><li><a href="#%E6%9C%AF%E8%AF%AD">术语</a></li><li><a href="#%E8%B0%83%E9%A2%91%E7%AD%96%E7%95%A5">调频策略</a></li></ul><h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><h2 id="在线CPU"><a href="#在线CPU" class="headerlink" title="在线CPU"></a>在线CPU</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu/online</span><br><span class="line"><span class="number">0</span>-<span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="PPM使能"><a href="#PPM使能" class="headerlink" title="PPM使能"></a>PPM使能</h2><blockquote><p>性能管理模块</p></blockquote><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/ppm/enabled<span class="title"></span></span><br><span class="line"><span class="title">ppm</span> is<span class="title"> enabled</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">echo</span> 0 &gt; /<span class="keyword">proc</span>/ppm/enabled<span class="title"></span></span><br><span class="line"><span class="title">ppm</span> is<span class="title"> disabled</span></span><br></pre></td></tr></table></figure><h2 id="CPU频率-proc"><a href="#CPU频率-proc" class="headerlink" title="CPU频率(proc)"></a>CPU频率(proc)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_freq</span><br><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_LL/</span>cpufreq_freq</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_freq</span><br><span class="line"><span class="number">1326000</span> KHz</span><br><span class="line"></span><br><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_LL/</span>cpufreq_freq</span><br><span class="line"><span class="number">793000</span> KHz</span><br></pre></td></tr></table></figure><blockquote><p>proc节点优先级可能（通常，平台差异）低于thermal</p></blockquote><h2 id="CPU频率-sys"><a href="#CPU频率-sys" class="headerlink" title="CPU频率(sys)"></a>CPU频率(sys)</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu</span><br><span class="line">cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 cpu6 cpu7 cpufreq cpuidle cputopo eas hotplug isolated kernel_max modalias offline online possible <span class="keyword">power</span> present rq-stats sched sched_isolated uevent</span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu</span><br><span class="line"></span><br><span class="line">cat cpu[<span class="number">0</span>-<span class="number">7</span>]<span class="regexp">/cpufreq/</span>cpuinfo_cur_freq</span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1508000</span></span><br><span class="line"><span class="number">1846000</span></span><br><span class="line"><span class="number">1846000</span></span><br><span class="line"><span class="number">1846000</span></span><br><span class="line"><span class="number">1846000</span></span><br></pre></td></tr></table></figure><h2 id="CPU档位OPPidx（频点）"><a href="#CPU档位OPPidx（频点）" class="headerlink" title="CPU档位OPPidx（频点）"></a>CPU档位OPPidx（频点）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_oppidx</span><br><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_LL/</span>cpufreq_oppidx</span><br></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpufreq/MT_CPU_DVFS_L/cpufreq_oppidx</span><br><span class="line"></span><br><span class="line">[MT_CPU_DVFS_L/<span class="number">4</span>]</span><br><span class="line">cpufreq_oppidx = <span class="number">15</span></span><br><span class="line">        <span class="number">0</span>  <span class="comment">(1989000, 103125)</span></span><br><span class="line">        <span class="number">1</span>  <span class="comment">(1924000, 101875)</span></span><br><span class="line">        <span class="number">2</span>  <span class="comment">(1846000, 99375)</span></span><br><span class="line">        <span class="number">3</span>  <span class="comment">(1781000, 98125)</span></span><br><span class="line">        <span class="number">4</span>  <span class="comment">(1716000, 96250)</span></span><br><span class="line">        <span class="number">5</span>  <span class="comment">(1677000, 94375)</span></span><br><span class="line">        <span class="number">6</span>  <span class="comment">(1625000, 92500)</span></span><br><span class="line">        <span class="number">7</span>  <span class="comment">(1586000, 91250)</span></span><br><span class="line">        <span class="number">8</span>  <span class="comment">(1508000, 88750)</span></span><br><span class="line">        <span class="number">9</span>  <span class="comment">(1417000, 86250)</span></span><br><span class="line">        <span class="number">10</span> <span class="comment">(1326000, 83750)</span></span><br><span class="line">        <span class="number">11</span> <span class="comment">(1248000, 81250)</span></span><br><span class="line">        <span class="number">12</span> <span class="comment">(1131000, 78750)</span></span><br><span class="line">        <span class="number">13</span> <span class="comment">(1014000, 76250)</span></span><br><span class="line">        <span class="number">14</span> <span class="comment">(910000, 73750)</span></span><br><span class="line">        <span class="number">15</span> <span class="comment">(793000, 71250)</span></span><br><span class="line"></span><br><span class="line">cat MT_CPU_DVFS_LL/cpufreq_oppidx</span><br><span class="line"></span><br><span class="line">[MT_CPU_DVFS_LL/<span class="number">0</span>]</span><br><span class="line">cpufreq_oppidx = <span class="number">13</span></span><br><span class="line">        <span class="number">0</span>  <span class="comment">(1989000, 93750)</span></span><br><span class="line">        <span class="number">1</span>  <span class="comment">(1924000, 92500)</span></span><br><span class="line">        <span class="number">2</span>  <span class="comment">(1846000, 90000)</span></span><br><span class="line">        <span class="number">3</span>  <span class="comment">(1781000, 88750)</span></span><br><span class="line">        <span class="number">4</span>  <span class="comment">(1716000, 87500)</span></span><br><span class="line">        <span class="number">5</span>  <span class="comment">(1677000, 85625)</span></span><br><span class="line">        <span class="number">6</span>  <span class="comment">(1625000, 83750)</span></span><br><span class="line">        <span class="number">7</span>  <span class="comment">(1586000, 82500)</span></span><br><span class="line">        <span class="number">8</span>  <span class="comment">(1508000, 80000)</span></span><br><span class="line">        <span class="number">9</span>  <span class="comment">(1417000, 77500)</span></span><br><span class="line">        <span class="number">10</span> <span class="comment">(1326000, 75000)</span></span><br><span class="line">        <span class="number">11</span> <span class="comment">(1248000, 71875)</span></span><br><span class="line">        <span class="number">12</span> <span class="comment">(1131000, 69375)</span></span><br><span class="line">        <span class="number">13</span> <span class="comment">(1014000, 66250)</span></span><br><span class="line">        <span class="number">14</span> <span class="comment">(910000, 63125)</span></span><br><span class="line">        <span class="number">15</span> <span class="comment">(793000, 60000)</span></span><br></pre></td></tr></table></figure><ul><li>输出解析：</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CPU</span>名称_核心簇/<span class="keyword">CPUID</span>]</span><br><span class="line">cpufreq_oppidx = 目前使用的opp档位</span><br><span class="line">        档位 (频率, 供电电压uV)</span><br></pre></td></tr></table></figure><blockquote><p>簇分为LL、L、B。CPUID一般是每个簇中的第一个CPU的ID。</p><p>如4+4的CPU中，会有两个簇分别是MT_CPU_DVFS_LL（CPU0-3）和MT_CPU_DVDS_L（CPU4-7），其id分别使用每个簇的第一个CPU即0和4。</p></blockquote><blockquote><p>OPP即CPU能够“挂得上的档”，包含一个频率和对应的供电电压（uV）</p></blockquote><blockquote><p>由上可见该CPU的大小核的最高频率相同（不代表实际性能相同），但是供电差异较大</p></blockquote><h2 id="CPU和高速缓存电压"><a href="#CPU和高速缓存电压" class="headerlink" title="CPU和高速缓存电压"></a>CPU和高速缓存电压</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpufreq<span class="regexp">/MT_CPU_DVFS_L/</span>cpufreq_volt</span><br><span class="line">Vproc: <span class="number">812500</span> uV</span><br><span class="line">Vsram: <span class="number">912500</span> uV</span><br></pre></td></tr></table></figure><h2 id="CPU算力"><a href="#CPU算力" class="headerlink" title="CPU算力"></a>CPU算力</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu4/</span>cpu_capacity <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu<span class="regexp">/cpu0/</span>cpu_capacity</span><br><span class="line"></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/sys/</span>devices<span class="regexp">/system/</span>cpu</span><br><span class="line"></span><br><span class="line"><span class="keyword">find</span> cpu*/cpu_capacity | xargs cat</span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">604</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure><h2 id="支持的调频策略"><a href="#支持的调频策略" class="headerlink" title="支持的调频策略"></a>支持的调频策略</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat cpu[<span class="number">04</span>]<span class="regexp">/cpufreq/</span>scaling_available_governors</span><br><span class="line">ondemand userspace powersave performance schedutil</span><br><span class="line">ondemand userspace powersave performance schedutil</span><br></pre></td></tr></table></figure><h2 id="正在使用的调频策略"><a href="#正在使用的调频策略" class="headerlink" title="正在使用的调频策略"></a>正在使用的调频策略</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat cpu[<span class="number">04</span>]<span class="regexp">/cpufreq/</span>scaling_governor</span><br><span class="line">schedutil</span><br><span class="line">schedutil</span><br></pre></td></tr></table></figure><h2 id="调频驱动"><a href="#调频驱动" class="headerlink" title="调频驱动"></a>调频驱动</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat cpu[<span class="number">04</span>]<span class="regexp">/cpufreq/</span>scaling_driver</span><br><span class="line">mt-cpufreq</span><br><span class="line">mt-cpufreq</span><br></pre></td></tr></table></figure><h2 id="当前启用的核心"><a href="#当前启用的核心" class="headerlink" title="当前启用的核心"></a>当前启用的核心</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/ppm/policy/ut_fix_core_num<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> core<span class="title"> num</span> = -1<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> core<span class="title"> num</span> = 1</span><br></pre></td></tr></table></figure><ul><li>输出解析：</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">簇<span class="number"> 0 </span>指定使用核心个数 = -1</span><br><span class="line">簇<span class="number"> 1 </span>指定使用核心个数 = 1</span><br></pre></td></tr></table></figure><blockquote><p>-1表示不做任何指定，默认启用所有核心</p></blockquote><h2 id="当前固定的频率"><a href="#当前固定的频率" class="headerlink" title="当前固定的频率"></a>当前固定的频率</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/ppm/policy/ut_fix_freq_idx<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> freq<span class="title"> idx</span> = -1<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> freq<span class="title"> idx</span> = -1</span><br></pre></td></tr></table></figure><ul><li>输出解析：</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">簇<span class="number"> 0 </span>指定频点索引 = -1</span><br><span class="line">簇<span class="number"> 1 </span>指定频点索引 = 0</span><br></pre></td></tr></table></figure><blockquote><p>-1表示不做任何指定，系统会由调频管理程序自动根据当前工作负载选择合适的档位</p></blockquote><blockquote><p>数字不为-1时忽略调度程序，指定要求该簇（簇中的全部核心）工作到指定档位（但是可能被优先级更高的调度程序、设置、温度&#x2F;功耗策略影响）</p></blockquote><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>ppm/policy</span><br></pre></td></tr></table></figure><h2 id="开关CPU核心个数"><a href="#开关CPU核心个数" class="headerlink" title="开关CPU核心个数"></a>开关CPU核心个数</h2><p>开、关掉一些CPU核心。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">2</span> <span class="number">1</span> &gt; /<span class="keyword">proc</span>/ppm/policy/ut_fix_core_num<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">cat</span> /<span class="keyword">proc</span>/ppm/policy/ut_fix_core_num<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> core<span class="title"> num</span> = 2<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> core<span class="title"> num</span> = 1</span><br></pre></td></tr></table></figure><ul><li>效果，小核簇(簇0)之CPU2、3下线，大核簇(簇1)之CPU5、6、7下线：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> /sys/devices/system/cpu/online</span><br><span class="line"><span class="attribute">0</span>-<span class="number">1</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Mem</span>: <span class="number">1555028</span>K used, <span class="number">2402960</span>K free, <span class="number">0</span>K shrd, <span class="number">4040146952</span>K buff, <span class="number">1432</span>K cached</span><br><span class="line"><span class="attribute">CPU0</span>: <span class="number">76</span>.<span class="number">1</span>% usr <span class="number">23</span>.<span class="number">8</span>% sys  <span class="number">0</span>.<span class="number">0</span>% nic  <span class="number">0</span>.<span class="number">0</span>% idle  <span class="number">0</span>.<span class="number">0</span>% io  <span class="number">0</span>.<span class="number">0</span>% irq  <span class="number">0</span>.<span class="number">0</span>% sirq</span><br><span class="line"><span class="attribute">CPU1</span>: <span class="number">88</span>.<span class="number">5</span>% usr <span class="number">11</span>.<span class="number">4</span>% sys  <span class="number">0</span>.<span class="number">0</span>% nic  <span class="number">0</span>.<span class="number">0</span>% idle  <span class="number">0</span>.<span class="number">0</span>% io  <span class="number">0</span>.<span class="number">0</span>% irq  <span class="number">0</span>.<span class="number">0</span>% sirq</span><br><span class="line"><span class="attribute">CPU2</span>: <span class="number">98</span>.<span class="number">8</span>% usr  <span class="number">1</span>.<span class="number">1</span>% sys  <span class="number">0</span>.<span class="number">0</span>% nic  <span class="number">0</span>.<span class="number">0</span>% idle  <span class="number">0</span>.<span class="number">0</span>% io  <span class="number">0</span>.<span class="number">0</span>% irq  <span class="number">0</span>.<span class="number">0</span>% sirq</span><br><span class="line"><span class="attribute">Load</span> average: <span class="number">28</span>.<span class="number">04</span> <span class="number">26</span>.<span class="number">40</span> <span class="number">24</span>.<span class="number">93</span> <span class="number">7</span>/<span class="number">1432</span> <span class="number">12912</span></span><br></pre></td></tr></table></figure><blockquote><p>echo送入的数字个数取决于处理器具有多少个簇（Cluster），一般大+小核处理器为2，超大+大+小核处理器为3。</p></blockquote><ul><li>设置为-1恢复默认</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -<span class="number">1</span> -<span class="number">1</span> &gt; <span class="regexp">/proc/</span>ppm<span class="regexp">/policy/u</span>t_fix_core_num</span><br></pre></td></tr></table></figure><ul><li>命令解析：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 簇<span class="number">0</span>允许使用的核心数 簇<span class="number">1</span>允许使用的核心数 &gt; <span class="regexp">/proc/</span>ppm<span class="regexp">/policy/u</span>t_fix_core_num</span><br></pre></td></tr></table></figure><h2 id="定频"><a href="#定频" class="headerlink" title="定频"></a>定频</h2><p>定频，固定CPU频率（频点），固定到具体档位。频率的档位，即频点，为OPP index，故固定频率实际上是强制将CPU挂至对应的各个index。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> <span class="number">-1</span> &gt; /<span class="keyword">proc</span>/ppm/policy/ut_fix_freq_idx<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">cat</span> /<span class="keyword">proc</span>/ppm/policy/ut_fix_freq_idx<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 0<span class="title"> fix</span> freq<span class="title"> idx</span> = 0<span class="title"></span></span><br><span class="line"><span class="title">cluster</span> 1<span class="title"> fix</span> freq<span class="title"> idx</span> = -1</span><br></pre></td></tr></table></figure><ul><li>命令解析：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 簇<span class="number">0</span>档位 簇<span class="number">1</span>档位 &gt; <span class="regexp">/proc/</span>ppm<span class="regexp">/policy/u</span>t_fix_freq_idx</span><br></pre></td></tr></table></figure><ul><li>效果，命令要求将簇0（小核簇）内的所有CPU运行在最高频率：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/devices/system/cpu/cpu[<span class="number">0</span>-<span class="number">7</span>]/cpufreq/cpuinfo_cur_freq | xargs cat</span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1989000</span></span><br><span class="line"><span class="number">1248000</span></span><br><span class="line"><span class="number">1248000</span></span><br><span class="line"><span class="number">1248000</span></span><br><span class="line"><span class="number">1248000</span></span><br></pre></td></tr></table></figure><blockquote><p>可见，簇0的所以CPU（CPU0-4）全部工作在最高频率</p></blockquote><h2 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h2><p>将指定的进程绑定到一个或一些CPU上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskset -ap <span class="attribute">MASK</span> PID</span><br><span class="line"></span><br><span class="line">taskset -<span class="selector-tag">p</span> <span class="attribute">MASK</span> PID</span><br></pre></td></tr></table></figure><h1 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel-<span class="number">4.14</span><span class="regexp">/drivers/mi</span>sc<span class="regexp">/mediatek/</span>base<span class="regexp">/power/</span>ppm_v3/src</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum mt_cpu_dvfs_id &#123;</span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_LL,</span></span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_L,</span></span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_B,</span></span><br><span class="line"><span class="built_in">        MT_CPU_DVFS_CCI,</span></span><br><span class="line"><span class="built_in">        NR_MT_CPU_DVFS,</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">enum mt_dvfs_debug_id &#123;</span><br><span class="line"><span class="built_in">        DEBUG_FREQ_CLUSTER0,</span></span><br><span class="line"><span class="built_in">        DEBUG_FREQ_CLUSTER1,</span></span><br><span class="line"><span class="built_in">        DEBUG_FREQ_CLUSTER2,</span></span><br><span class="line"><span class="built_in">        DEBUG_FREQ_ALL,</span></span><br><span class="line">        DEBUG_FREQ_DISABLED = <span class="number">100</span>,</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>cpufreq_freq proc节点</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cpufreq_freq_proc_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">cpufreq_freq_proc_write</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>cpufreq_oppidx proc节点</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mtk_cpufreq_interface<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cpufreq_oppidx_proc_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">cpufreq_oppidx_proc_write</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>定频、核数开关</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mtk_ppm_policy_ut</span><span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line"># 核数</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_core_num_proc_show</span>()</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_core_num_proc_write</span>()</span><br><span class="line"></span><br><span class="line"># 定频：读取设置、更新设置</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_freq_idx_proc_show</span>()</span><br><span class="line"><span class="selector-tag">ppm_ut_fix_freq_idx_proc_write</span>()</span><br></pre></td></tr></table></figure><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>DVFS</td><td>Dynamic Voltage and Frequency Scaling 通过调整CPU频率、电压来匹配工作负载，取得节能目的的技术</td></tr><tr><td>freq</td><td>Frequency 频率</td></tr><tr><td>OPP</td><td>Operating Performance Points 频点、频率档位</td></tr><tr><td>PPM</td><td>Power Policy Manager</td></tr><tr><td>oppidx</td><td>OPP的Index 各档位的频率对应为一个index， 0对应最高频率</td></tr><tr><td>LL</td><td>小核</td></tr><tr><td>L</td><td>大核</td></tr><tr><td>B</td><td>超大核</td></tr><tr><td>Jade</td><td>BIG.LITTLE架构的CPU（大小端模式）</td></tr><tr><td>Everest</td><td>小核-大核-超大核架构的CPU</td></tr><tr><td>Olympus</td><td>小核-大核架构的CPU</td></tr><tr><td>Cluster</td><td>CPU簇；CPU的几个核心在同一簇中管理，一个CPU可能有多个簇，一般将效能核、性能核、超大核分别分入一个簇中</td></tr></tbody></table><h1 id="调频策略"><a href="#调频策略" class="headerlink" title="调频策略"></a>调频策略</h1><table><thead><tr><th>策略名称</th><th>说明</th></tr></thead><tbody><tr><td>performance</td><td>运行于最大频率</td></tr><tr><td>powersave</td><td>运行于最小频率</td></tr><tr><td>userspace</td><td>运行于用户指定的频率</td></tr><tr><td>ondemand</td><td>按需快速动态调整CPU频率， 一有cpu计算量的任务，就会立即达到最大频率运行; 空闲时间占比增加则降低频率</td></tr><tr><td>conservative</td><td>按需快速动态调整CPU频率，比 ondemand 的调整更保守，不会迅速达到最大频率</td></tr><tr><td>schedutil</td><td>由调度程序管理</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;9:51 am&lt;br&gt;Thursday, 3 November 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96&quot;&gt;获取&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>紫光展锐展讯SPRD刷机包pac文件解包提取img步骤</title>
    <link href="https://nasdaqgodzilla.github.io/2022/10/10/%E7%B4%AB%E5%85%89%E5%B1%95%E9%94%90%E5%B1%95%E8%AE%AFSPRD%E5%88%B7%E6%9C%BA%E5%8C%85pac%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8F%96img%E6%AD%A5%E9%AA%A4/"/>
    <id>https://nasdaqgodzilla.github.io/2022/10/10/%E7%B4%AB%E5%85%89%E5%B1%95%E9%94%90%E5%B1%95%E8%AE%AFSPRD%E5%88%B7%E6%9C%BA%E5%8C%85pac%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8F%96img%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-10-10T02:24:35.000Z</published>
    <updated>2022-10-10T02:28:10.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UNISOC-SPRD-PAC-UNPAC"><a href="#UNISOC-SPRD-PAC-UNPAC" class="headerlink" title="UNISOC_SPRD_PAC_UNPAC"></a>UNISOC_SPRD_PAC_UNPAC</h1><p>紫光展锐展讯SPRD刷机包pac文件解包提取img文件。</p><p>Extract Images from .pac file from Spreadtrum Unisoc SPRD.</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><ol><li>pac文件 *1</li><li><code>Perl</code>环境</li></ol><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>展锐官方自带一套分别用Python和Perl实现的将各img打包为pac文件的工具，也实现了对应的解包工具。其中，<code>pac_tools/unpac_perl/unpac.pl</code>是<code>Perl</code>实现的解包工具，能将pac文件中的各img提取出来。</p><p>下载：<a href="https://github.com/NasdaqGodzilla/UNISOC_SPRD_PAC_UNPAC">地址</a>（Clone源码或下载Release包）</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>请根据系统权限机制确保unpac.pl具有执行权限</li><li>第一个参数为需要提取的pac文件</li><li>第二个参数为提取产物的存储路径</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/pac_tools/u</span>npac_perl<span class="regexp">/unpac.pl ROM/y</span>our_pac_file.pac pac_unpac_path/</span><br></pre></td></tr></table></figure><h2 id="添加-S参数加快提取"><a href="#添加-S参数加快提取" class="headerlink" title="添加-S参数加快提取"></a>添加-S参数加快提取</h2><p><code>unpac.pl</code>在提取之前会校验pac文件的完整性。它非常耗时，可以在命令的最后追加<code>-S</code>跳过CRC校验。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/pac_tools/u</span>npac_perl<span class="regexp">/unpac.pl ROM/y</span>our_pac_file.pac pac_unpac_path/ -S</span><br></pre></td></tr></table></figure><ul><li>注意，-S参数必须放在最后面，不能放置️前两个参数之前</li></ul><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>在命令的最后添加参数<code>-D</code>要求<code>unpac.pl</code>打印调试信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UNISOC-SPRD-PAC-UNPAC&quot;&gt;&lt;a href=&quot;#UNISOC-SPRD-PAC-UNPAC&quot; class=&quot;headerlink&quot; title=&quot;UNISOC_SPRD_PAC_UNPAC&quot;&gt;&lt;/a&gt;UNISOC_SPRD_PAC_UNPAC&lt;/</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>记一次带宽压榨：多线多拨（多WAN口）实现网络性能改善</title>
    <link href="https://nasdaqgodzilla.github.io/2022/09/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B8%A6%E5%AE%BD%E5%8E%8B%E6%A6%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E5%A4%9A%E6%8B%A8%EF%BC%88%E5%A4%9AWAN%E5%8F%A3%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%94%B9%E5%96%84/"/>
    <id>https://nasdaqgodzilla.github.io/2022/09/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B8%A6%E5%AE%BD%E5%8E%8B%E6%A6%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E5%A4%9A%E6%8B%A8%EF%BC%88%E5%A4%9AWAN%E5%8F%A3%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%94%B9%E5%96%84/</id>
    <published>2022-09-30T10:51:06.000Z</published>
    <updated>2022-09-30T10:52:37.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当谈及上网体验时，总是会涉及网络性能优化的探索。</p><p>其中，对于提升网速这一块，最直接最有效的莫过于增加带宽、增加物理链路来实现更大更快的网络网络流量。通常在家庭场景、商业场景会向ISP订购更多的宽带服务，通过<code>单线多拨</code>、<code>多线多拨</code>机制实现「网速叠加」。</p><p>而对于办公场景等具有多层交换机、NAT内网的环境而言，网速优化的首要目标不是增加更多的链路，而是<strong>「避开内网网速限制」和「压榨内网带宽」</strong>，让内网终端能够最大化利用内网出口带宽。</p><p>本文讨论「多WAN口」实现内网带宽压榨，并亲测wan口数量带来的网速提升效果。</p><h1 id="多线多拨与单线多拨"><a href="#多线多拨与单线多拨" class="headerlink" title="多线多拨与单线多拨"></a>多线多拨与单线多拨</h1><p>在最舒服的理想状况下，路由器每一次拨号，便能从ISP获取一个 IP，运营商会分配对应的带宽，每个IP独立计算一个带宽大小。</p><p>将路由器的端口模拟成多个拨号端口（或者是，本来路由器就支持多端口拨号），多个端口分别拨号，成功连接的前提下，如果将网络通信分配到这些端口进行传输，那么实际上就实现了「网速叠加」。</p><blockquote><p>注意是在最舒服的状况下能实现：运营商支持&#x2F;套餐支持、猫支持、路由器支持、操作系统支持…</p></blockquote><p>单线多拨：实际上就是实现了多拨，但是“每个拨”的出口都是同一个链路（同一个宽带）</p><p>多线多拨：多拨，并且出口并不都是同一个链路（比如办理移动千兆+电信百兆两个套餐，配置双拨分别使用这两条宽带）</p><blockquote><p>多拨除了「网速叠加」以外，一大用途是作为链路备份。当某条链路故障时，多拨的其他链路可以维持正常服务，保证可用性。</p></blockquote><h1 id="多WAN口压榨带宽"><a href="#多WAN口压榨带宽" class="headerlink" title="多WAN口压榨带宽"></a>多WAN口压榨带宽</h1><p>对于办公场景，一个典型的网络架构就是「多层交换机+多层NAT」。通常，会带有流量控制、带宽配额。因此，对于存在网络瓶颈或网络加速需求的时候，「多拨将不是首要关注点（显然，首先过掉内网的网速限制，让自己分配到更多带宽才是重点）」。</p><p>事实上，一种常见的网速控制&#x2F;带宽分配方案就是按交换机客户端接入点来定额分配。在不「入侵计算机系统」的前提下，每个接入点的配额不能被随意修改。</p><p>按照多拨的思路，容易想到，如果上网终端能够<strong>同时连接交换机的多个端口，再像多拨一样将流量分配到这些端口上</strong>，即可实现和多拨原理一样的「网速叠加」。</p><blockquote><p>事实上是最大带宽叠加，每条链路本身的速度还是固定不变的。它不能让一个小的数据包传输的更快。</p></blockquote><p>实现这一方案（同时连接到交换机的多个端口上）对软件（路由器软件或操作系统）来说是已经就绪可行的（都已实现）。对于硬件也有要求，即使用的路由器（用来通过网线连接到交换机的）必须支持「多WAN口」（便宜的家庭路由器通常只有一个WAN口）；或不使用路由器，上网终端直接通过多个自带的&#x2F;扩展的网口连接交换机。</p><blockquote><p>还有一些隐性的硬件要求，比如你必须有多根网线，并且要靠近交换机或老板在你的工位安装了多个网口（不然你怎么实现接入到交换机的多个口？）此外，上网终端配备的网卡必须是千兆网卡，否则实现多WAN口后网卡性能跟不上，还是会降级减速。</p></blockquote><p>小结：</p><ol><li>对于内网有带宽限制的场景，突破带宽限制成为第一关注点</li><li>类似多拨，上网终端通过多WAN口接入交换机，多个WAN口的带宽可以实现叠加，提高极限带宽，「变相绕路」避开了内网带宽配额</li><li>多WAN口有硬件条件——起码是实施条件</li></ol><blockquote><p>移动端有一种技术——iPhone的Wifi信号不佳时自动转数据、手游网络优化（Wifi卡顿时允许使用数据），这些实现了链路备份，并从技术上来说，可以（或已经）实现了「多拨」</p></blockquote><h1 id="环境、配置"><a href="#环境、配置" class="headerlink" title="环境、配置"></a>环境、配置</h1><p>在某个环境中尝试一下多WAN口的效果。</p><ul><li>工具：提供上网服务的交换机（有多个空余接入口）；该交换机单个接入口带宽在50~100M左右（测速数据，见下一节单WAN口，非ISP提供）</li><li>工具：路由器TL-WAR1208L（9口路由器，可以配置最大支持将其中4个口配置成WAN口）。在测试过程中，分别配置1～4个WAN口并连接到交换机进行测速</li><li>上网终端：Apple M1 Pro 2021 14寸，Chrome 105，通过speedtest.cn测速。该终端通过雷雳接口连接一个绿联hub，引出网线连接路由器LAN口实现上网</li></ul><p>网络拓扑简单描述：终端-&gt;网线-&gt;路由器-&gt;（1～4根网线）连接交换机（1～4个接入口）</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>注意到上述我使用的路由器是最大支持4个WAN口。因此这里通过多个WAN口压榨带宽的极限就是4，下列分别是1～4个WAN口时的表现。</p><p>（不展示怎么配置多WAN口了，通常系统配置或路由器配置即可。）</p><ul><li>没有使用多WAN口（单WAN口）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%8D%95WAN%E5%8F%A3.png" alt="单WAN口"></p><ul><li>两个WAN口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%8F%8Cwan%E5%8F%A3.png" alt="双WAN口"></p><ul><li>三个WAN口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E4%B8%89wan%E5%8F%A3.png" alt="三WAN口"></p><ul><li>四个WAN口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NasdaqGodzilla/PeacePicture/img/%E5%9B%9Bwan%E5%8F%A3.png" alt="四WAN口"></p><p>可以看到，多WAN口带来的测速成绩（极限带宽）提升很明显。<strong>在1、2、3个WAN口的情况下，随着WAN口数量提升，测速成绩也不断攀升</strong>。</p><p>但是，当WAN口数量到第4个的时候，测速成绩反而下降了。<strong>这提示一个违反常理的结果：明显带宽提高了，测速成绩却更低了？</strong>虽然没有找到根本原因，但从对路由器性能参数的观察发现，<strong>四WAN口同时启用，可能对路由器CPU带来了较大压力，不堪重负的CPU在更多WAN口的调度压力下表现更差了</strong>。因此，多WAN口配置还需要考虑硬件&#x2F;软件性能，一味提高链路带宽不一定保证提高实际的最大带宽。</p><blockquote><p>其实来到「三WAN口」已经能“睥睨”出一点路由器性能瓶颈了。带宽叠加的结果一般都是测速翻倍（注意是测速，没说你打开网页也翻倍）。但是可以看到，双WAN比单WAN的下载速度刚好翻倍，而三WAN则没有对双WAN有翻倍的效果了——实际上这里就是因为路由器性能没跟上，发挥不出来三WAN的完整带宽了（到了四WAN由于调度工作拖累，反而更差了）。</p></blockquote><p>总结：</p><ol><li>多拨、多WAN口有机会优化网络访问速度，还有链路备份功能、高可用功能</li><li>多拨、多WAN口需要硬件支持</li><li>链路带宽一定程度上受制于路由器性能，可能出现带宽提高反而测速降低的现象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;当谈及上网体验时，总是会涉及网络性能优化的探索。&lt;/p&gt;
&lt;p&gt;其中，对于提升网速这一块，最直接最有效的莫过于增加带宽、增加物理链路来实现更</summary>
      
    
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android SystemWebview Chromoum源码拉取与编译</title>
    <link href="https://nasdaqgodzilla.github.io/2022/08/17/Android-SystemWebview-Chromoum%E6%BA%90%E7%A0%81%E6%8B%89%E5%8F%96%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    <id>https://nasdaqgodzilla.github.io/2022/08/17/Android-SystemWebview-Chromoum%E6%BA%90%E7%A0%81%E6%8B%89%E5%8F%96%E4%B8%8E%E7%BC%96%E8%AF%91/</id>
    <published>2022-08-17T03:44:37.000Z</published>
    <updated>2022-08-29T11:29:39.195Z</updated>
    
    <content type="html"><![CDATA[<hr><p>2:52 pm<br>Monday, 15 August 2022 (HKT)<br>Time in Hong Kong</p><hr><h1 id="拉取步骤"><a href="#拉取步骤" class="headerlink" title="拉取步骤"></a>拉取步骤</h1><h2 id="拉取depot-tools"><a href="#拉取depot-tools" class="headerlink" title="拉取depot_tools"></a>拉取depot_tools</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//</span>chromium.googlesource.com<span class="regexp">/chromium/</span>tools/depot_tools.git</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">&quot;<span class="variable">$PATH</span>:/path/to/depot_tools&quot;</span></span><br></pre></td></tr></table></figure><h2 id="拉取Android-Chromium源码"><a href="#拉取Android-Chromium源码" class="headerlink" title="拉取Android Chromium源码"></a>拉取Android Chromium源码</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="string">/chromium</span> &amp;&amp; <span class="keyword">cd</span> <span class="string">/chromium</span></span><br></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">fetch</span> --<span class="comment">nohooks</span> --<span class="comment">no</span><span class="literal">-</span><span class="comment">history</span> <span class="comment">android</span></span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="keyword">sync</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来继续之前，额外一个可选步骤：切换到指定版本（查阅“切换到指定版本”节）</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">.<span class="regexp">/build/i</span>nstall-build-deps-android.sh</span><br><span class="line">gclient runhooks</span><br></pre></td></tr></table></figure><p>代码拉取完成。</p><h2 id="可选-查看当前版本"><a href="#可选-查看当前版本" class="headerlink" title="(可选)查看当前版本"></a>(可选)查看当前版本</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> src</span><br><span class="line"><span class="keyword">cat</span> chrome/<span class="keyword">VERSION</span></span><br></pre></td></tr></table></figure><h2 id="可选-切换到指定版本"><a href="#可选-切换到指定版本" class="headerlink" title="(可选)切换到指定版本"></a>(可选)切换到指定版本</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> src</span><br><span class="line"><span class="attribute">git</span> fetch origin <span class="number">74</span>.<span class="number">0</span>.<span class="number">3729</span>.<span class="number">186</span></span><br><span class="line"><span class="attribute">git</span> checkout -b <span class="number">74</span>.<span class="number">0</span>.<span class="number">3729</span>.<span class="number">186</span> FETCH_HEAD</span><br><span class="line"><span class="attribute">gclient</span> sync --with_branch_heads -D</span><br></pre></td></tr></table></figure><h2 id="（用于平时更新代码）同步一下代码"><a href="#（用于平时更新代码）同步一下代码" class="headerlink" title="（用于平时更新代码）同步一下代码"></a>（用于平时更新代码）同步一下代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="keyword">sync</span></span><br></pre></td></tr></table></figure><h1 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h1><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gn</span> gen out/Release --<span class="built_in">args</span>=&#x27;target_os=<span class="string">&quot;android&quot;</span> is_debug=<span class="literal">false</span> is_official_build=<span class="literal">true</span> enable_nacl=<span class="literal">false</span> is_chrome_branded=<span class="literal">false</span> use_official_google_api_keys=<span class="literal">false</span> enable_resource_whitelist_generation=<span class="literal">true</span> ffmpeg_branding=<span class="string">&quot;Chrome&quot;</span> proprietary_codecs=<span class="literal">true</span> enable_remoting=<span class="literal">true</span>&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out<span class="regexp">/Release/</span> system_webview_apk -j32</span><br></pre></td></tr></table></figure><blockquote><p>或者使用autoninja进行编译：</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>ninja -C <span class="keyword">out</span>/Release/ system_webview_apk </span><br></pre></td></tr></table></figure><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="Error-Could-not-create-the-Java-Virtual-Machine"><a href="#Error-Could-not-create-the-Java-Virtual-Machine" class="headerlink" title="Error: Could not create the Java Virtual Machine."></a>Error: Could not create the Java Virtual Machine.</h2><p>编译需要JDK，而且是特定版本的JDK（截至目前要求JDK 8）</p><p>JDK版本是可以动态切换的，查看（并修改）JDK版本：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config java  </span></span><br><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config javac</span></span><br></pre></td></tr></table></figure><blockquote><p>根据提示输入数字，选择jdk 8即可</p></blockquote><p>命令输出长得像下面这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="number">2</span> choices <span class="keyword">for</span> the alternative java (providing <span class="regexp">/usr/</span>bin/java).</span><br><span class="line"></span><br><span class="line">  Selection    Path                                            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* <span class="number">0</span>            <span class="regexp">/usr/</span>lib<span class="regexp">/jvm/</span>java-<span class="number">11</span>-openjdk-amd64<span class="regexp">/bin/</span>java      <span class="number">1111</span>      auto mode</span><br><span class="line">  <span class="number">1</span>            <span class="regexp">/usr/</span>lib<span class="regexp">/jvm/</span>java-<span class="number">11</span>-openjdk-amd64<span class="regexp">/bin/</span>java      <span class="number">1111</span>      manual mode</span><br><span class="line">  <span class="number">2</span>            <span class="regexp">/usr/</span>lib<span class="regexp">/jvm/</span>java-<span class="number">8</span>-openjdk-amd64<span class="regexp">/jre/</span>bin/java   <span class="number">1081</span>      manual mode</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md">https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;2:52 pm&lt;br&gt;Monday, 15 August 2022 (HKT)&lt;br&gt;Time in Hong Kong&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;拉取步骤&quot;&gt;&lt;a href=&quot;#拉取步骤&quot; class=&quot;headerlink&quot; title=&quot;拉取步骤&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Clash配置暴露代理服务</title>
    <link href="https://nasdaqgodzilla.github.io/2022/08/15/Clash%E9%85%8D%E7%BD%AE%E6%9A%B4%E9%9C%B2%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
    <id>https://nasdaqgodzilla.github.io/2022/08/15/Clash%E9%85%8D%E7%BD%AE%E6%9A%B4%E9%9C%B2%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-08-15T05:16:03.000Z</published>
    <updated>2022-08-29T11:29:39.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>通常在PC中启动了clash提供上网功能，需要将上网能力共享到WSL终端、Linux终端等不直接配置clash的场景中使用。</p><p>方案：使用clash内建的LAN mode、Linux&#x2F;WSL等提供的代理功能。</p><h1 id="1-clash启动代理服务"><a href="#1-clash启动代理服务" class="headerlink" title="1. clash启动代理服务"></a>1. clash启动代理服务</h1><p>clash启动lan服务，并且记录下IP和端口。</p><p><img src="https://s2.loli.net/2022/08/15/47GSyevF5TZVh2A.png"></p><h1 id="2-终端配置代理"><a href="#2-终端配置代理" class="headerlink" title="2. 终端配置代理"></a>2. 终端配置代理</h1><p>配置代理仅需一行命令（注意生效范围是本终端）：</p><p><img src="https://s2.loli.net/2022/08/15/l2GXUTkQEYVFoxJ.png"></p><h1 id="3-测试代理"><a href="#3-测试代理" class="headerlink" title="3. 测试代理"></a>3. 测试代理</h1><p>下面命令可以检测代理是否生效。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="regexp">//myi</span>p.ipip.net/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;通常在PC中启动了clash提供上网功能，需要将上网能力共享到WSL终端、Linux终端等不直接配置clash的场景中使用。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android系统编译优化: 使用Ninja加快编译</title>
    <link href="https://nasdaqgodzilla.github.io/2022/08/08/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E4%BD%BF%E7%94%A8Ninja%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91/"/>
    <id>https://nasdaqgodzilla.github.io/2022/08/08/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E4%BD%BF%E7%94%A8Ninja%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91/</id>
    <published>2022-08-08T09:16:51.000Z</published>
    <updated>2022-08-29T11:29:39.199Z</updated>
    
    <content type="html"><![CDATA[<hr><p>10:34 am<br>Monday, 8 August 2022 (GMT+8)<br>Time in Guangzhou, Guangdong Province, China</p><hr><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E5%92%8C%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90">关键编译阶段和耗时分析</a><ul><li><a href="#%E9%98%B6%E6%AE%B5%E4%B8%80-soong-bootstrap">阶段一：Soong bootstrap</a></li><li><a href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9Akati%E9%81%8D%E5%8E%86%E3%80%81mk%E6%90%9C%E9%9B%86%E4%B8%8Eninja%E7%94%9F%E6%88%90">阶段二：Kati遍历、mk搜集与ninja生成</a></li><li><a href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9Aninja%E7%BC%96%E8%AF%91">阶段三：Ninja编译</a></li></ul></li><li><a href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96">编译优化</a></li><li><a href="#%E5%AF%B9%E6%AF%94%E6%B1%87%E6%80%BB">对比汇总</a></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android系统模块代码的编译实在是太耗时了，即使寥寥几行代码的修改，也能让一台具有足够性能的编译服务器工作十几分钟以上（模块单编），只为编出一些几兆大小的jar和dex。</p><blockquote><p>这里探究的是系统完成过一次整编后进行的模块单编，即m、mm、mmm等命令。</p></blockquote><p>除此之外，一些不会更新源码、编译配置等文件的内容的操作，如touch、git操作等，会被Android系统编译工具识别为有差异，从而在编译时重新生成编译配置，重新编译并没有更新的源码、重新生成没有差异的中间文件等一系列严重耗时操作。</p><p>本文介绍关于<strong>编译过程中的几个阶段</strong>，以及这些阶段的<strong>耗时点&#x2F;耗时原因</strong>，并最后给出一个<strong>覆盖一定应用场景的基于ninja的加快编译的方法（实际上是裁剪掉冗余的编译工作）</strong>。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>编译服务器硬件及Android信息：</p><ul><li>Ubuntu 18.04.4 LTS</li><li>Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz (28核56超线程)</li><li>MemTotal: 65856428 kB (62.8GiB)</li><li>AOSP Android 10.0</li><li>仅修改某个Java文件内部的boolean初始化值（true改false）</li><li>不修改其他任何内容，包括源码、mk、bp的情况下，使用m单编模块（在清理后，使用对比的ninja进行单编）</li><li>使用time计时</li><li>此前整个系统已经整编过一次</li><li><strong>编译时不修改任何编译配置文件如Android.mk</strong></li></ul><p><strong>之所以做一个代码修改量微乎其微的case，是因为要分析编译性能瓶颈，代码变更量越小的情况下，瓶颈就越明显，越有利于分析</strong>。</p><h1 id="关键编译阶段和耗时分析"><a href="#关键编译阶段和耗时分析" class="headerlink" title="关键编译阶段和耗时分析"></a>关键编译阶段和耗时分析</h1><p>由于<code>Makefile</code>结构复杂、不易调试、难以扩展，因此Android决定将它替换掉。Android在7.0时引入了<code>Soong</code>，它将Android从<code>Makefile</code>的编译架构带入到了<code>ninja</code>的时代。</p><p><code>Soong</code>包含两大模块，其中<code>Kati</code>负责解析<code>Makefile</code>并转换为<code>.ninja</code>，第二个模块<code>Ninja</code>则基于生成的<code>.ninja</code>完成编译。</p><blockquote><p><code>Kati</code>是对<code>GNU Make</code>的clone，并将编译后端实现切换到ninja。<code>Kati</code>本身不进行编译，仅生成<code>.ninja</code>文件提供给<code>Ninja</code>进行编译。</p></blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M<span class="function"><span class="title">akefile</span>/Android.mk -&gt;</span> K<span class="function"><span class="title">ati</span> -&gt;</span> Ninja</span><br><span class="line">A<span class="function"><span class="title">ndroid</span>.bp -&gt;</span> B<span class="function"><span class="title">lueprint</span> -&gt;</span> S<span class="function"><span class="title">oong</span> -&gt;</span> Ninja</span><br></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">M<span class="function"><span class="title">akefile</span>/Android.mk --&gt;</span> Kati</span><br><span class="line">K<span class="function"><span class="title">ati</span> --&gt;</span> Ninja</span><br><span class="line">A<span class="function"><span class="title">ndroid</span>.bp --&gt;</span> Blueprint</span><br><span class="line">B<span class="function"><span class="title">lueprint</span> --&gt;</span> Soong</span><br><span class="line">S<span class="function"><span class="title">oong</span> --&gt;</span> Ninja</span><br></pre></td></tr></table></figure><p>因此在执行编译之前（即<code>Ninja</code>真正开动时），还有一些生成<code>.ninja</code>的步骤。关键编译阶段如下：</p><ol><li>Soong的自举（Bootstrap），将Soong本身编译出来<ol><li>系统代码首次编译会比较耗时，其中一个原因是Soong要全新编译它自己</li></ol></li><li>遍历源码树，收集所有编译配置文件（Makefile&#x2F;Android.mk&#x2F;Android.bp)<ol><li><strong>遍历、验证非常耗时，多么强劲配置的机器都将受限于单线程效率和磁盘IO效率</strong></li><li><strong>由于Android系统各模块之间的依赖、引入，因此即使是单编模块，Soong（Kati）也不得不确认目标模块以外的路径是否需要重新跟随编译</strong>。</li></ol></li><li>验证编译配置文件的合法性、有效性、时效性、是否应该加入编译，生成.ninja<ol><li>如果没有任何更改，.ninja不需要重新生成</li><li><strong>最终生成的.ninja文件很大（In my case，1GB以上），有很明显的IO性能效率问题，显然在查询效率方面也很低下</strong></li></ol></li><li>最后一步，真正执行编译，调用ninja进入多线程编译<ol><li>由于Android加入了大量的代码编译期工作，如API权限控制检查、API列表生成等工作（比如，生成系统API保护名单、插桩工作等等），因此编译过程实际上不是完全投入到编译中</li><li>编译过程穿插“泛打包工作”，如生成odex、art、res资源打包。虽然不同的“泛打包”可以多线程并行进行，但是每个打包本身只能单线程进行</li></ol></li></ol><p>下面将基于模块单编（因开发环境系统全新编译场景频率较低，不予考虑），对这四个关键阶段进行性能分析。</p><h2 id="阶段一：Soong-bootstrap"><a href="#阶段一：Soong-bootstrap" class="headerlink" title="阶段一：Soong bootstrap"></a>阶段一：Soong bootstrap</h2><p>在系统已经整编过一次的情况下，Soong已经完成了编译，因此其预热过程占整个编译时间的比例会比较小。</p><p>在“环境”下，修改一行Framework代码触发差异进行编译。并且使用下面的命令进行编译。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">time</span> m services framework -j<span class="number">57</span></span><br></pre></td></tr></table></figure><p>编译实际耗时22m37s：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">build</span> completed successfully (<span class="number">22</span>:<span class="number">37</span> (mm:ss)) ####</span><br><span class="line"><span class="attribute">real</span>    <span class="number">22</span>m<span class="number">37</span>.<span class="number">504</span>s</span><br><span class="line"><span class="attribute">user</span>    <span class="number">110</span>m<span class="number">25</span>.<span class="number">656</span>s</span><br><span class="line"><span class="attribute">sys</span>     <span class="number">12</span>m<span class="number">28</span>.<span class="number">056</span>s</span><br></pre></td></tr></table></figure><p>对应的分阶段耗时如下图。</p><ul><li>可以看到，包括Soong bootstrap流程在内的预热耗时占比非常低，耗时约为11.6s，总耗时约为1357s，预热耗时占比为<code>0.8%</code>。</li></ul><p><img src="https://s2.loli.net/2022/08/08/kxlQBKUAeN1CMpW.png" alt="Soong编译耗时占比"></p><ul><li>Kati和ninja，也就是上述编译关键流程的第2步和第3步，分别占了接近60%（820秒，13分钟半）和约35%（521秒，8分钟半）的耗时，合计占比接近95%的耗时。</li></ul><p><strong>注：这个耗时是仅小幅度修改Java代码后测试的耗时。如果修改编译配置文件如Android.mk，会有更大的耗时。</strong></p><p>小结：看来在完成一次整编后的模块单编，包括Soong bootstrap、执行编译准备脚本、vendorsetup脚本的耗时占比很低，可以完全排除存在性能瓶颈的可能。</p><h2 id="阶段二：Kati遍历、mk搜集与ninja生成"><a href="#阶段二：Kati遍历、mk搜集与ninja生成" class="headerlink" title="阶段二：Kati遍历、mk搜集与ninja生成"></a>阶段二：Kati遍历、mk搜集与ninja生成</h2><p>从上图可以看到，<code>Kati</code>耗时占比很大，它的任务是遍历源码树，收集所有的编译配置文件，经过验证和筛选后，将它们解析并转化为<code>.ninja</code>。</p><p>从性能角度来看，它的主要特点如下：</p><ol><li>它要遍历源码树，收集所有mk文件（In my case，有983个mk文件）</li><li>解析mk文件（In my case，framework&#x2F;base&#x2F;Android.mk耗费了~6800ms）</li><li>生成并写入对应的.ninja</li><li>单线程</li></ol><p>直观展示如下，它是一个单线程的、IO速度敏感、CPU不敏感的过程：</p><p><img src="https://s2.loli.net/2022/08/08/2KYmOSuU17dZGMq.png" alt="Soong编译-Kati耗时细节.png"></p><p>Kati串行地处理文件，此时对CPU利用率很低，对IO的压力也不高。</p><p>小结：可以确定它的性能瓶颈来源于IO速度，单纯为编译实例分配更多的CPU资源也无益于提升Kati的速度。</p><h2 id="阶段三：Ninja编译"><a href="#阶段三：Ninja编译" class="headerlink" title="阶段三：Ninja编译"></a>阶段三：Ninja编译</h2><p><code>Soong</code>Clone了一份<code>GNU Make</code>，并将其改造为<code>Kati</code>。即使我们没有修改任何mk文件，前面<code>Kati</code>仍然会花费数分钟到数十分钟的工作耗时，只为了生成一份能够被<code>Ninja</code>或<code>.ninja</code>的生成工具能够识别的文件。接下来是调用<code>Ninja</code>真正开始编译工作。</p><p>从性能角度来看，它的主要特点如下：</p><ol><li>根据目标target及依赖，读取前面生成的.ninja配置，进行编译</li><li>比较独立，不与前面的组件，如blueprint、kati等耦合，只要<code>.ninja</code>文件中能找到target和build rule就能完成编译</li><li>多线程</li></ol><p>直观展示如下，<code>Ninja</code>将会根据传入的并行任务数参数启动对应数量的线程进行编译。<code>Ninja</code>编译阶段会真正的启动多线程。但做不到一直多线程编译，因为部分阶段如部分编译目标（比如生成一个API文档）、泛打包阶段等本身无法多线程并行执行。</p><p><img src="https://s2.loli.net/2022/08/08/p4bnkJmearyzVZG.png" alt="Soong编译-ninja耗时.png"></p><blockquote><p>可以看到此时CPU利用率应该是可以明显上升的。但是耗时较大的阶段仅启用了几个线程，后面的阶段和最后的图形很细（时间占比很小）的阶段才用起来更多的线程。</p></blockquote><blockquote><p>其中，一些阶段（图中时间占比较长的几条记录）没能跑满资源的原因是这些编译目标本身不支持并行，且本次编译命令指定的目标已经全部“安排”了，不需要调动更多资源启动其他编译目标的工作。当编译整个系统时就能够跑满了。</p></blockquote><blockquote><p>最后一个阶段（图中最后的几列很细的记录）虽然跑满了所有线程资源，但是运行时间很短。这是因为本case进行编译分析的过程中，仅修改了一行代码来触发编译。因编译工作量很小，所以这几列很细。</p></blockquote><p>小结：我们看到，<code>Ninja</code>编译启动比较快，这<strong>表明<code>Ninja</code>对<code>.ninja</code>文件的读取解析并不敏感</strong>。整个过程也没有看到显著的耗时点。且最后面编译量很小，表明<code>Ninja</code>能够确保增量编译、未更新不编译。</p><h1 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h1><p>本节完成点题——Android系统编译优化：使用Ninja加快编译。</p><p>根据前面分析的小结，可以总结性能瓶颈:</p><ol><li>Kati遍历、生成太慢，受限于IO速率</li><li>Kati吞吐量太低，单线程</li><li>不论有无更新均重新解析Makefile</li></ol><p>利用<code>Ninja</code>进行编译优化的思路是，<strong>大多数场景，可以舍弃Kati的工作，仅执行Ninja的工作，以节省掉60%以上的时间</strong>。其<strong>核心思路，也是制约条件，即在不影响编译正确性的前提下，舍弃不必要的Kati编译工作</strong>。</p><ul><li>使用<code>Ninja</code>直接基于<code>.ninja</code>文件进行编译来改善耗时：</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"><span class="function"><span class="title">make</span>--&gt;</span>Soong</span><br><span class="line">S<span class="function"><span class="title">oong</span>--&gt;</span>Kati</span><br><span class="line">K<span class="function"><span class="title">ati</span>--&gt;</span>.ninja</span><br><span class="line">.<span class="function"><span class="title">ninja</span>--&gt;</span>Ninja</span><br><span class="line">N<span class="function"><span class="title">inja</span>--&gt;</span>TARGET</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ninja</span>--&gt;</span>Ninja</span><br></pre></td></tr></table></figure><p>结合前面的分析，容易想到，如果目标被构建前，能够确保mk文件没有更新也不需要重新生成一长串的最终编译目标（即.ninja），那么<code>make</code>命令带来的Soong bootstrap、Kati等工作完全是重复的冗余的——这个性质Soong和Kati自己识别不出来，它们会重复工作一次。</p><p>既重新生成.ninja是冗余的，那么直接命令编译系统根据指定的.ninja进行编译显然会节省大量的工作耗时。ninja命令is the key:</p><p>使用源码中自带的ninja:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/prebuilts/</span>build-tools<span class="regexp">/linux-x86/</span>bin/ninja --version</span><br><span class="line"><span class="number">1.8</span>.<span class="number">2</span>.git</span><br></pre></td></tr></table></figure><p>对比最上面列出的<code>make</code>命令的编译，这里用ninja编译同样的目标：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time .<span class="regexp">/prebuilts/</span>build-tools<span class="regexp">/linux-x86/</span>bin<span class="regexp">/ninja -j 57 -v -f out/</span>combined-full_xxxxxx.ninja services framework</span><br></pre></td></tr></table></figure><blockquote><p>ninja自己识别出来CPU平台后，默认使用-j58。这里为了对比上面的m命令，使用-j57编译</p></blockquote><blockquote><p>-f参数指定.ninja文件。它是编译配置文件，在Android中由Kati生成。这里文件名用’x’替换修改</p></blockquote><p>编译结果，对比上面的<code>m</code>，有三倍的提升：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">real</span>    <span class="number">7</span>m<span class="number">57</span>.<span class="number">835</span>s</span><br><span class="line"><span class="attribute">user</span>    <span class="number">97</span>m<span class="number">12</span>.<span class="number">564</span>s</span><br><span class="line"><span class="attribute">sys</span>     <span class="number">8</span>m<span class="number">31</span>.<span class="number">756</span>s</span><br></pre></td></tr></table></figure><p><strong>编译耗时为8分半，仅make的三分之一</strong>。As we can see，当<strong>能够确保编译配置没有更新，变更仅存在于源码范围时，使用Ninja直接编译，跳过Kati可以取得很显著的提升</strong>。</p><p>直接使用ninja:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/prebuilts/</span>build-tools<span class="regexp">/linux-x86/</span>bin<span class="regexp">/ninja -j $MAKE_JOBS -v -f out/</span>combined-*.ninja &lt;targets...&gt;</span><br></pre></td></tr></table></figure><h1 id="对比汇总"><a href="#对比汇总" class="headerlink" title="对比汇总"></a>对比汇总</h1><p>这里找了一个其他项目的编译Demo，该Demo的特点是本身代码较简单，编译配置也较简单，整体编译工作较少，通过make编译的大部分耗时来自soong、make等<strong>工具自身的消耗，而真正执行编译的ninja耗时占比极其低</strong>。由于ninja本身跳过了soong，因此可以跳过这一无用的繁琐的耗时。可以看到下面，ninja编译iperf仅花费10秒。这个时间如果给soong来编译，预热都不够。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ -&gt; f_ninja_msf iperf</span><br><span class="line">Run ninja with out/combined-full_xxxxxx.ninja to build iperf.</span><br><span class="line">====== ====== ======</span><br><span class="line">Ninja: .<span class="regexp">/prebuilts/</span>build-tools<span class="regexp">/linux-x86/</span>bin/ninja@<span class="number">1.8</span>.<span class="number">2</span>.git</span><br><span class="line">Ninja: build with out/combined-full_xxxxxx.ninja</span><br><span class="line">Ninja: build targets iperf</span><br><span class="line">Ninja: j72</span><br><span class="line">====== ====== ======</span><br><span class="line">time <span class="regexp">/usr/</span>bin<span class="regexp">/time ./</span>prebuilts<span class="regexp">/build-tools/</span>linux-x86<span class="regexp">/bin/</span>ninja -j <span class="number">72</span> -f out/combined-full_xxxxxx.ninja iperf</span><br><span class="line"></span><br><span class="line">[<span class="number">24</span><span class="regexp">/24] Install: out/</span>target<span class="regexp">/product/</span>xxxxxx<span class="regexp">/system/</span>bin/iperf</span><br><span class="line"><span class="number">53.62</span>user <span class="number">11.09</span>system <span class="number">0</span>:<span class="number">10.17</span>elapsed <span class="number">636</span>%CPU (<span class="number">0</span>avgtext+<span class="number">0</span>avgdata <span class="number">5696772</span>maxresident)</span><br><span class="line"><span class="number">4793472</span>inputs+<span class="number">5992</span>outputs (<span class="number">4713</span>major+<span class="number">897026</span>minor)pagefaults <span class="number">0</span>swaps</span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m10.<span class="number">174</span>s</span><br><span class="line">user    <span class="number">0</span>m53.<span class="number">624</span>s</span><br><span class="line">sys     <span class="number">0</span>m11.<span class="number">096</span>s</span><br></pre></td></tr></table></figure><p>下面给出soong编译的恐怖耗时：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ -&gt; rm out<span class="regexp">/target/</span>product<span class="regexp">/xxxxxx/</span>system<span class="regexp">/bin/i</span>perf</span><br><span class="line">$ -&gt; time m iperf -j72</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[<span class="number">100</span>% <span class="number">993</span><span class="regexp">/993] Install: out/</span>target<span class="regexp">/product/</span>xxxxxx<span class="regexp">/system/</span>bin/iperf</span><br><span class="line"></span><br><span class="line"><span class="comment">#### build completed successfully (14:45 (mm:ss)) ####</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">real    <span class="number">14</span>m45.<span class="number">164</span>s</span><br><span class="line">user    <span class="number">23</span>m40.<span class="number">616</span>s</span><br><span class="line">sys     <span class="number">11</span>m46.<span class="number">248</span>s</span><br></pre></td></tr></table></figure><blockquote><p>As we can see，m和ninja一个是10+ minutes，一个是10+ seconds，比例是88.5倍。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;10:34 am&lt;br&gt;Monday, 8 August 2022 (GMT+8)&lt;br&gt;Time in Guangzhou, Guangdong Province, China&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%9</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    <category term="工具" scheme="https://nasdaqgodzilla.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="性能优化" scheme="https://nasdaqgodzilla.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android动态日志ProtoLog原理与架构: How ProtoLogTool works</title>
    <link href="https://nasdaqgodzilla.github.io/2022/07/08/Android%E5%8A%A8%E6%80%81%E6%97%A5%E5%BF%97ProtoLog%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9E%B6%E6%9E%84-How-ProtoLogTool-works/"/>
    <id>https://nasdaqgodzilla.github.io/2022/07/08/Android%E5%8A%A8%E6%80%81%E6%97%A5%E5%BF%97ProtoLog%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9E%B6%E6%9E%84-How-ProtoLogTool-works/</id>
    <published>2022-07-08T07:05:23.000Z</published>
    <updated>2022-08-29T11:29:39.197Z</updated>
    
    <content type="html"><![CDATA[<hr><p>11:33 am<br>Thursday, 7 July 2022 (GMT+8)<br>Time in Guangzhou, Guangdong Province, China</p><hr><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E5%8E%9F%E7%90%86">原理</a><ul><li><a href="#%E7%BC%96%E8%AF%91">编译</a></li><li><a href="#ProtoLogTool">ProtoLogTool</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文基于Android 11介绍动态日志<code>ProtoLog</code>的实现原理。</p><p><code>ProtoLog</code>在<strong>编译期插入代码，用于实现动态启停的判断逻辑</strong>，在<strong>编译期实现字符串哈希管理，用于实现日志数据量的压缩</strong>。执行这些工作的主要工具是<code>ProtoLogTool</code>。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>本节介绍<code>ProtoLog</code>在编译期的工作、以及动态启停的实现。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在Framework Services编译过程中，会执行动态日志相关的编译。关键的编译配置在<code>framework/services/core/Android.bp</code>中，如下。可以看到，services在编译过程中会调用<code>protologtool</code>。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">genrule &#123;</span><br><span class="line">    <span class="attribute">name</span>: &quot;services<span class="variable">.core</span><span class="variable">.protologsrc</span>&quot;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;:services<span class="variable">.core</span><span class="variable">.wm</span><span class="variable">.protologgroups</span>&quot;,</span><br><span class="line">        &quot;:services<span class="variable">.core-sources</span>&quot;,</span><br><span class="line">    ],</span><br><span class="line">    tools: [&quot;protologtool&quot;],</span><br><span class="line">    cmd: &quot;$(location protologtool) transform-protolog-calls &quot; +</span><br><span class="line">      &quot;--protolog-class com<span class="variable">.android</span><span class="variable">.server</span><span class="variable">.protolog</span><span class="variable">.common</span><span class="variable">.ProtoLog</span> &quot; +</span><br><span class="line">      &quot;--protolog-impl-class com<span class="variable">.android</span><span class="variable">.server</span><span class="variable">.protolog</span><span class="variable">.ProtoLogImpl</span> &quot; +</span><br><span class="line">      &quot;--protolog-cache-class &#x27;com<span class="variable">.android</span><span class="variable">.server</span><span class="variable">.protolog</span><span class="variable">.ProtoLog</span>$$Cache&#x27; &quot; +</span><br><span class="line">      &quot;--loggroups-class com<span class="variable">.android</span><span class="variable">.server</span><span class="variable">.wm</span><span class="variable">.ProtoLogGroup</span> &quot; +</span><br><span class="line">      &quot;--loggroups-jar $(location :services<span class="variable">.core</span><span class="variable">.wm</span><span class="variable">.protologgroups</span>) &quot; +</span><br><span class="line">      &quot;--output-srcjar $(out) &quot; +</span><br><span class="line">      &quot;$(locations :services<span class="variable">.core-sources</span>)&quot;,</span><br><span class="line">    out: [&quot;services<span class="variable">.core</span><span class="variable">.protolog</span><span class="variable">.srcjar</span>&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>protologtool</code>的编译配置如下。它通过<code>javaparser</code>将源码中<code>ProtoLog</code>相关的调用进行替换，并通过<code>jsonlib</code>生成Config、通过<code>platformprotos</code>提供ProtoBuf支持。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">java_library_host </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">&quot;protologtool-lib&quot;</span>,</span><br><span class="line"><span class="symbol">    srcs:</span> [</span><br><span class="line">        <span class="string">&quot;src/com/android/protolog/tool/**/*.kt&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line"><span class="symbol">    static_libs:</span> [</span><br><span class="line">        <span class="string">&quot;protolog-common&quot;</span>,</span><br><span class="line">        <span class="string">&quot;javaparser&quot;</span>,</span><br><span class="line">        <span class="string">&quot;platformprotos&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jsonlib&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">java_binary_host </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">&quot;protologtool&quot;</span>,</span><br><span class="line"><span class="symbol">    manifest:</span> <span class="string">&quot;manifest.txt&quot;</span>,</span><br><span class="line"><span class="symbol">    static_libs:</span> [</span><br><span class="line">        <span class="string">&quot;protologtool-lib&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，**<code>ProtoLog</code>会借助<code>ProtoLogTool</code>在编译期通过<code>JavaParser</code>将动态日志进行实现**。下面分析<code>ProtoLogTool</code>即可了解<code>ProtoLog</code>的实现了。</p><h2 id="ProtoLogTool"><a href="#ProtoLogTool" class="headerlink" title="ProtoLogTool"></a>ProtoLogTool</h2><p><code>ProtoLogTool</code>主要负责三大重要事务。<strong>一是找到源码中<code>ProtoLog</code>的调用；二是将<code>ProtoLog</code>调用替换为真正的动态日志实现，这个过程会执行日志数据量压缩工作所要求的哈希计算和引用替换；三是将生成对应的哈希-字符串Map、Group、TAG到Json中——称为Config，没有该文件的情况下是无法解析ProtoBuf的</strong>。</p><p>其中，找到<code>ProtoLog</code>的调用、替换调用等功能一般会基于源码词法分析或字节码分析、插桩。<code>ProtoLog</code>采用的是<code>JavaParser</code>，它是源码级的Analyse、Transform工具。</p><p><code>ProtoLogTool</code>关键流程如下（源码可以参考“参考”节中列出的源码地址）。<code>ProtoLogTool</code>将三个关键步骤分为对应的三个分支流程，包括生成Config、解析读取PB文件以及编译处理。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">fun</span> <span class="function"><span class="title">invoke</span>(<span class="variable">command</span>: <span class="variable">CommandOptions</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">StaticJavaParser.setConfiguration</span>(<span class="title">ParserConfiguration</span>().apply &#123;</span></span><br><span class="line"><span class="function">        <span class="title">setLanguageLevel</span>(<span class="variable">ParserConfiguration.LanguageLevel.RAW</span>)</span></span><br><span class="line">        <span class="function"><span class="title">setAttributeComments</span>(<span class="variable"><span class="literal">false</span></span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable">when</span> (<span class="variable">command.command</span>) &#123;</span><br><span class="line">        <span class="variable">CommandOptions.TRANSFORM_CALLS_CMD</span> -&gt; <span class="function"><span class="title">processClasses</span>(<span class="variable">command</span>)</span></span><br><span class="line">        <span class="variable">CommandOptions.GENERATE_CONFIG_CMD</span> -&gt; <span class="function"><span class="title">viewerConf</span>(<span class="variable">command</span>)</span></span><br><span class="line">        <span class="variable">CommandOptions.READ_LOG_CMD</span> -&gt; <span class="function"><span class="title">read</span>(<span class="variable">command</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>processClasses()</code>是决定动态日志功能实现的关键。阅读源码可知，它<strong>通过<code>JavaParser</code>实现了源码级插桩</strong>。细节是找到所有<code>ProtoLog</code>的日志方法的调用，然后通过Transformer进行源码级别的替换。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">processClasses</span><span class="params">(command: <span class="type">CommandOptions</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> groups = injector.readLogGroups(</span><br><span class="line">            command.protoLogGroupsJarArg,</span><br><span class="line">            command.protoLogGroupsClassNameArg)</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">out</span> = injector.fileOutputStream(command.outputSourceJarArg)</span><br><span class="line">    <span class="keyword">val</span> outJar = JarOutputStream(<span class="keyword">out</span>)</span><br><span class="line">    <span class="keyword">val</span> processor = ProtoLogCallProcessor(command.protoLogClassNameArg,</span><br><span class="line">            command.protoLogGroupsClassNameArg, groups)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> executor = newThreadPool()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        command.javaSourceArgs.map &#123; path -&gt;</span><br><span class="line">            executor.submitCallable &#123;</span><br><span class="line">                <span class="keyword">val</span> transformer = SourceTransformer(command.protoLogImplClassNameArg,</span><br><span class="line">                        command.protoLogCacheClassNameArg, processor)</span><br><span class="line">                <span class="keyword">val</span> file = File(path)</span><br><span class="line">                <span class="keyword">val</span> text = injector.readText(file)</span><br><span class="line">    ...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(code: <span class="type">CompilationUnit</span>, callVisitor: <span class="type">ProtoLogCallVisitor</span>?, fileName: <span class="type">String</span>)</span></span>:</span><br><span class="line">        CompilationUnit &#123;</span><br><span class="line">    CodeUtils.checkWildcardStaticImported(code, protoLogClassName, fileName)</span><br><span class="line">    CodeUtils.checkWildcardStaticImported(code, protoLogGroupClassName, fileName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isLogClassImported = CodeUtils.isClassImportedOrSamePackage(code, protoLogClassName)</span><br><span class="line">    <span class="keyword">val</span> staticLogImports = CodeUtils.staticallyImportedMethods(code, protoLogClassName)</span><br><span class="line">    <span class="keyword">val</span> isGroupClassImported = CodeUtils.isClassImportedOrSamePackage(code,</span><br><span class="line">            protoLogGroupClassName)</span><br><span class="line">    <span class="keyword">val</span> staticGroupImports = CodeUtils.staticallyImportedMethods(code, protoLogGroupClassName)</span><br><span class="line"></span><br><span class="line">    code.findAll(MethodCallExpr::<span class="keyword">class</span>.java)</span><br><span class="line">            .filter &#123; call -&gt;</span><br><span class="line">                isProtoCall(call, isLogClassImported, staticLogImports)</span><br><span class="line">            &#125;.forEach &#123; call -&gt;</span><br><span class="line">                <span class="keyword">val</span> context = ParsingContext(fileName, call)</span><br><span class="line">                <span class="keyword">if</span> (call.arguments.size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> InvalidProtoLogCallException(<span class="string">&quot;Method signature does not match &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;any ProtoLog method: <span class="variable">$call</span>&quot;</span>, context)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> messageString = CodeUtils.concatMultilineString(call.getArgument(<span class="number">1</span>),</span><br><span class="line">                        context)</span><br><span class="line">                <span class="keyword">val</span> groupNameArg = call.getArgument(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> groupName =</span><br><span class="line">                        getLogGroupName(groupNameArg, isGroupClassImported,</span><br><span class="line">                                staticGroupImports, fileName)</span><br><span class="line">                <span class="keyword">if</span> (groupName !<span class="keyword">in</span> groupMap) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> InvalidProtoLogCallException(<span class="string">&quot;Unknown group argument &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;- not a ProtoLogGroup enum member: <span class="variable">$call</span>&quot;</span>, context)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                callVisitor?.processCall(call, messageString, LogLevel.getLevelForMethodName(</span><br><span class="line">                        call.name.toString(), call, context), groupMap.getValue(groupName))</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>可以看到，<code>ProtoLogTool</code>为了实现日志压缩，会将字符串做哈希替换，并将日志打印方法替换为真正具有动态能力的实现。这是源码级别的插桩，它通过JavaParser实现。如果熟悉JavaParser容易读懂代码。</p><p>下面看看经过<code>ProtoLogTool</code>处理后的产物，看看<code>ProtoLog</code>的动态能力的技术原理。</p><p>反编译service.jar，找一个<code>ProtoLog</code>的案例。如下，以<code>DisplayPolicy.finishScreenTurningOn()</code>为例。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> finishScreenTurningOn() &#123;</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    ProtoLog.i(WM_DEBUG_SCREEN_ON, <span class="string">&quot;Finished screen turning on...&quot;</span>);</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的代码如下（从dex反编译而来，只列出ProtoLog部分）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!protoLogParam02 &amp;&amp; <span class="keyword">this</span>.mScreenOnEarly &amp;&amp; <span class="keyword">this</span>.mWindowManagerDrawComplete &amp;&amp; (!<span class="keyword">this</span>.mAwake || <span class="keyword">this</span>.mKeyguardDrawComplete)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ProtoLog.Cache.WM_DEBUG_SCREEN_ON_enabled) &#123;</span><br><span class="line">        ProtoLogImpl.i(ProtoLogGroup.WM_DEBUG_SCREEN_ON, <span class="number">1140424002</span>, <span class="number">0</span>, (String) <span class="literal">null</span>, (Object[]) <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mScreenOnListener = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mScreenOnFully = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到，动态日志的动态能力实现的基本思路是判断一个开关是否被打开，该开关控制了对应的动态日志打印代码是否被执行</p></li><li><p>动态日志打印方法<code>ProtoLog</code>实际上被替换成了<code>ProtoLogImpl</code>，并且不再直接使用字符串，而是使用了一个整型常量</p></li><li><p>动态日志开关</p></li></ul><p>动态日志开关（即上面的WM_DEBUG_SCREEN_ON_enabled）是由<code>ProtoLogImpl</code>在编译期生成的。该值是<code>Group</code>内的一个属性，并有<code>IProtoLogGroup</code>接口用作动态设置：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IProtoLogGroup &#123;</span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">getTag</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLogToLogcat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLogToProto</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLogToLogcat</span><span class="params">(<span class="keyword">boolean</span> z)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLogToProto</span><span class="params">(<span class="keyword">boolean</span> z)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isLogToAny</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isLogToLogcat</span>() || <span class="built_in">isLogToProto</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowMangager暴露了adb ShellCommand接口用于接收动态日志的启停命令：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/protolog/ProtoLogImpl.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> set<span class="constructor">Logging(ShellCommand <span class="params">shell</span>, <span class="params">boolean</span> <span class="params">setTextLogging</span>, <span class="params">boolean</span> <span class="params">value</span>)</span> &#123;</span><br><span class="line">        String group;</span><br><span class="line">        <span class="keyword">while</span> ((group = shell.get<span class="constructor">NextArg()</span>) != null) &#123;</span><br><span class="line">            IProtoLogGroup g = <span class="module-access"><span class="module"><span class="identifier">LOG_GROUPS</span>.</span></span>get(group);</span><br><span class="line">            <span class="keyword">if</span> (g != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setTextLogging) &#123;</span><br><span class="line">                    g.set<span class="constructor">LogToLogcat(<span class="params">value</span>)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    g.set<span class="constructor">LogToProto(<span class="params">value</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log<span class="constructor">AndPrintln(<span class="params">shell</span>.<span class="params">getOutPrintWriter</span>()</span>, <span class="string">&quot;No IProtoLogGroup named &quot;</span> + group);</span><br><span class="line">                return -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sCacheUpdater.run<span class="literal">()</span>;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="built_in">int</span> on<span class="constructor">ShellCommand(ShellCommand <span class="params">shell</span>)</span> &#123;</span><br><span class="line">        PrintWriter pw = shell.get<span class="constructor">OutPrintWriter()</span>;</span><br><span class="line">        String cmd = shell.get<span class="constructor">NextArg()</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmd<span class="operator"> == </span>null) &#123;</span><br><span class="line">            return unknown<span class="constructor">Command(<span class="params">pw</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">            case <span class="string">&quot;start&quot;</span>:</span><br><span class="line">                start<span class="constructor">ProtoLog(<span class="params">pw</span>)</span>;</span><br><span class="line">                return <span class="number">0</span>;</span><br><span class="line">            case <span class="string">&quot;stop&quot;</span>:</span><br><span class="line">                stop<span class="constructor">ProtoLog(<span class="params">pw</span>, <span class="params">true</span>)</span>;</span><br><span class="line">                return <span class="number">0</span>;</span><br><span class="line">            case <span class="string">&quot;status&quot;</span>:</span><br><span class="line">                log<span class="constructor">AndPrintln(<span class="params">pw</span>, <span class="params">getStatus</span>()</span>);</span><br><span class="line">                return <span class="number">0</span>;</span><br><span class="line">            case <span class="string">&quot;enable&quot;</span>:</span><br><span class="line">                return set<span class="constructor">Logging(<span class="params">shell</span>, <span class="params">false</span>, <span class="params">true</span>)</span>;</span><br><span class="line">            case <span class="string">&quot;enable-text&quot;</span>:</span><br><span class="line">                mViewerConfig.load<span class="constructor">ViewerConfig(<span class="params">pw</span>, VIEWER_CONFIG_FILENAME)</span>;</span><br><span class="line">                return set<span class="constructor">Logging(<span class="params">shell</span>, <span class="params">true</span>, <span class="params">true</span>)</span>;</span><br><span class="line">            case <span class="string">&quot;disable&quot;</span>:</span><br><span class="line">                return set<span class="constructor">Logging(<span class="params">shell</span>, <span class="params">false</span>, <span class="params">false</span>)</span>;</span><br><span class="line">            case <span class="string">&quot;disable-text&quot;</span>:</span><br><span class="line">                return set<span class="constructor">Logging(<span class="params">shell</span>, <span class="params">true</span>, <span class="params">false</span>)</span>;</span><br><span class="line">            default:</span><br><span class="line">                return unknown<span class="constructor">Command(<span class="params">pw</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：ProtoLog动态启停的原理是以一个个的Group的开关为桥梁的。动态日志打印前会判断这个开关，并能够通过ShellCommand这一接口实时设置开关值。其中，对开关的判断和管理代码均是由<code>ProtoLogTool</code>在编译期完成生成的，属于源码级Transform，并不需要用户手动添加难看的开关判断逻辑。</p><ul><li>日志数据量压缩</li></ul><p>可以看到<code>ProtoLogTool</code>除了将<code>ProtoLog</code>替换成<code>ProtoLogImpl</code>外，还将打印的字符串替换成哈希值。<code>ProtoLogImpl</code>实现数据量压缩的原理如下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void i(IProtoLogGroup group, <span class="built_in">int</span> messageHash, <span class="built_in">int</span> paramsMask,</span><br><span class="line">        @Nullable String messageString,</span><br><span class="line">        Object... args) &#123;</span><br><span class="line">    get<span class="constructor">SingleInstance()</span>.log(LogLevel.INFO, group, messageHash, paramsMask, messageString, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void log(LogLevel level, IProtoLogGroup group, <span class="built_in">int</span> messageHash, <span class="built_in">int</span> paramsMask,</span><br><span class="line">        @Nullable String messageString, Object<span class="literal">[]</span> args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (group.is<span class="constructor">LogToProto()</span>) &#123;</span><br><span class="line">        log<span class="constructor">ToProto(<span class="params">messageHash</span>, <span class="params">paramsMask</span>, <span class="params">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (group.is<span class="constructor">LogToLogcat()</span>) &#123;</span><br><span class="line">        log<span class="constructor">ToLogcat(<span class="params">group</span>.<span class="params">getTag</span>()</span>, level, messageHash, messageString, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void log<span class="constructor">ToProto(<span class="params">int</span> <span class="params">messageHash</span>, <span class="params">int</span> <span class="params">paramsMask</span>, Object[] <span class="params">args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is<span class="constructor">ProtoEnabled()</span>) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ProtoOutputStream os = <span class="keyword">new</span> <span class="constructor">ProtoOutputStream()</span>;</span><br><span class="line">        long token = os.start(LOG);</span><br><span class="line">        os.write(MESSAGE_HASH, messageHash);</span><br><span class="line">        os.write(ELAPSED_REALTIME_NANOS, <span class="module-access"><span class="module"><span class="identifier">SystemClock</span>.</span></span>elapsed<span class="constructor">RealtimeNanos()</span>)<span class="operator"></span></span><br><span class="line"><span class="operator">        ...</span></span><br><span class="line"><span class="operator">    </span>...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志数据量压缩的关键逻辑就是<code>ProtoOutputStream.write(MESSAGE_HASH,messageHash)</code>了。<strong>可见，Message确实被<code>ProtoLogTool</code>转化成了对应的哈希，并通过<code>ProtoOutputStream</code>写入到<code>ProtoBuf</code>中，最后输出成为二进制日志</strong>。这就是日志数据量压缩的基本原理——<strong>日志不再存储字符串本身，而是存储字符串的哈希。解析器根据字符串与哈希的映射，反向操作解析出字符串</strong>。这样做能够使冗余的字符串（一个日志打印方法在业务逻辑中、进程运行过程中会多次调用，使日志存储重复的冗余的串）被替换成定长的简短的哈希。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>ProtoLog</code>提供的简单接口，需要在编译期由<code>ProtoLogTool</code>进行源码级的替换，生成对日志开关的检查代码来实现动态日志。并通过哈希-String映射实现数据量压缩。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/services/core/Android.bp">Android Framework Service.core Android.bp</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/tools/protologtool/src/com/android/protolog/tool/ProtoLogTool.kt">ProtoLogTool</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;11:33 am&lt;br&gt;Thursday, 7 July 2022 (GMT+8)&lt;br&gt;Time in Guangzhou, Guangdong Province, China&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A6%82%E8%B</summary>
      
    
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/categories/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/categories/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
    
    <category term="Android" scheme="https://nasdaqgodzilla.github.io/tags/Android/"/>
    
    <category term="Android稳定性" scheme="https://nasdaqgodzilla.github.io/tags/Android%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
  </entry>
  
</feed>
